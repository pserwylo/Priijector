# 1 "/home/pete/code/liiner/src/GameApplication.cpp"
# 1 "/home/pete/code/liiner/build_wii_release//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/home/pete/code/liiner/src/GameApplication.cpp"







# 1 "/home/pete/code/liiner/src/GameApplication.h" 1
# 11 "/home/pete/code/liiner/src/GameApplication.h"
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireApplication.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireApplication.h"
       



# 1 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h"
       



# 1 "/home/pete/code/wire3d/Wire/Engine/WireBoundingVolume.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireBoundingVolume.h"
       



# 1 "/home/pete/code/wire3d/Wire/Engine/WireObject.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireObject.h"
       



# 1 "/home/pete/code/wire3d/Wire/Engine/WireRtti.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireRtti.h"
       



# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTypes.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireTypes.h"
       



typedef bool Bool;
typedef char Char;
typedef double Double;
typedef float Float;
typedef int Int;
typedef long Long;
typedef long long LongLong;
typedef short Short;
typedef unsigned char UChar;
typedef unsigned int UInt;
typedef unsigned long ULong;
typedef unsigned long long ULongLong;
typedef unsigned short UShort;
# 14 "/home/pete/code/wire3d/Wire/Engine/WireRtti.h" 2

namespace Wire
{

class Rtti
{

public:
 Rtti(const Char* pName, const Rtti* pBaseType);
 ~Rtti();

 inline const Char* GetName () const;
 inline Bool IsExactly(const Rtti& rType) const;
 Bool IsDerived(const Rtti& rType) const;

private:
 const Char* mpName;
 const Rtti* mpBaseType;
};

# 1 "/home/pete/code/wire3d/Wire/Engine/WireRtti.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireRtti.inl"
inline const Char* Rtti::GetName() const
{
 return mpName;
}


inline Bool Rtti::IsExactly(const Rtti& rType) const
{
 return &rType == this;
}
# 35 "/home/pete/code/wire3d/Wire/Engine/WireRtti.h" 2

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireObject.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireSmartPointer.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireSmartPointer.h"
       



# 1 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h"
       
# 22 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h"
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 1 3




# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 1 3
# 9 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
extern "C" {



# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/_ansi.h" 1 3
# 15 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/_ansi.h" 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/newlib.h" 1 3
# 16 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/_ansi.h" 2 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/config.h" 1 3



# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/ieeefp.h" 1 3
# 5 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/config.h" 2 3
# 17 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/_ansi.h" 2 3
# 14 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 2 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/_types.h" 1 3
# 12 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/_types.h" 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_types.h" 1 3






# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_default_types.h" 1 3
# 9 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_default_types.h" 3
extern "C" {
# 26 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 118 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_default_types.h" 3
}
# 8 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/_types.h" 2 3


typedef long long _fpos_t;


typedef long long _off_t;
# 13 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/_types.h" 2 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 47 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/lock.h" 3
extern int __libc_lock_init(int*,int);
extern int __libc_lock_close(int*);
extern int __libc_lock_acquire(int*);
extern int __libc_lock_try_acquire(int*);
extern int __libc_lock_release(int*);
# 14 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/_types.h" 2 3
# 24 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/_types.h" 3
typedef short __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;
# 56 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/_types.h" 3
typedef int _ssize_t;






# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stddef.h" 1 3 4
# 352 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 64 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 89 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 105 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 169 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                     ;
  int (* _write) (struct _reent *, void *, const char *, int)
                            ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _fpos_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 273 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 305 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 579 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  struct _atexit *_atexit;
  struct _atexit _atexit0;


  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 817 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr __attribute__((__section__(".sdata")));
extern struct _reent *const _global_impure_ptr __attribute__((__section__(".sdata")));

void _reclaim_reent (struct _reent *);
# 840 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/reent.h" 3
}
# 6 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 2 3

# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/_ansi.h" 1 3
# 8 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 2 3

extern "C" {




union __dmath
{
  double d;
  __ULong i[2];
};

union __fmath
{
  float f;
  __ULong i[1];
};


union __ldmath
{
  long double ld;
  __ULong i[4];
};
# 111 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 3
extern double atan (double);
extern double cos (double);
extern double sin (double);
extern double tan (double);
extern double tanh (double);
extern double frexp (double, int *);
extern double modf (double, double *);
extern double ceil (double);
extern double fabs (double);
extern double floor (double);






extern double acos (double);
extern double asin (double);
extern double atan2 (double, double);
extern double cosh (double);
extern double sinh (double);
extern double exp (double);
extern double ldexp (double, int);
extern double log (double);
extern double log10 (double);
extern double pow (double, double);
extern double sqrt (double);
extern double fmod (double, double);
# 148 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 3
typedef float float_t;
typedef double double_t;
# 175 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 3
extern int __isinff (float x);
extern int __isinfd (double x);
extern int __isnanf (float x);
extern int __isnand (double x);
extern int __fpclassifyf (float x);
extern int __fpclassifyd (double x);
extern int __signbitf (float x);
extern int __signbitd (double x);
# 235 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 3
extern double infinity (void);
extern double nan (const char *);
extern int finite (double);
extern double copysign (double, double);
extern double logb (double);
extern int ilogb (double);

extern double asinh (double);
extern double cbrt (double);
extern double nextafter (double, double);
extern double rint (double);
extern double scalbn (double, int);

extern double exp2 (double);
extern double scalbln (double, long int);
extern double tgamma (double);
extern double nearbyint (double);
extern long int lrint (double);
extern long long int llrint (double);
extern double round (double);
extern long int lround (double);
extern long long int llround (double);
extern double trunc (double);
extern double remquo (double, double, int *);
extern double fdim (double, double);
extern double fmax (double, double);
extern double fmin (double, double);
extern double fma (double, double, double);


extern double log1p (double);
extern double expm1 (double);



extern double acosh (double);
extern double atanh (double);
extern double remainder (double, double);
extern double gamma (double);
extern double lgamma (double);
extern double erf (double);
extern double erfc (double);
extern double log2 (double);



extern double hypot (double, double);






extern float atanf (float);
extern float cosf (float);
extern float sinf (float);
extern float tanf (float);
extern float tanhf (float);
extern float frexpf (float, int *);
extern float modff (float, float *);
extern float ceilf (float);
extern float fabsf (float);
extern float floorf (float);


extern float acosf (float);
extern float asinf (float);
extern float atan2f (float, float);
extern float coshf (float);
extern float sinhf (float);
extern float expf (float);
extern float ldexpf (float, int);
extern float logf (float);
extern float log10f (float);
extern float powf (float, float);
extern float sqrtf (float);
extern float fmodf (float, float);




extern float exp2f (float);
extern float scalblnf (float, long int);
extern float tgammaf (float);
extern float nearbyintf (float);
extern long int lrintf (float);
extern long long llrintf (float);
extern float roundf (float);
extern long int lroundf (float);
extern long long int llroundf (float);
extern float truncf (float);
extern float remquof (float, float, int *);
extern float fdimf (float, float);
extern float fmaxf (float, float);
extern float fminf (float, float);
extern float fmaf (float, float, float);

extern float infinityf (void);
extern float nanf (const char *);
extern int finitef (float);
extern float copysignf (float, float);
extern float logbf (float);
extern int ilogbf (float);

extern float asinhf (float);
extern float cbrtf (float);
extern float nextafterf (float, float);
extern float rintf (float);
extern float scalbnf (float, int);
extern float log1pf (float);
extern float expm1f (float);


extern float acoshf (float);
extern float atanhf (float);
extern float remainderf (float, float);
extern float gammaf (float);
extern float lgammaf (float);
extern float erff (float);
extern float erfcf (float);
extern float log2f (float);

extern float hypotf (float, float);






extern long double atanl (long double);
extern long double cosl (long double);
extern long double sinl (long double);
extern long double tanl (long double);
extern long double tanhl (long double);
extern long double frexpl (long double value, int *);
extern long double modfl (long double, long double *);
extern long double ceill (long double);
extern long double fabsl (long double);
extern long double floorl (long double);
extern long double log1pl (long double);
extern long double expm1l (long double);




extern long double acosl (long double);
extern long double asinl (long double);
extern long double atan2l (long double, long double);
extern long double coshl (long double);
extern long double sinhl (long double);
extern long double expl (long double);
extern long double ldexpl (long double, int);
extern long double logl (long double);
extern long double log10l (long double);
extern long double powl (long double, long double);
extern long double sqrtl (long double);
extern long double fmodl (long double, long double);
extern long double hypotl (long double, long double);


extern long double copysignl (long double, long double);
extern long double nanl (const char *);
extern int ilogbl (long double);
extern long double asinhl (long double);
extern long double cbrtl (long double);
extern long double nextafterl (long double, long double);
extern long double rintl (long double);
extern long double scalbnl (long double, int);
extern long double exp2l (long double);
extern long double scalblnl (long double, long);
extern long double tgammal (long double);
extern long double nearbyintl (long double);
extern long int lrintl (long double);
extern long long int llrintl (long double);
extern long double roundl (long double);
extern long lroundl (long double);
extern long long int llroundl (long double);
extern long double truncl (long double);
extern long double remquol (long double, long double, int *);
extern long double fdiml (long double, long double);
extern long double fmaxl (long double, long double);
extern long double fminl (long double, long double);
extern long double fmal (long double, long double, long double);

extern long double acoshl (long double);
extern long double atanhl (long double);
extern long double remainderl (long double, long double);
extern long double lgammal (long double);
extern long double erfl (long double);
extern long double erfcl (long double);
# 439 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 3
extern double cabs();
extern double drem (double, double);
extern void sincos (double, double *, double *);
extern double gamma_r (double, int *);
extern double lgamma_r (double, int *);

extern double y0 (double);
extern double y1 (double);
extern double yn (int, double);
extern double j0 (double);
extern double j1 (double);
extern double jn (int, double);

extern float cabsf();
extern float dremf (float, float);
extern void sincosf (float, float *, float *);
extern float gammaf_r (float, int *);
extern float lgammaf_r (float, int *);

extern float y0f (float);
extern float y1f (float);
extern float ynf (int, float);
extern float j0f (float);
extern float j1f (float);
extern float jnf (int, float);



extern double exp10 (double);


extern double pow10 (double);


extern float exp10f (float);


extern float pow10f (float);
# 486 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 3
extern int *__signgam (void);
# 495 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 3
struct __exception



{
  int type;
  char *name;
  double arg1;
  double arg2;
  double retval;
  int err;
};


extern int matherr (struct __exception *e);
# 552 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 3
enum __fdlibm_version
{
  __fdlibm_ieee = -1,
  __fdlibm_svid,
  __fdlibm_xopen,
  __fdlibm_posix
};




extern enum __fdlibm_version __fdlib_version;
# 572 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/math.h" 3
}
# 23 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireOgcDefines.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireOgcDefines.h"
       


# 1 "/opt/devkitpro/libogc/include/gctypes.h" 1
# 9 "/opt/devkitpro/libogc/include/gctypes.h"
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stdbool.h" 1 3 4
# 10 "/opt/devkitpro/libogc/include/gctypes.h" 2
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stdint.h" 1 3 4


# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 1 3 4
# 13 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
extern "C" {
# 41 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed char int8_t ;
typedef unsigned char uint8_t ;




typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;




typedef signed short int16_t;
typedef unsigned short uint16_t;
# 67 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;
# 79 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed int int32_t;
typedef unsigned int uint32_t;
# 97 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;
# 119 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed long long int64_t;
typedef unsigned long long uint64_t;
# 129 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;
# 159 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef signed int int_fast8_t;
  typedef unsigned int uint_fast8_t;




  typedef signed int int_fast16_t;
  typedef unsigned int uint_fast16_t;




  typedef signed int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 213 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef int_least64_t int_fast64_t;
  typedef uint_least64_t uint_fast64_t;







  typedef long long int intmax_t;
# 231 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef long long unsigned int uintmax_t;
# 243 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed int intptr_t;
typedef unsigned int uintptr_t;
# 490 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdint.h" 3 4
}
# 4 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stdint.h" 2 3 4
# 11 "/opt/devkitpro/libogc/include/gctypes.h" 2


   extern "C" {



typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;
typedef int64_t s64;

typedef volatile u8 vu8;
typedef volatile u16 vu16;
typedef volatile u32 vu32;
typedef volatile u64 vu64;

typedef volatile s8 vs8;
typedef volatile s16 vs16;
typedef volatile s32 vs32;
typedef volatile s64 vs64;


typedef s16 sfp16;
typedef s32 sfp32;
typedef u16 ufp16;
typedef u32 ufp32;

typedef float f32;
typedef double f64;

typedef volatile float vf32;
typedef volatile double vf64;



typedef unsigned int BOOL;
# 88 "/opt/devkitpro/libogc/include/gctypes.h"
struct __argv {
 int argvMagic;
 char *commandLine;
 int length;
 int argc;
 char **argv;
 char **endARGV;
};


extern struct __argv *__system_argv;





   }
# 13 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireOgcDefines.h" 2
# 1 "/opt/devkitpro/libogc/include/gccore.h" 1
# 39 "/opt/devkitpro/libogc/include/gccore.h"
# 1 "/opt/devkitpro/libogc/include/ogc/dsp.h" 1
# 72 "/opt/devkitpro/libogc/include/ogc/dsp.h"
   extern "C" {







typedef struct _dsp_task dsptask_t;






typedef void (*DSPTaskCallback)(dsptask_t *task);





typedef void (*DSPCallback)(void);
# 115 "/opt/devkitpro/libogc/include/ogc/dsp.h"
struct _dsp_task {
 vu32 state;
 vu32 prio;
 vu32 flags;

 void *iram_maddr;
 u32 iram_len;
 u32 iram_addr;

 void *dram_maddr;
 u32 dram_len;
 u32 dram_addr;

 u16 init_vec;
 u16 resume_vec;

 DSPTaskCallback init_cb;
 DSPTaskCallback res_cb;
 DSPTaskCallback done_cb;
 DSPTaskCallback req_cb;

 struct _dsp_task *next;
 struct _dsp_task *prev;
};







void DSP_Init();







u32 DSP_CheckMailTo();







u32 DSP_CheckMailFrom();







u32 DSP_ReadMailFrom();







void DSP_AssertInt();
# 187 "/opt/devkitpro/libogc/include/ogc/dsp.h"
void DSP_SendMailTo(u32 mail);







u32 DSP_ReadCPUtoDSP();
# 204 "/opt/devkitpro/libogc/include/ogc/dsp.h"
dsptask_t* DSP_AddTask(dsptask_t *task);

dsptask_t* DSP_AssertTask(dsptask_t *task);

void DSP_CancelTask(dsptask_t *task);

void DSP_Reset();

void DSP_Halt();

void DSP_Unhalt();







DSPCallback DSP_RegisterCallback(DSPCallback usr_cb);


   }
# 40 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/aram.h" 1
# 71 "/opt/devkitpro/libogc/include/ogc/aram.h"
   extern "C" {
# 81 "/opt/devkitpro/libogc/include/ogc/aram.h"
typedef void (*ARCallback)(void);
# 94 "/opt/devkitpro/libogc/include/ogc/aram.h"
ARCallback AR_RegisterCallback(ARCallback callback);
# 103 "/opt/devkitpro/libogc/include/ogc/aram.h"
u32 AR_GetDMAStatus();
# 147 "/opt/devkitpro/libogc/include/ogc/aram.h"
u32 AR_Init(u32 *stack_idx_array,u32 num_entries);
# 167 "/opt/devkitpro/libogc/include/ogc/aram.h"
void AR_StartDMA(u32 dir,u32 memaddr,u32 aramaddr,u32 len);
# 180 "/opt/devkitpro/libogc/include/ogc/aram.h"
u32 AR_Alloc(u32 len);
# 191 "/opt/devkitpro/libogc/include/ogc/aram.h"
u32 AR_Free(u32 *len);
# 202 "/opt/devkitpro/libogc/include/ogc/aram.h"
void AR_Clear(u32 flag);
# 212 "/opt/devkitpro/libogc/include/ogc/aram.h"
BOOL AR_CheckInit();
# 223 "/opt/devkitpro/libogc/include/ogc/aram.h"
void AR_Reset();
# 232 "/opt/devkitpro/libogc/include/ogc/aram.h"
u32 AR_GetSize();
# 241 "/opt/devkitpro/libogc/include/ogc/aram.h"
u32 AR_GetBaseAddress();
# 250 "/opt/devkitpro/libogc/include/ogc/aram.h"
u32 AR_GetInternalSize();
# 269 "/opt/devkitpro/libogc/include/ogc/aram.h"
   }
# 41 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/arqueue.h" 1
# 36 "/opt/devkitpro/libogc/include/ogc/arqueue.h"
# 1 "/opt/devkitpro/libogc/include/ogc/lwp_queue.h" 1
# 13 "/opt/devkitpro/libogc/include/ogc/lwp_queue.h"
extern "C" {


typedef struct _lwpnode {
 struct _lwpnode *next;
 struct _lwpnode *prev;
} lwp_node;

typedef struct _lwpqueue {
 lwp_node *first;
 lwp_node *perm_null;
 lwp_node *last;
} lwp_queue;

void __lwp_queue_initialize(lwp_queue *,void *,u32,u32);
lwp_node* __lwp_queue_get(lwp_queue *);
void __lwp_queue_append(lwp_queue *,lwp_node *);
void __lwp_queue_extract(lwp_node *);
void __lwp_queue_insert(lwp_node *,lwp_node *);






 }
# 37 "/opt/devkitpro/libogc/include/ogc/arqueue.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/aram.h" 1
# 38 "/opt/devkitpro/libogc/include/ogc/arqueue.h" 2
# 48 "/opt/devkitpro/libogc/include/ogc/arqueue.h"
   extern "C" {


enum {
 ARQ_TASK_READY = 0,
 ARQ_TASK_RUNNING,
 ARQ_TASK_FINISHED
};

typedef struct _arq_request ARQRequest;
typedef void (*ARQCallback)(ARQRequest *);

struct _arq_request {
 lwp_node node;
 u32 owner,dir,prio,state;
 u32 aram_addr,mram_addr,len;
 ARQCallback callback;
};

void ARQ_Init();
void ARQ_Reset();
# 86 "/opt/devkitpro/libogc/include/ogc/arqueue.h"
void ARQ_PostRequest(ARQRequest *req,u32 owner,u32 dir,u32 prio,u32 aram_addr,u32 mram_addr,u32 len);
# 104 "/opt/devkitpro/libogc/include/ogc/arqueue.h"
void ARQ_PostRequestAsync(ARQRequest *req,u32 owner,u32 dir,u32 prio,u32 aram_addr,u32 mram_addr,u32 len,ARQCallback cb);
void ARQ_RemoveRequest(ARQRequest *req);
void ARQ_SetChunkSize(u32 size);
u32 ARQ_GetChunkSize();
void ARQ_FlushQueue();
u32 ARQ_RemoveOwnerRequest(u32 owner);


   }
# 42 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/arqmgr.h" 1
# 47 "/opt/devkitpro/libogc/include/ogc/arqmgr.h"
   extern "C" {
# 56 "/opt/devkitpro/libogc/include/ogc/arqmgr.h"
typedef void (*ARQMCallback)(s32 result);
# 68 "/opt/devkitpro/libogc/include/ogc/arqmgr.h"
void ARQM_Init(u32 arambase,s32 len);
# 80 "/opt/devkitpro/libogc/include/ogc/arqmgr.h"
u32 ARQM_PushData(void *buffer,s32 len);
# 89 "/opt/devkitpro/libogc/include/ogc/arqmgr.h"
u32 ARQM_GetZeroBuffer();
# 98 "/opt/devkitpro/libogc/include/ogc/arqmgr.h"
u32 ARQM_GetStackPointer();
# 107 "/opt/devkitpro/libogc/include/ogc/arqmgr.h"
u32 ARQM_GetFreeSize();


   }
# 43 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/audio.h" 1
# 70 "/opt/devkitpro/libogc/include/ogc/audio.h"
   extern "C" {
# 79 "/opt/devkitpro/libogc/include/ogc/audio.h"
typedef void (*AIDCallback)(void);
# 88 "/opt/devkitpro/libogc/include/ogc/audio.h"
typedef void (*AISCallback)(u32 smp_cnt);
# 99 "/opt/devkitpro/libogc/include/ogc/audio.h"
AISCallback AUDIO_RegisterStreamCallback(AISCallback callback);
# 110 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_Init(u8 *stack);
# 121 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamVolLeft(u8 vol);
# 130 "/opt/devkitpro/libogc/include/ogc/audio.h"
u8 AUDIO_GetStreamVolLeft();
# 141 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamVolRight(u8 vol);
# 150 "/opt/devkitpro/libogc/include/ogc/audio.h"
u8 AUDIO_GetStreamVolRight();
# 161 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamSampleRate(u32 rate);
# 170 "/opt/devkitpro/libogc/include/ogc/audio.h"
u32 AUDIO_GetStreamSampleRate();
# 184 "/opt/devkitpro/libogc/include/ogc/audio.h"
AIDCallback AUDIO_RegisterDMACallback(AIDCallback callback);
# 196 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_InitDMA(u32 startaddr,u32 len);
# 205 "/opt/devkitpro/libogc/include/ogc/audio.h"
u16 AUDIO_GetDMAEnableFlag();
# 217 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_StartDMA();
# 226 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_StopDMA();
# 235 "/opt/devkitpro/libogc/include/ogc/audio.h"
u32 AUDIO_GetDMABytesLeft();
# 244 "/opt/devkitpro/libogc/include/ogc/audio.h"
u32 AUDIO_GetDMALength();
# 253 "/opt/devkitpro/libogc/include/ogc/audio.h"
u32 AUDIO_GetDMAStartAddr();
# 264 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamTrigger(u32 cnt);
# 273 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_ResetStreamSampleCnt();
# 284 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_SetDSPSampleRate(u8 rate);
# 293 "/opt/devkitpro/libogc/include/ogc/audio.h"
u32 AUDIO_GetDSPSampleRate();
# 304 "/opt/devkitpro/libogc/include/ogc/audio.h"
void AUDIO_SetStreamPlayState(u32 state);
# 313 "/opt/devkitpro/libogc/include/ogc/audio.h"
u32 AUDIO_GetStreamPlayState();


   }
# 44 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/cache.h" 1
# 47 "/opt/devkitpro/libogc/include/ogc/cache.h"
   extern "C" {
# 57 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCEnable();
# 66 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCDisable();
# 78 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCFreeze();
# 90 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCUnfreeze();
# 102 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCFlashInvalidate();
# 116 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCInvalidateRange(void *startaddress,u32 len);
# 131 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCFlushRange(void *startaddress,u32 len);
# 144 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCStoreRange(void *startaddress,u32 len);
# 159 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCFlushRangeNoSync(void *startaddress,u32 len);
# 173 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCStoreRangeNoSync(void *startaddress,u32 len);
# 185 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCZeroRange(void *startaddress,u32 len);
# 197 "/opt/devkitpro/libogc/include/ogc/cache.h"
void DCTouchRange(void *startaddress,u32 len);
# 208 "/opt/devkitpro/libogc/include/ogc/cache.h"
void ICSync();
# 220 "/opt/devkitpro/libogc/include/ogc/cache.h"
void ICFlashInvalidate();
# 229 "/opt/devkitpro/libogc/include/ogc/cache.h"
void ICEnable();
# 238 "/opt/devkitpro/libogc/include/ogc/cache.h"
void ICDisable();
# 250 "/opt/devkitpro/libogc/include/ogc/cache.h"
void ICFreeze();
# 262 "/opt/devkitpro/libogc/include/ogc/cache.h"
void ICUnfreeze();
# 275 "/opt/devkitpro/libogc/include/ogc/cache.h"
void ICBlockInvalidate(void *startaddress);
# 289 "/opt/devkitpro/libogc/include/ogc/cache.h"
void ICInvalidateRange(void *startaddress,u32 len);

void LCEnable();
void LCDisable();
void LCLoadBlocks(void *,void *,u32);
void LCStoreBlocks(void *,void *,u32);
u32 LCLoadData(void *,void *,u32);
u32 LCStoreData(void *,void *,u32);
u32 LCQueueLength();
u32 LCQueueWait(u32);
void LCFlushQueue();
void LCAlloc(void *,u32);
void LCAllocNoInvalidate(void *,u32);
void LCAllocOneTag(BOOL,void *);
void LCAllocTags(BOOL,void *,u32);



   }
# 45 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/card.h" 1
# 117 "/opt/devkitpro/libogc/include/ogc/card.h"
   extern "C" {
# 129 "/opt/devkitpro/libogc/include/ogc/card.h"
typedef struct _card_file {
 s32 chn;
 s32 filenum;
 s32 offset;
 s32 len;
 u16 iblock;
} card_file;
# 148 "/opt/devkitpro/libogc/include/ogc/card.h"
typedef struct _card_dir {
      s32 chn;
      u32 fileno;
   u32 filelen;
   u8 permissions;
      u8 filename[32];
      u8 gamecode[4];
      u8 company[2];
      bool showall;
} card_dir;
# 176 "/opt/devkitpro/libogc/include/ogc/card.h"
typedef struct _card_stat {
 u8 filename[32];
 u32 len;
 u32 time;
 u8 gamecode[4];
 u8 company[2];
 u8 banner_fmt;
 u32 icon_addr;
 u16 icon_fmt;
 u16 iconfmt[8];
 u16 icon_speed;
 u16 iconspeed[8];
 u32 comment_addr;
 u32 offset_banner;
 u32 offset_banner_tlut;
 u32 offset_icon[8];
 u32 offset_icon_tlut[8];
 u32 offset_data;
} card_stat;
# 210 "/opt/devkitpro/libogc/include/ogc/card.h"
typedef void (*cardcallback)(s32 chan,s32 result);
# 220 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Init(const char *gamecode,const char *company);
# 229 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Probe(s32 chn);
# 240 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_ProbeEx(s32 chn,s32 *mem_size,s32 *sect_size);
# 251 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Mount(s32 chn,void *workarea,cardcallback detach_cb);
# 263 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_MountAsync(s32 chn,void *workarea,cardcallback detach_cb,cardcallback attach_cb);
# 272 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Unmount(s32 chn);
# 284 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Read(card_file *file,void *buffer,u32 len,u32 offset);
# 297 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_ReadAsync(card_file *file,void *buffer,u32 len,u32 offset,cardcallback callback);
# 308 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Open(s32 chn,const char *filename,card_file *file);
# 319 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_OpenEntry(s32 chn,card_dir *entry,card_file *file);
# 328 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Close(card_file *file);
# 340 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Create(s32 chn,const char *filename,u32 size,card_file *file);
# 353 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_CreateAsync(s32 chn,const char *filename,u32 size,card_file *file,cardcallback callback);
# 364 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_CreateEntry(s32 chn,card_dir *direntry,card_file *file);
# 376 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_CreateEntryAsync(s32 chn,card_dir *direntry,card_file *file,cardcallback callback);
# 386 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Delete(s32 chn,const char *filename);
# 397 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_DeleteAsync(s32 chn,const char *filename,cardcallback callback);
# 407 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_DeleteEntry(s32 chn,card_dir *dir_entry);
# 418 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_DeleteEntryAsync(s32 chn,card_dir *dir_entry,cardcallback callback);
# 430 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_Write(card_file *file,void *buffer,u32 len,u32 offset);
# 443 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_WriteAsync(card_file *file,void *buffer,u32 len,u32 offset,cardcallback callback);
# 452 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_GetErrorCode(s32 chn);
# 463 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_FindFirst(s32 chn, card_dir *dir, bool showall);
# 472 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_FindNext(card_dir *dir);
# 484 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_GetDirectory(s32 chn, card_dir *dir_entries, s32 *count, bool showall);
# 494 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_GetSectorSize(s32 chn,u32 *sector_size);
# 504 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_GetBlockCount(s32 chn,u32 *block_count);
# 515 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_GetStatus(s32 chn,s32 fileno,card_stat *stats);
# 526 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_SetStatus(s32 chn,s32 fileno,card_stat *stats);
# 538 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_SetStatusAsync(s32 chn,s32 fileno,card_stat *stats,cardcallback callback);
# 549 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_GetAttributes(s32 chn,s32 fileno,u8 *attr);
# 560 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_SetAttributes(s32 chn,s32 fileno,u8 attr);
# 572 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_SetAttributesAsync(s32 chn,s32 fileno,u8 attr,cardcallback callback);




s32 CARD_Format(s32 chn);



s32 CARD_FormatAsync(s32 chn,cardcallback callback);
# 590 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_SetCompany(const char *company);
# 599 "/opt/devkitpro/libogc/include/ogc/card.h"
s32 CARD_SetGamecode(const char *gamecode);


   }
# 46 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/cast.h" 1
# 25 "/opt/devkitpro/libogc/include/ogc/cast.h"
extern "C" {







static inline void CAST_Init()
{
 __asm__ __volatile__ (
  "li		3,0x0004\n		 oris	3,3,0x0004\n		 mtspr	914,3\n		 li		3,0x0005\n		 oris	3,3,0x0005\n		 mtspr	915,3\n		 li		3,0x0006\n		 oris	3,3,0x0006\n		 mtspr	916,3\n		 li		3,0x0007\n		 oris	3,3,0x0007\n		 mtspr	917,3\n"
# 48 "/opt/devkitpro/libogc/include/ogc/cast.h"
   : : : "r3"
 );
}

static inline void CAST_SetGQR2(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(914), "b"(val));
}

static inline void CAST_SetGQR3(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(915), "b"(val));
}

static inline void CAST_SetGQR4(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(916), "b"(val));
}

static inline void CAST_SetGQR5(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(917), "b"(val));
}

static inline void CAST_SetGQR6(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(918), "b"(val));
}

static inline void CAST_SetGQR7(u32 type,u32 scale)
{
 register u32 val = (((((scale)<<8)|(type))<<16)|(((scale)<<8)|(type)));
 asm volatile("mtspr %0,%1" : : "i"(919), "b"(val));
}
# 95 "/opt/devkitpro/libogc/include/ogc/cast.h"
static inline f32 __castu8f32(register u8 *in)
{
 register f32 rval;
 __asm__ __volatile__ (
  "psq_l	%[rval],0(%[in]),1,2" : [rval]"=f"(rval) : [in]"r"(in)
 );
 return rval;
}

static inline f32 __castu16f32(register u16 *in)
{
 register f32 rval;
 __asm__ __volatile__ (
  "psq_l	%[rval],0(%[in]),1,3" : [rval]"=f"(rval) : [in]"r"(in)
 );
 return rval;
}

static inline f32 __casts8f32(register s8 *in)
{
 register f32 rval;
 __asm__ __volatile__ (
  "psq_l	%[rval],0(%[in]),1,4" : [rval]"=f"(rval) : [in]"r"(in)
 );
 return rval;
}

static inline f32 __casts16f32(register s16 *in)
{
 register f32 rval;
 __asm__ __volatile__ (
  "psq_l	%[rval],0(%[in]),1,5" : [rval]"=f"(rval) : [in]"r"(in)
 );
 return rval;
}

static inline void castu8f32(register u8 *in,register volatile f32 *out)
{
 *out = __castu8f32(in);
}

static inline void castu16f32(register u16 *in,register volatile f32 *out)
{
 *out = __castu16f32(in);
}

static inline void casts8f32(register s8 *in,register volatile f32 *out)
{
 *out = __casts8f32(in);
}

static inline void casts16f32(register s16 *in,register volatile f32 *out)
{
 *out = __casts16f32(in);
}







static inline u8 __castf32u8(register f32 in)
{
 f32 a;
 register u8 rval;
 register f32 *ptr = &a;

 __asm__ __volatile__ (
  "psq_st	%[in],0(%[ptr]),1,2\n"
  "lbz	%[out],0(%[ptr])\n"
  : [out]"=r"(rval), [ptr]"+r"(ptr) : [in]"f"(in)
 );
 return rval;
}

static inline u16 __castf32u16(register f32 in)
{
 f32 a;
 register u16 rval;
 register f32 *ptr = &a;

 __asm__ __volatile__ (
  "psq_st	%[in],0(%[ptr]),1,3\n"
  "lhz	%[out],0(%[ptr])\n"
  : [out]"=r"(rval), [ptr]"+r"(ptr) : [in]"f"(in)
 );
 return rval;
}

static inline s8 __castf32s8(register f32 in)
{
 f32 a;
 register s8 rval;
 register f32 *ptr = &a;

 __asm__ __volatile__ (
  "psq_st	%[in],0(%[ptr]),1,4\n"
  "lbz	%[out],0(%[ptr])\n"
  : [out]"=r"(rval), [ptr]"+r"(ptr) : [in]"f"(in)
 );
 return rval;
}

static inline s16 __castf32s16(register f32 in)
{
 f32 a;
 register s16 rval;
 register f32 *ptr = &a;

 __asm__ __volatile__ (
  "psq_st	%[in],0(%[ptr]),1,5\n"
  "lha	%[out],0(%[ptr])\n"
  : [out]"=r"(rval), [ptr]"+r"(ptr) : [in]"f"(in)
 );
 return rval;
}

static inline void castf32u8(register f32 *in,register vu8 *out)
{
 *out = __castf32u8(*in);
}

static inline void castf32u16(register f32 *in,register vu16 *out)
{
 *out = __castf32u16(*in);
}

static inline void castf32s8(register f32 *in,register vs8 *out)
{
 *out = __castf32s8(*in);
}

static inline void castf32s16(register f32 *in,register vs16 *out)
{
 *out = __castf32s16(*in);
}




}
# 47 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/color.h" 1
# 48 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/consol.h" 1
# 10 "/opt/devkitpro/libogc/include/ogc/consol.h"
# 1 "/opt/devkitpro/libogc/include/ogc/gx_struct.h" 1
# 42 "/opt/devkitpro/libogc/include/ogc/gx_struct.h"
   extern "C" {
# 58 "/opt/devkitpro/libogc/include/ogc/gx_struct.h"
typedef struct _gx_rmodeobj {
 u32 viTVMode;
 u16 fbWidth;
 u16 efbHeight;
 u16 xfbHeight;
 u16 viXOrigin;
 u16 viYOrigin;
 u16 viWidth;
 u16 viHeight;
 u32 xfbMode;
 u8 field_rendering;
 u8 aa;
 u8 sample_pattern[12][2];
 u8 vfilter[7];
} GXRModeObj;


   }
# 11 "/opt/devkitpro/libogc/include/ogc/consol.h" 2






 extern "C" {
# 31 "/opt/devkitpro/libogc/include/ogc/consol.h"
void CON_Init(void *framebuffer,int xstart,int ystart,int xres,int yres,int stride);
# 44 "/opt/devkitpro/libogc/include/ogc/consol.h"
s32 CON_InitEx(GXRModeObj *rmode, s32 conXOrigin,s32 conYOrigin,s32 conWidth,s32 conHeight);
# 54 "/opt/devkitpro/libogc/include/ogc/consol.h"
void CON_GetMetrics(int *cols, int *rows);
# 64 "/opt/devkitpro/libogc/include/ogc/consol.h"
void CON_GetPosition(int *cols, int *rows);
# 75 "/opt/devkitpro/libogc/include/ogc/consol.h"
void CON_EnableGecko(int channel,int safe);


 }
# 49 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/dvd.h" 1
# 42 "/opt/devkitpro/libogc/include/ogc/dvd.h"
# 1 "/opt/devkitpro/libogc/include/ogc/disc_io.h" 1
# 46 "/opt/devkitpro/libogc/include/ogc/disc_io.h"
typedef uint32_t sec_t;

typedef bool (* FN_MEDIUM_STARTUP)(void) ;
typedef bool (* FN_MEDIUM_ISINSERTED)(void) ;
typedef bool (* FN_MEDIUM_READSECTORS)(sec_t sector, sec_t numSectors, void* buffer) ;
typedef bool (* FN_MEDIUM_WRITESECTORS)(sec_t sector, sec_t numSectors, const void* buffer) ;
typedef bool (* FN_MEDIUM_CLEARSTATUS)(void) ;
typedef bool (* FN_MEDIUM_SHUTDOWN)(void) ;

struct DISC_INTERFACE_STRUCT {
 unsigned long ioType ;
 unsigned long features ;
 FN_MEDIUM_STARTUP startup ;
 FN_MEDIUM_ISINSERTED isInserted ;
 FN_MEDIUM_READSECTORS readSectors ;
 FN_MEDIUM_WRITESECTORS writeSectors ;
 FN_MEDIUM_CLEARSTATUS clearStatus ;
 FN_MEDIUM_SHUTDOWN shutdown ;
} ;

typedef struct DISC_INTERFACE_STRUCT DISC_INTERFACE ;
# 43 "/opt/devkitpro/libogc/include/ogc/dvd.h" 2
# 103 "/opt/devkitpro/libogc/include/ogc/dvd.h"
   extern "C" {







typedef struct _dvddiskid dvddiskid;
# 128 "/opt/devkitpro/libogc/include/ogc/dvd.h"
struct _dvddiskid {
 s8 gamename[4];
 s8 company[2];
 u8 disknum;
 u8 gamever;
 u8 streaming;
 u8 streambufsize;
 u8 pad[22];
};





typedef struct _dvdcmdblk dvdcmdblk;






typedef void (*dvdcbcallback)(s32 result,dvdcmdblk *block);







struct _dvdcmdblk {
 lwp_node node;
 u32 cmd;
 s32 state;
 s64 offset;
 u32 len;
 void *buf;
 u32 currtxsize;
 u32 txdsize;
 dvddiskid *id;
 dvdcbcallback cb;
 void *usrdata;
};






typedef struct _dvddrvinfo dvddrvinfo;
# 190 "/opt/devkitpro/libogc/include/ogc/dvd.h"
struct _dvddrvinfo {
 u16 rev_level;
 u16 dev_code;
 u32 rel_date;
 u8 pad[24];
};






typedef struct _dvdfileinfo dvdfileinfo;
# 212 "/opt/devkitpro/libogc/include/ogc/dvd.h"
typedef void (*dvdcallback)(s32 result,dvdfileinfo *info);







struct _dvdfileinfo {
 dvdcmdblk block;
 u32 addr;
 u32 len;
 dvdcallback cb;
};
# 236 "/opt/devkitpro/libogc/include/ogc/dvd.h"
void DVD_Init();
void DVD_Pause();
# 248 "/opt/devkitpro/libogc/include/ogc/dvd.h"
void DVD_Reset(u32 reset_mode);
# 259 "/opt/devkitpro/libogc/include/ogc/dvd.h"
s32 DVD_Mount();
s32 DVD_GetDriveStatus();
# 283 "/opt/devkitpro/libogc/include/ogc/dvd.h"
s32 DVD_MountAsync(dvdcmdblk *block,dvdcbcallback cb);
# 297 "/opt/devkitpro/libogc/include/ogc/dvd.h"
s32 DVD_ControlDrive(dvdcmdblk *block,u32 cmd);
# 310 "/opt/devkitpro/libogc/include/ogc/dvd.h"
s32 DVD_ControlDriveAsync(dvdcmdblk *block,u32 cmd,dvdcbcallback cb);
# 324 "/opt/devkitpro/libogc/include/ogc/dvd.h"
s32 DVD_SetGCMOffset(dvdcmdblk *block,s64 offset);
# 339 "/opt/devkitpro/libogc/include/ogc/dvd.h"
s32 DVD_SetGCMOffsetAsync(dvdcmdblk *block,s64 offset,dvdcbcallback cb);

s32 DVD_GetCmdBlockStatus(dvdcmdblk *block);
s32 DVD_SpinUpDrive(dvdcmdblk *block);
s32 DVD_SpinUpDriveAsync(dvdcmdblk *block,dvdcbcallback cb);
s32 DVD_Inquiry(dvdcmdblk *block,dvddrvinfo *info);
s32 DVD_InquiryAsync(dvdcmdblk *block,dvddrvinfo *info,dvdcbcallback cb);
s32 DVD_ReadPrio(dvdcmdblk *block,void *buf,u32 len,s64 offset,s32 prio);
s32 DVD_ReadAbsAsyncPrio(dvdcmdblk *block,void *buf,u32 len,s64 offset,dvdcbcallback cb,s32 prio);
s32 DVD_ReadAbsAsyncForBS(dvdcmdblk *block,void *buf,u32 len,s64 offset,dvdcbcallback cb);
s32 DVD_SeekPrio(dvdcmdblk *block,s64 offset,s32 prio);
s32 DVD_SeekAbsAsyncPrio(dvdcmdblk *block,s64 offset,dvdcbcallback cb,s32 prio);
s32 DVD_CancelAllAsync(dvdcbcallback cb);
s32 DVD_StopStreamAtEndAsync(dvdcmdblk *block,dvdcbcallback cb);
s32 DVD_StopStreamAtEnd(dvdcmdblk *block);
s32 DVD_ReadDiskID(dvdcmdblk *block,dvddiskid *id,dvdcbcallback cb);
u32 DVD_SetAutoInvalidation(u32 auto_inv);
dvddiskid* DVD_GetCurrentDiskID();
dvddrvinfo* DVD_GetDriveInfo();





extern const DISC_INTERFACE __io_gcdvd;


   }
# 50 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/exi.h" 1
# 138 "/opt/devkitpro/libogc/include/ogc/exi.h"
   extern "C" {







typedef s32 (*EXICallback)(s32 chn,s32 dev);
# 155 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_ProbeEx(s32 nChn);
# 164 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Probe(s32 nChn);
# 175 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Lock(s32 nChn,s32 nDev,EXICallback unlockCB);
# 184 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Unlock(s32 nChn);
# 195 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Select(s32 nChn,s32 nDev,s32 nFrq);
# 206 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_SelectSD(s32 nChn,s32 nDev,s32 nFrq);
# 215 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Deselect(s32 nChn);
# 224 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Sync(s32 nChn);
# 237 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Imm(s32 nChn,void *pData,u32 nLen,u32 nMode,EXICallback tc_cb);
# 249 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_ImmEx(s32 nChn,void *pData,u32 nLen,u32 nMode);
# 262 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Dma(s32 nChn,void *pData,u32 nLen,u32 nMode,EXICallback tc_cb);
# 271 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_GetState(s32 nChn);
# 282 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_GetID(s32 nChn,s32 nDev,u32 *nId);
# 292 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Attach(s32 nChn,EXICallback ext_cb);
# 301 "/opt/devkitpro/libogc/include/ogc/exi.h"
s32 EXI_Detach(s32 nChn);







void EXI_ProbeReset();
# 319 "/opt/devkitpro/libogc/include/ogc/exi.h"
EXICallback EXI_RegisterEXICallback(s32 nChn,EXICallback exi_cb);


   }
# 51 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/gu.h" 1
# 80 "/opt/devkitpro/libogc/include/ogc/gu.h"
   extern "C" {
# 94 "/opt/devkitpro/libogc/include/ogc/gu.h"
typedef struct _vecf {
 f32 x,y,z;
} guVector;
# 107 "/opt/devkitpro/libogc/include/ogc/gu.h"
typedef struct _qrtn {
 f32 x,y,z,w;
} guQuaternion;





typedef f32 Mtx[3][4];
typedef f32 (*MtxP)[4];







typedef f32 ROMtx[4][3];
typedef f32 (*ROMtxP)[3];




typedef f32 Mtx33[3][3];
typedef f32 (*Mtx33P)[3];





typedef f32 Mtx44[4][4];
typedef f32 (*Mtx44P)[4];
# 162 "/opt/devkitpro/libogc/include/ogc/gu.h"
void guFrustum(Mtx44 mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 f);
# 187 "/opt/devkitpro/libogc/include/ogc/gu.h"
void guPerspective(Mtx44 mt,f32 fovy,f32 aspect,f32 n,f32 f);
# 211 "/opt/devkitpro/libogc/include/ogc/gu.h"
void guOrtho(Mtx44 mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 f);
# 244 "/opt/devkitpro/libogc/include/ogc/gu.h"
void guLightPerspective(Mtx mt,f32 fovY,f32 aspect,f32 scaleS,f32 scaleT,f32 transS,f32 transT);
# 273 "/opt/devkitpro/libogc/include/ogc/gu.h"
void guLightOrtho(Mtx mt,f32 t,f32 b,f32 l,f32 r,f32 scaleS,f32 scaleT,f32 transS,f32 transT);
# 303 "/opt/devkitpro/libogc/include/ogc/gu.h"
void guLightFrustum(Mtx mt,f32 t,f32 b,f32 l,f32 r,f32 n,f32 scaleS,f32 scaleT,f32 transS,f32 transT);
# 325 "/opt/devkitpro/libogc/include/ogc/gu.h"
void guLookAt(Mtx mt,guVector *camPos,guVector *camUp,guVector *target);
# 346 "/opt/devkitpro/libogc/include/ogc/gu.h"
void guVecHalfAngle(guVector *a,guVector *b,guVector *half);

void c_guVecAdd(guVector *a,guVector *b,guVector *ab);
void c_guVecSub(guVector *a,guVector *b,guVector *ab);
void c_guVecScale(guVector *src,guVector *dst,f32 scale);
void c_guVecNormalize(guVector *v);
void c_guVecMultiply(Mtx mt,guVector *src,guVector *dst);
void c_guVecCross(guVector *a,guVector *b,guVector *axb);
void c_guVecMultiplySR(Mtx mt,guVector *src,guVector *dst);
f32 c_guVecDotProduct(guVector *a,guVector *b);


void ps_guVecAdd(register guVector *a,register guVector *b,register guVector *ab);
void ps_guVecSub(register guVector *a,register guVector *b,register guVector *ab);
void ps_guVecScale(register guVector *src,register guVector *dst,f32 scale);
void ps_guVecNormalize(register guVector *v);
void ps_guVecCross(register guVector *a,register guVector *b,register guVector *axb);
void ps_guVecMultiply(register Mtx mt,register guVector *src,register guVector *dst);
void ps_guVecMultiplySR(register Mtx mt,register guVector *src,register guVector *dst);
f32 ps_guVecDotProduct(register guVector *a,register guVector *b);


void c_guQuatAdd(guQuaternion *a,guQuaternion *b,guQuaternion *ab);
void c_guQuatSub(guQuaternion *a,guQuaternion *b,guQuaternion *ab);
void c_guQuatMultiply(guQuaternion *a,guQuaternion *b,guQuaternion *ab);
void c_guQuatNormalize(guQuaternion *a,guQuaternion *d);
void c_guQuatInverse(guQuaternion *a,guQuaternion *d);
void c_guQuatMtx(guQuaternion *a,Mtx m);


void ps_guQuatAdd(register guQuaternion *a,register guQuaternion *b,register guQuaternion *ab);
void ps_guQuatSub(register guQuaternion *a,register guQuaternion *b,register guQuaternion *ab);
void ps_guQuatMultiply(register guQuaternion *a,register guQuaternion *b,register guQuaternion *ab);
void ps_guQuatNormalize(register guQuaternion *a,register guQuaternion *d);
void ps_guQuatInverse(register guQuaternion *a,register guQuaternion *d);


void c_guMtxIdentity(Mtx mt);
void c_guMtxCopy(Mtx src,Mtx dst);
void c_guMtxConcat(Mtx a,Mtx b,Mtx ab);
void c_guMtxScale(Mtx mt,f32 xS,f32 yS,f32 zS);
void c_guMtxScaleApply(Mtx src,Mtx dst,f32 xS,f32 yS,f32 zS);
void c_guMtxApplyScale(Mtx src,Mtx dst,f32 xS,f32 yS,f32 zS);
void c_guMtxTrans(Mtx mt,f32 xT,f32 yT,f32 zT);
void c_guMtxTransApply(Mtx src,Mtx dst,f32 xT,f32 yT,f32 zT);
void c_guMtxApplyTrans(Mtx src,Mtx dst,f32 xT,f32 yT,f32 zT);
u32 c_guMtxInverse(Mtx src,Mtx inv);
u32 c_guMtxInvXpose(Mtx src,Mtx xPose);
void c_guMtxTranspose(Mtx src,Mtx xPose);
void c_guMtxRotRad(Mtx mt,const char axis,f32 rad);
void c_guMtxRotTrig(Mtx mt,const char axis,f32 sinA,f32 cosA);
void c_guMtxRotAxisRad(Mtx mt,guVector *axis,f32 rad);
void c_guMtxReflect(Mtx m,guVector *p,guVector *n);
void c_guMtxQuat(Mtx m,guQuaternion *a);


void ps_guMtxIdentity(register Mtx mt);
void ps_guMtxCopy(register Mtx src,register Mtx dst);
void ps_guMtxConcat(register Mtx a,register Mtx b,register Mtx ab);
void ps_guMtxTranspose(register Mtx src,register Mtx xPose);
u32 ps_guMtxInverse(register Mtx src,register Mtx inv);
u32 ps_guMtxInvXpose(register Mtx src,register Mtx xPose);
void ps_guMtxScale(register Mtx mt,register f32 xS,register f32 yS,register f32 zS);
void ps_guMtxScaleApply(register Mtx src,register Mtx dst,register f32 xS,register f32 yS,register f32 zS);
void ps_guMtxApplyScale(register Mtx src,register Mtx dst,register f32 xS,register f32 yS,register f32 zS);
void ps_guMtxTrans(register Mtx mt,register f32 xT,register f32 yT,register f32 zT);
void ps_guMtxTransApply(register Mtx src,register Mtx dst,register f32 xT,register f32 yT,register f32 zT);
void ps_guMtxApplyTrans(register Mtx src,register Mtx dst,register f32 xT,register f32 yT,register f32 zT);
void ps_guMtxRotRad(register Mtx mt,register const char axis,register f32 rad);
void ps_guMtxRotTrig(register Mtx mt,register const char axis,register f32 sinA,register f32 cosA);
void ps_guMtxRotAxisRad(register Mtx mt,register guVector *axis,register f32 tmp0);
void ps_guMtxReflect(register Mtx m,register guVector *p,register guVector *n);
# 496 "/opt/devkitpro/libogc/include/ogc/gu.h"
   }
# 52 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/gx.h" 1
# 11 "/opt/devkitpro/libogc/include/ogc/gx.h"
# 1 "/opt/devkitpro/libogc/include/ogc/lwp.h" 1
# 55 "/opt/devkitpro/libogc/include/ogc/lwp.h"
extern "C" {






typedef u32 lwp_t;





typedef u32 lwpq_t;
# 81 "/opt/devkitpro/libogc/include/ogc/lwp.h"
s32 LWP_CreateThread(lwp_t *thethread,void* (*entry)(void *),void *arg,void *stackbase,u32 stack_size,u8 prio);
# 90 "/opt/devkitpro/libogc/include/ogc/lwp.h"
s32 LWP_SuspendThread(lwp_t thethread);
# 99 "/opt/devkitpro/libogc/include/ogc/lwp.h"
s32 LWP_ResumeThread(lwp_t thethread);
# 108 "/opt/devkitpro/libogc/include/ogc/lwp.h"
BOOL LWP_ThreadIsSuspended(lwp_t thethread);







lwp_t LWP_GetSelf();
# 126 "/opt/devkitpro/libogc/include/ogc/lwp.h"
void LWP_SetThreadPriority(lwp_t thethread,u32 prio);







void LWP_YieldThread();
# 143 "/opt/devkitpro/libogc/include/ogc/lwp.h"
void LWP_Reschedule(u32 prio);
# 153 "/opt/devkitpro/libogc/include/ogc/lwp.h"
s32 LWP_JoinThread(lwp_t thethread,void **value_ptr);
# 162 "/opt/devkitpro/libogc/include/ogc/lwp.h"
s32 LWP_InitQueue(lwpq_t *thequeue);
# 171 "/opt/devkitpro/libogc/include/ogc/lwp.h"
void LWP_CloseQueue(lwpq_t thequeue);
# 180 "/opt/devkitpro/libogc/include/ogc/lwp.h"
s32 LWP_ThreadSleep(lwpq_t thequeue);
# 189 "/opt/devkitpro/libogc/include/ogc/lwp.h"
void LWP_ThreadSignal(lwpq_t thequeue);
# 198 "/opt/devkitpro/libogc/include/ogc/lwp.h"
void LWP_ThreadBroadcast(lwpq_t thequeue);


 }
# 12 "/opt/devkitpro/libogc/include/ogc/gx.h" 2

# 1 "/opt/devkitpro/libogc/include/ogc/gu.h" 1
# 14 "/opt/devkitpro/libogc/include/ogc/gx.h" 2
# 1165 "/opt/devkitpro/libogc/include/ogc/gx.h"
   extern "C" {


typedef union _wgpipe
{
 vu8 U8;
 vs8 S8;
 vu16 U16;
 vs16 S16;
 vu32 U32;
 vs32 S32;
 vf32 F32;
} WGPipe;




typedef struct _gx_color {
  u8 r;
  u8 g;
  u8 b;
 u8 a;
} GXColor;




typedef struct _gx_colors10 {
  s16 r;
  s16 g;
  s16 b;
 s16 a;
} GXColorS10;
# 1209 "/opt/devkitpro/libogc/include/ogc/gx.h"
typedef struct _gx_texobj {
 u32 val[8];
} GXTexObj;
# 1223 "/opt/devkitpro/libogc/include/ogc/gx.h"
typedef struct _gx_tlutobj {
 u32 val[3];
} GXTlutObj;
# 1237 "/opt/devkitpro/libogc/include/ogc/gx.h"
typedef struct _gx_texreg {
 u32 val[4];
} GXTexRegion;
# 1251 "/opt/devkitpro/libogc/include/ogc/gx.h"
typedef struct _gx_tlutreg {
 u32 val[4];
} GXTlutRegion;
# 1265 "/opt/devkitpro/libogc/include/ogc/gx.h"
typedef struct _gx_litobj {
 u32 val[16];
} GXLightObj;

typedef struct _vtx {
 f32 x,y,z;
 u16 s,t;
 u32 rgba;
} Vtx;







typedef struct {
 u8 attr;
 u8 type;
} GXVtxDesc;







typedef struct {
 u32 vtxattr;
 u32 comptype;
 u32 compsize;
 u32 frac;
} GXVtxAttrFmt;
# 1309 "/opt/devkitpro/libogc/include/ogc/gx.h"
typedef struct {
 u8 pad[128];
} GXFifoObj;

typedef struct {
 u8 dummy[4];
} GXTexReg;




typedef struct {
 u16 r[10];
} GXFogAdjTbl;




typedef void (*GXBreakPtCallback)(void);




typedef void (*GXDrawDoneCallback)(void);





typedef void (*GXDrawSyncCallback)(u16 token);





typedef GXTexRegion* (*GXTexRegionCallback)(GXTexObj *obj,u8 mapid);





typedef GXTlutRegion* (*GXTlutRegionCallback)(u32 tlut_name);

extern WGPipe* const wgPipe;
# 1377 "/opt/devkitpro/libogc/include/ogc/gx.h"
GXFifoObj* GX_Init(void *base,u32 size);
# 1407 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitFifoBase(GXFifoObj *fifo,void *base,u32 size);
# 1431 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitFifoLimits(GXFifoObj *fifo,u32 hiwatermark,u32 lowatermark);
# 1445 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitFifoPtrs(GXFifoObj *fifo,void *rd_ptr,void *wt_ptr);
# 1459 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_GetFifoPtrs(GXFifoObj *fifo,void **rd_ptr,void **wt_ptr);
# 1472 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetCPUFifo(GXFifoObj *fifo);
# 1495 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetGPFifo(GXFifoObj *fifo);
# 1505 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_GetCPUFifo(GXFifoObj *fifo);
# 1515 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_GetGPFifo(GXFifoObj *fifo);
# 1525 "/opt/devkitpro/libogc/include/ogc/gx.h"
void* GX_GetFifoBase(GXFifoObj *fifo);
u32 GX_GetFifoCount(GXFifoObj *fifo);
# 1536 "/opt/devkitpro/libogc/include/ogc/gx.h"
u32 GX_GetFifoSize(GXFifoObj *fifo);
u8 GX_GetFifoWrap(GXFifoObj *fifo);
# 1551 "/opt/devkitpro/libogc/include/ogc/gx.h"
GXDrawDoneCallback GX_SetDrawDoneCallback(GXDrawDoneCallback cb);
# 1563 "/opt/devkitpro/libogc/include/ogc/gx.h"
GXBreakPtCallback GX_SetBreakPtCallback(GXBreakPtCallback cb);
# 1577 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_AbortFrame();
# 1587 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_Flush();
# 1598 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetMisc(u32 token,u32 value);
# 1614 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetDrawDone();
# 1629 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_WaitDrawDone();







u16 GX_GetDrawSync();
# 1651 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetDrawSync(u16 token);
# 1665 "/opt/devkitpro/libogc/include/ogc/gx.h"
GXDrawSyncCallback GX_SetDrawSyncCallback(GXDrawSyncCallback cb);
# 1677 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_DisableBreakPt();
# 1702 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_EnableBreakPt(void *break_pt);
# 1712 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_DrawDone();
# 1727 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_TexModeSync();
# 1743 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InvVtxCache();
# 1753 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_ClearVtxDesc();
# 1766 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadProjectionMtx(Mtx44 mt,u8 type);
# 1788 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetViewport(f32 xOrig,f32 yOrig,f32 wd,f32 ht,f32 nearZ,f32 farZ);
# 1810 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetViewportJitter(f32 xOrig,f32 yOrig,f32 wd,f32 ht,f32 nearZ,f32 farZ,u32 field);
# 1845 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetChanCtrl(s32 channel,u8 enable,u8 ambsrc,u8 matsrc,u8 litmask,u8 diff_fn,u8 attn_fn);
# 1858 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetChanAmbColor(s32 channel,GXColor color);
# 1871 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetChanMatColor(s32 channel,GXColor color);
# 1901 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetArray(u32 attr,void *ptr,u8 stride);
# 1927 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetVtxAttrFmt(u8 vtxfmt,u32 vtxattr,u32 comptype,u32 compsize,u32 frac);
# 1942 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetVtxAttrFmtv(u8 vtxfmt,GXVtxAttrFmt *attr_list);
# 1957 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetVtxDesc(u8 attr,u8 type);
# 1971 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetVtxDescv(GXVtxDesc *attr_list);
# 1985 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_GetVtxDescv(GXVtxDesc *attr_list);
# 2010 "/opt/devkitpro/libogc/include/ogc/gx.h"
u32 GX_EndDispList();
# 2027 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_Begin(u8 primitve,u8 vtxfmt,u16 vtxcnt);
# 2061 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_BeginDispList(void *list,u32 size);
# 2082 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_CallDispList(void *list,u32 nbytes);







static inline void GX_End()
{
}

static inline void GX_Position3f32(f32 x,f32 y,f32 z)
{
 wgPipe->F32 = x;
 wgPipe->F32 = y;
 wgPipe->F32 = z;
}

static inline void GX_Position3u16(u16 x,u16 y,u16 z)
{
 wgPipe->U16 = x;
 wgPipe->U16 = y;
 wgPipe->U16 = z;
}

static inline void GX_Position3s16(s16 x,s16 y,s16 z)
{
 wgPipe->S16 = x;
 wgPipe->S16 = y;
 wgPipe->S16 = z;
}

static inline void GX_Position3u8(u8 x,u8 y,u8 z)
{
 wgPipe->U8 = x;
 wgPipe->U8 = y;
 wgPipe->U8 = z;
}

static inline void GX_Position3s8(s8 x,s8 y,s8 z)
{
 wgPipe->S8 = x;
 wgPipe->S8 = y;
 wgPipe->S8 = z;
}

static inline void GX_Position2f32(f32 x,f32 y)
{
 wgPipe->F32 = x;
 wgPipe->F32 = y;
}

static inline void GX_Position2u16(u16 x,u16 y)
{
 wgPipe->U16 = x;
 wgPipe->U16 = y;
}

static inline void GX_Position2s16(s16 x,s16 y)
{
 wgPipe->S16 = x;
 wgPipe->S16 = y;
}

static inline void GX_Position2u8(u8 x,u8 y)
{
 wgPipe->U8 = x;
 wgPipe->U8 = y;
}

static inline void GX_Position2s8(s8 x,s8 y)
{
 wgPipe->S8 = x;
 wgPipe->S8 = y;
}

static inline void GX_Position1x8(u8 index)
{
 wgPipe->U8 = index;
}

static inline void GX_Position1x16(u16 index)
{
 wgPipe->U16 = index;
}

static inline void GX_Normal3f32(f32 nx,f32 ny,f32 nz)
{
 wgPipe->F32 = nx;
 wgPipe->F32 = ny;
 wgPipe->F32 = nz;
}

static inline void GX_Normal3s16(s16 nx,s16 ny,s16 nz)
{
 wgPipe->S16 = nx;
 wgPipe->S16 = ny;
 wgPipe->S16 = nz;
}

static inline void GX_Normal3s8(s8 nx,s8 ny,s8 nz)
{
 wgPipe->S8 = nx;
 wgPipe->S8 = ny;
 wgPipe->S8 = nz;
}

static inline void GX_Normal1x8(u8 index)
{
 wgPipe->U8 = index;
}

static inline void GX_Normal1x16(u16 index)
{
 wgPipe->U16 = index;
}

static inline void GX_Color4u8(u8 r,u8 g,u8 b,u8 a)
{
 wgPipe->U8 = r;
 wgPipe->U8 = g;
 wgPipe->U8 = b;
 wgPipe->U8 = a;
}

static inline void GX_Color3u8(u8 r,u8 g,u8 b)
{
 wgPipe->U8 = r;
 wgPipe->U8 = g;
 wgPipe->U8 = b;
}

static inline void GX_Color3f32(f32 r, f32 g, f32 b)
{
 wgPipe->U8 = (u8)(r * 255.0);
 wgPipe->U8 = (u8)(g * 255.0);
 wgPipe->U8 = (u8)(b * 255.0);

}

static inline void GX_Color1u32(u32 clr)
{
 wgPipe->U32 = clr;
}

static inline void GX_Color1u16(u16 clr)
{
 wgPipe->U16 = clr;
}

static inline void GX_Color1x8(u8 index)
{
 wgPipe->U8 = index;
}

static inline void GX_Color1x16(u16 index)
{
 wgPipe->U16 = index;
}

static inline void GX_TexCoord2f32(f32 s,f32 t)
{
 wgPipe->F32 = s;
 wgPipe->F32 = t;
}

static inline void GX_TexCoord2u16(u16 s,u16 t)
{
 wgPipe->U16 = s;
 wgPipe->U16 = t;
}

static inline void GX_TexCoord2s16(s16 s,s16 t)
{
 wgPipe->S16 = s;
 wgPipe->S16 = t;
}

static inline void GX_TexCoord2u8(u8 s,u8 t)
{
 wgPipe->U8 = s;
 wgPipe->U8 = t;
}

static inline void GX_TexCoord2s8(s8 s,s8 t)
{
 wgPipe->S8 = s;
 wgPipe->S8 = t;
}

static inline void GX_TexCoord1f32(f32 s)
{
 wgPipe->F32 = s;
}

static inline void GX_TexCoord1u16(u16 s)
{
 wgPipe->U16 = s;
}

static inline void GX_TexCoord1s16(s16 s)
{
 wgPipe->S16 = s;
}

static inline void GX_TexCoord1u8(u8 s)
{
 wgPipe->U8 = s;
}

static inline void GX_TexCoord1s8(s8 s)
{
 wgPipe->S8 = s;
}

static inline void GX_TexCoord1x8(u8 index)
{
 wgPipe->U8 = index;
}

static inline void GX_TexCoord1x16(u16 index)
{
 wgPipe->U16 = index;
}

static inline void GX_MatrixIndex1x8(u8 index)
{
 wgPipe->U8 = index;
}
# 2332 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_AdjustForOverscan(GXRModeObj *rmin,GXRModeObj *rmout,u16 hor,u16 ver);
# 2355 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadPosMtxImm(Mtx mt,u32 pnidx);
# 2378 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadPosMtxIdx(u16 mtxidx,u32 pnidx);
# 2401 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadNrmMtxImm(Mtx mt,u32 pnidx);
# 2425 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadNrmMtxIdx3x3(u16 mtxidx,u32 pnidx);
# 2451 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadTexMtxImm(Mtx mt,u32 texidx,u8 type);
# 2476 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadTexMtxIdx(u16 mtxidx,u32 texidx,u8 type);
# 2490 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetCurrentMtx(u32 mtx);
# 2507 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevOp(u8 tevstage,u8 mode);
# 2523 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevColor(u8 tev_regid,GXColor color);
# 2539 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevColorS10(u8 tev_regid,GXColorS10 color);
# 2558 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevColorIn(u8 tevstage,u8 a,u8 b,u8 c,u8 d);
# 2576 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevAlphaIn(u8 tevstage,u8 a,u8 b,u8 c,u8 d);
# 2600 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevColorOp(u8 tevstage,u8 tevop,u8 tevbias,u8 tevscale,u8 clamp,u8 tevregid);
# 2624 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevAlphaOp(u8 tevstage,u8 tevop,u8 tevbias,u8 tevscale,u8 clamp,u8 tevregid);
# 2640 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetNumTexGens(u32 nr);
# 2674 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTexCoordGen(u16 texcoord,u32 tgen_typ,u32 tgen_src,u32 mtxsrc);
# 2705 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTexCoordGen2(u16 texcoord,u32 tgen_typ,u32 tgen_src,u32 mtxsrc,u32 normalize,u32 postmtx);
# 2736 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetZTexture(u8 op,u8 fmt,u32 bias);
# 2758 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetZMode(u8 enable,u8 func,u8 update_enable);
# 2771 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetZCompLoc(u8 before_tex);
# 2785 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetLineWidth(u8 width,u8 fmt);
# 2799 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetPointSize(u8 width,u8 fmt);
# 2830 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetBlendMode(u8 type,u8 src_fact,u8 dst_fact,u8 op);
# 2844 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetCullMode(u8 mode);
# 2862 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetCoPlanar(u8 enable);
# 2880 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_EnableTexOffsets(u8 coord,u8 line_enable,u8 point_enable);
# 2894 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetClipMode(u8 mode);
# 2916 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetScissor(u32 xOrigin,u32 yOrigin,u32 wd,u32 ht);
# 2942 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetScissorBoxOffset(s32 xoffset,s32 yoffset);
# 2959 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetNumChans(u8 num);
# 2999 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevOrder(u8 tevstage,u8 texcoord,u32 texmap,u8 color);
# 3018 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetNumTevStages(u8 num);
# 3054 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetAlphaCompare(u8 comp0,u8 ref0,u8 aop,u8 comp1,u8 ref1);
# 3067 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevKColor(u8 sel, GXColor col);
# 3081 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevKColorSel(u8 tevstage,u8 sel);
# 3095 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevKAlphaSel(u8 tevstage,u8 sel);
# 3113 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevKColorS10(u8 sel, GXColorS10 col);
# 3129 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevSwapMode(u8 tevstage,u8 ras_sel,u8 tex_sel);
# 3146 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevSwapModeTable(u8 swapid,u8 r,u8 g,u8 b,u8 a);
# 3165 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevIndirect(u8 tevstage,u8 indtexid,u8 format,u8 bias,u8 mtxid,u8 wrap_s,u8 wrap_t,u8 addprev,u8 utclod,u8 a);
# 3175 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevDirect(u8 tevstage);
# 3187 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetNumIndStages(u8 nstages);
# 3199 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetIndTexOrder(u8 indtexstage,u8 texcoord,u8 texmap);
# 3213 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetIndTexCoordScale(u8 indtexid,u8 scale_s,u8 scale_t);
# 3236 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetFog(u8 type,f32 startz,f32 endz,f32 nearz,f32 farz,GXColor col);
# 3255 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetFogRangeAdj(u8 enable,u16 center,GXFogAdjTbl *table);

void GX_SetFogColor(GXColor color);

void GX_InitFogAdjTable(GXFogAdjTbl *table,u16 width,f32 projmtx[4][4]);
# 3279 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetIndTexMatrix(u8 indtexmtx,f32 offset_mtx[2][3],s8 scale_exp);
# 3300 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevIndBumpST(u8 tevstage,u8 indstage,u8 mtx_sel);
# 3318 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevIndBumpXYZ(u8 tevstage,u8 indstage,u8 mtx_sel);
# 3343 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevIndTile(u8 tevstage,u8 indtexid,u16 tilesize_x,u16 tilesize_y,u16 tilespacing_x,u16 tilespacing_y,u8 indtexfmt,u8 indtexmtx,u8 bias_sel,u8 alpha_sel);
# 3355 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTevIndRepeat(u8 tevstage);
# 3366 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetColorUpdate(u8 enable);
# 3381 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetAlphaUpdate(u8 enable);
# 3413 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetPixelFmt(u8 pix_fmt,u8 z_fmt);
# 3430 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetDither(u8 dither);
# 3445 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetDstAlpha(u8 enable,u8 a);
# 3461 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetFieldMask(u8 even_mask,u8 odd_mask);
# 3484 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetFieldMode(u8 field_mode,u8 half_aspect_ratio);
# 3496 "/opt/devkitpro/libogc/include/ogc/gx.h"
f32 GX_GetYScaleFactor(u16 efbHeight,u16 xfbHeight);
# 3509 "/opt/devkitpro/libogc/include/ogc/gx.h"
u32 GX_SetDispCopyYScale(f32 yscale);
# 3522 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetDispCopySrc(u16 left,u16 top,u16 wd,u16 ht);
# 3536 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetDispCopyDst(u16 wd,u16 ht);
# 3546 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetCopyClamp(u8 clamp);
# 3556 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetDispCopyGamma(u8 gamma);
# 3577 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetCopyFilter(u8 aa,u8 sample_pattern[12][2],u8 vf,u8 vfilter[7]);
# 3593 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetDispCopyFrame2Field(u8 mode);
# 3606 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetCopyClear(GXColor color,u32 zvalue);
# 3624 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_CopyDisp(void *dest,u8 clear);
# 3637 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTexCopySrc(u16 left,u16 top,u16 wd,u16 ht);
# 3653 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTexCopyDst(u16 wd,u16 ht,u32 fmt,u8 mipmap);
# 3667 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_CopyTex(void *dest,u8 clear);
# 3681 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PixModeSync();
# 3691 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_ClearBoundingBox();
# 3712 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeAlphaMode(u8 func,u8 threshold);
# 3724 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeAlphaUpdate(u8 update_enable);
# 3734 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeColorUpdate(u8 update_enable);
# 3748 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeDither(u8 dither);
# 3776 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeBlendMode(u8 type,u8 src_fact,u8 dst_fact,u8 op);
# 3792 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeAlphaRead(u8 mode);
# 3806 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeDstAlpha(u8 enable,u8 a);
# 3823 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeARGB(u16 x,u16 y,GXColor color);
# 3837 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PeekARGB(u16 x,u16 y,GXColor *color);
# 3855 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeZ(u16 x,u16 y,u32 z);
# 3872 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PeekZ(u16 x,u16 y,u32 *z);
# 3896 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PokeZMode(u8 comp_enable,u8 func,u8 update_enable);
# 3908 "/opt/devkitpro/libogc/include/ogc/gx.h"
u32 GX_GetTexObjFmt(GXTexObj *obj);
# 3920 "/opt/devkitpro/libogc/include/ogc/gx.h"
u32 GX_GetTexObjMipMap(GXTexObj *obj);


void* GX_GetTexObjUserData(GXTexObj *obj);
# 3942 "/opt/devkitpro/libogc/include/ogc/gx.h"
u32 GX_GetTexBufferSize(u16 wd,u16 ht,u32 fmt,u8 mipmap,u8 maxlod);
# 3954 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InvalidateTexAll();
# 3973 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InvalidateTexRegion(GXTexRegion *region);
# 4001 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTexCacheRegion(GXTexRegion *region,u8 is32bmipmap,u32 tmem_even,u8 size_even,u32 tmem_odd,u8 size_odd);
# 4026 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTexPreloadRegion(GXTexRegion *region,u32 tmem_even,u32 size_even,u32 tmem_odd,u32 size_odd);
# 4052 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTexObj(GXTexObj *obj,void *img_ptr,u16 wd,u16 ht,u8 fmt,u8 wrap_s,u8 wrap_t,u8 mipmap);
# 4085 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTexObjCI(GXTexObj *obj,void *img_ptr,u16 wd,u16 ht,u8 fmt,u8 wrap_s,u8 wrap_t,u8 mipmap,u32 tlut_name);
# 4096 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTexObjTlut(GXTexObj *obj,u32 tlut_name);
# 4110 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTexObjData(GXTexObj *obj,void *img_ptr);
# 4122 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTexObjWrapMode(GXTexObj *obj,u8 wrap_s,u8 wrap_t);
void GX_InitTexObjFilterMode(GXTexObj *obj,u8 minfilt,u8 magfilt);
void GX_InitTexObjMinLOD(GXTexObj *obj,f32 minlod);
void GX_InitTexObjMaxLOD(GXTexObj *obj,f32 maxlod);
void GX_InitTexObjLODBias(GXTexObj *obj,f32 lodbias);
void GX_InitTexObjBiasClamp(GXTexObj *obj,u8 biasclamp);
void GX_InitTexObjEdgeLOD(GXTexObj *obj,u8 edgelod);
void GX_InitTexObjMaxAniso(GXTexObj *obj,u8 maxaniso);
void GX_InitTexObjUserData(GXTexObj *obj,void *userdata);
# 4148 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadTexObj(GXTexObj *obj,u8 mapid);
# 4168 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadTlut(GXTlutObj *obj,u32 tlut_name);
# 4191 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadTexObjPreloaded(GXTexObj *obj,GXTexRegion *region,u8 mapid);
# 4209 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_PreloadEntireTexture(GXTexObj *obj,GXTexRegion *region);
# 4225 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTlutObj(GXTlutObj *obj,void *lut,u8 fmt,u16 entries);
# 4240 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTlutRegion(GXTlutRegion *region,u32 tmem_addr,u8 tlut_sz);
# 4273 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitTexObjLOD(GXTexObj *obj,u8 minfilt,u8 magfilt,f32 minlod,f32 maxlod,f32 lodbias,u8 biasclamp,u8 edgelod,u8 maxaniso);
# 4294 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTexCoordScaleManually(u8 texcoord,u8 enable,u16 ss,u16 ts);
# 4315 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetTexCoordBias(u8 texcoord,u8 s_enable,u8 t_enable);
# 4329 "/opt/devkitpro/libogc/include/ogc/gx.h"
GXTexRegionCallback GX_SetTexRegionCallback(GXTexRegionCallback cb);
# 4348 "/opt/devkitpro/libogc/include/ogc/gx.h"
GXTlutRegionCallback GX_SetTlutRegionCallback(GXTlutRegionCallback cb);
# 4371 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitLightPos(GXLightObj *lit_obj,f32 x,f32 y,f32 z);
# 4385 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitLightColor(GXLightObj *lit_obj,GXColor col);
# 4409 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitLightDir(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz);
# 4427 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadLightObj(GXLightObj *lit_obj,u8 lit_id);
# 4444 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_LoadLightObjIdx(u32 litobjidx,u8 litid);
# 4472 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitLightDistAttn(GXLightObj *lit_obj,f32 ref_dist,f32 ref_brite,u8 dist_fn);
# 4510 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitLightAttn(GXLightObj *lit_obj,f32 a0,f32 a1,f32 a2,f32 k0,f32 k1,f32 k2);
# 4538 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitLightAttnA(GXLightObj *lit_obj,f32 a0,f32 a1,f32 a2);
# 4566 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitLightAttnK(GXLightObj *lit_obj,f32 k0,f32 k1,f32 k2);
# 4591 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitSpecularDirHA(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz,f32 hx,f32 hy,f32 hz);
# 4617 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitSpecularDir(GXLightObj *lit_obj,f32 nx,f32 ny,f32 nz);
# 4646 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitLightSpot(GXLightObj *lit_obj,f32 cut_off,u8 spotfn);

u32 GX_ReadClksPerVtx();
u32 GX_GetOverflowCount();
u32 GX_ResetOverflowCount();
# 4665 "/opt/devkitpro/libogc/include/ogc/gx.h"
lwp_t GX_GetCurrentGXThread();
# 4683 "/opt/devkitpro/libogc/include/ogc/gx.h"
lwp_t GX_SetCurrentGXThread();
# 4697 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_RestoreWriteGatherPipe();
# 4724 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetGPMetric(u32 perf0,u32 perf1);
# 4736 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_ClearGPMetric();
# 4746 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_InitXfRasMetric();
# 4763 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_ReadXfRasMetric(u32 *xfwaitin,u32 *xfwaitout,u32 *rasbusy,u32 *clks);
# 4775 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_ClearVCacheMetric();
# 4792 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_ReadVCacheMetric(u32 *check,u32 *miss,u32 *stall);
# 4806 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_SetVCacheMetric(u32 attr);
# 4826 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_GetGPStatus(u8 *overhi,u8 *underlow,u8 *readIdle,u8 *cmdIdle,u8 *brkpt);
# 4846 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_ReadGPMetric(u32 *cnt0,u32 *cnt1);
# 4865 "/opt/devkitpro/libogc/include/ogc/gx.h"
void GX_ReadBoundingBox(u16 *top,u16 *bottom,u16 *left,u16 *right);
# 4895 "/opt/devkitpro/libogc/include/ogc/gx.h"
volatile void* GX_RedirectWriteGatherPipe(void *ptr);
# 5012 "/opt/devkitpro/libogc/include/ogc/gx.h"
   }
# 53 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/si.h" 1
# 66 "/opt/devkitpro/libogc/include/ogc/si.h"
   extern "C" {


typedef void (*SICallback)(s32,u32);
typedef void (*RDSTHandler)(u32,void*);

u32 SI_Sync();
u32 SI_Busy();
u32 SI_IsChanBusy(s32 chan);
void SI_EnablePolling(u32 poll);
void SI_DisablePolling(u32 poll);
void SI_SetCommand(s32 chan,u32 cmd);
u32 SI_GetStatus(s32 chan);
u32 SI_GetResponse(s32 chan,void *buf);
u32 SI_GetResponseRaw(s32 chan);
void SI_RefreshSamplingRate();
u32 SI_Transfer(s32 chan,void *out,u32 out_len,void *in,u32 in_len,SICallback cb,u32 us_delay);
u32 SI_GetTypeAsync(s32 chan,SICallback cb);
u32 SI_GetType(s32 chan);
u32 SI_GetCommand(s32 chan);
void SI_TransferCommands();
u32 SI_RegisterPollingHandler(RDSTHandler handler);
u32 SI_UnregisterPollingHandler(RDSTHandler handler);
u32 SI_EnablePollingInterrupt(s32 enable);


   }
# 54 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/gx_struct.h" 1
# 55 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/irq.h" 1
# 41 "/opt/devkitpro/libogc/include/ogc/irq.h"
# 1 "/opt/devkitpro/libogc/include/ogc/context.h" 1
# 27 "/opt/devkitpro/libogc/include/ogc/context.h"
   extern "C" {


typedef struct _excption_frame {
 u32 EXCPT_Number;
 u32 SRR0,SRR1;
 u32 GPR[32];
 u32 GQR[8];
 u32 CR, LR, CTR, XER, MSR, DAR;

 u16 state;
 u16 mode;

 f64 FPR[32];
 u64 FPSCR;
 f64 PSFPR[32];
} frame_context;


   }
# 42 "/opt/devkitpro/libogc/include/ogc/irq.h" 2
# 125 "/opt/devkitpro/libogc/include/ogc/irq.h"
   extern "C" {
# 134 "/opt/devkitpro/libogc/include/ogc/irq.h"
typedef void (*raw_irq_handler_t)(u32 irq,void *ctx);
# 145 "/opt/devkitpro/libogc/include/ogc/irq.h"
raw_irq_handler_t IRQ_Request(u32 nIrq,raw_irq_handler_t pHndl,void *pCtx);
# 154 "/opt/devkitpro/libogc/include/ogc/irq.h"
raw_irq_handler_t IRQ_Free(u32 nIrq);
# 163 "/opt/devkitpro/libogc/include/ogc/irq.h"
raw_irq_handler_t IRQ_GetHandler(u32 nIrq);







u32 IRQ_Disable(void);
# 180 "/opt/devkitpro/libogc/include/ogc/irq.h"
void IRQ_Restore(u32 level);

void __MaskIrq(u32 nMask);
void __UnmaskIrq(u32 nMask);


   }
# 56 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/lwp.h" 1
# 57 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/mutex.h" 1
# 44 "/opt/devkitpro/libogc/include/ogc/mutex.h"
 extern "C" {






typedef u32 mutex_t;
# 61 "/opt/devkitpro/libogc/include/ogc/mutex.h"
s32 LWP_MutexInit(mutex_t *mutex,bool use_recursive);
# 70 "/opt/devkitpro/libogc/include/ogc/mutex.h"
s32 LWP_MutexDestroy(mutex_t mutex);
# 79 "/opt/devkitpro/libogc/include/ogc/mutex.h"
s32 LWP_MutexLock(mutex_t mutex);
# 88 "/opt/devkitpro/libogc/include/ogc/mutex.h"
s32 LWP_MutexTryLock(mutex_t mutex);
# 97 "/opt/devkitpro/libogc/include/ogc/mutex.h"
s32 LWP_MutexUnlock(mutex_t mutex);


 }
# 58 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/message.h" 1
# 51 "/opt/devkitpro/libogc/include/ogc/message.h"
extern "C" {






typedef u32 mqbox_t;





typedef void* mqmsg_t;
# 75 "/opt/devkitpro/libogc/include/ogc/message.h"
s32 MQ_Init(mqbox_t *mqbox,u32 count);
# 84 "/opt/devkitpro/libogc/include/ogc/message.h"
void MQ_Close(mqbox_t mqbox);
# 95 "/opt/devkitpro/libogc/include/ogc/message.h"
BOOL MQ_Send(mqbox_t mqbox,mqmsg_t msg,u32 flags);
# 106 "/opt/devkitpro/libogc/include/ogc/message.h"
BOOL MQ_Jam(mqbox_t mqbox,mqmsg_t msg,u32 flags);
# 117 "/opt/devkitpro/libogc/include/ogc/message.h"
BOOL MQ_Receive(mqbox_t mqbox,mqmsg_t *msg,u32 flags);


 }
# 59 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/semaphore.h" 1
# 45 "/opt/devkitpro/libogc/include/ogc/semaphore.h"
extern "C" {






typedef u32 sem_t;
# 63 "/opt/devkitpro/libogc/include/ogc/semaphore.h"
s32 LWP_SemInit(sem_t *sem,u32 start,u32 max);
# 72 "/opt/devkitpro/libogc/include/ogc/semaphore.h"
s32 LWP_SemDestroy(sem_t sem);
# 81 "/opt/devkitpro/libogc/include/ogc/semaphore.h"
s32 LWP_SemWait(sem_t sem);
# 90 "/opt/devkitpro/libogc/include/ogc/semaphore.h"
s32 LWP_SemPost(sem_t sem);


 }
# 60 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/pad.h" 1
# 43 "/opt/devkitpro/libogc/include/ogc/pad.h"
   extern "C" {


typedef struct _padstatus {
 u16 button;
 s8 stickX;
 s8 stickY;
 s8 substickX;
 s8 substickY;
 u8 triggerL;
 u8 triggerR;
 u8 analogA;
 u8 analogB;
 s8 err;
} PADStatus;

typedef void (*sampling_callback)(void);




u32 PAD_Init();
u32 PAD_Sync();
u32 PAD_Read(PADStatus *status);
u32 PAD_Reset(u32 mask);
u32 PAD_Recalibrate(u32 mask);
void PAD_Clamp(PADStatus *status);
void PAD_ControlMotor(s32 chan,u32 cmd);
void PAD_SetSpec(u32 spec);

u32 PAD_ScanPads();

u16 PAD_ButtonsUp(int pad);
u16 PAD_ButtonsDown(int pad);
u16 PAD_ButtonsHeld(int pad);

s8 PAD_SubStickX(int pad);
s8 PAD_SubStickY(int pad);

s8 PAD_StickX(int pad);
s8 PAD_StickY(int pad);

u8 PAD_TriggerL(int pad);
u8 PAD_TriggerR(int pad);


sampling_callback PAD_SetSamplingCallback(sampling_callback cb);




   }
# 61 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/tpl.h" 1



# 1 "/opt/devkitpro/libogc/include/ogc/gx.h" 1
# 5 "/opt/devkitpro/libogc/include/ogc/tpl.h" 2


   extern "C" {


typedef void* FHANDLE;


typedef struct _tplfile {
 int type;
 int ntextures;
 void *texdesc;
 FHANDLE tpl_file;
} TPLFile;

s32 TPL_OpenTPLFromFile(TPLFile* tdf, const char* file_name);
s32 TPL_OpenTPLFromMemory(TPLFile* tdf, void *memory,u32 len);
s32 TPL_GetTexture(TPLFile *tdf,s32 id,GXTexObj *texObj);
s32 TPL_GetTextureCI(TPLFile *tdf,s32 id,GXTexObj *texObj,GXTlutObj *tlutObj,u8 tluts);
s32 TPL_GetTextureInfo(TPLFile *tdf,s32 id,u32 *fmt,u16 *width,u16 *height);
void TPL_CloseTPLFile(TPLFile *tdf);


   }
# 62 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/system.h" 1
# 42 "/opt/devkitpro/libogc/include/ogc/system.h"
# 1 "/opt/devkitpro/libogc/include/gcutil.h" 1
# 43 "/opt/devkitpro/libogc/include/ogc/system.h" 2
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 1 3
# 18 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/time.h" 1 3
# 19 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 2 3
# 27 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stddef.h" 1 3 4
# 211 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stddef.h" 3 4
typedef unsigned int size_t;
# 28 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 2 3

# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 1 3
# 69 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stddef.h" 1 3 4
# 149 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 70 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 2 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/types.h" 1 3
# 19 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/machine/types.h" 3
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 71 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 2 3
# 92 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;



typedef unsigned short ushort;
typedef unsigned int uint;



typedef unsigned long clock_t;




typedef long time_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};


typedef long daddr_t;
typedef char * caddr_t;






typedef unsigned int ino_t;
# 162 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 3
typedef _off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;





typedef int pid_t;



typedef long key_t;

typedef _ssize_t ssize_t;
# 191 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;
# 218 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 3
typedef long fd_mask;







typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8))-1))/((sizeof (fd_mask) * 8)))];
} _types_fd_set;
# 249 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef unsigned long useconds_t;
typedef long suseconds_t;

typedef __uint32_t fsblkcnt_t;
typedef __uint32_t fsfilcnt_t;

# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/features.h" 1 3
# 25 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/features.h" 3
extern "C" {
# 184 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/features.h" 3
}
# 265 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/types.h" 2 3
# 30 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 2 3

extern "C" {

struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
};

clock_t clock (void);
double difftime (time_t _time2, time_t _time1);
time_t mktime (struct tm *_timeptr);
time_t time (time_t *_timer);

char *asctime (const struct tm *_tblock);
char *ctime (const time_t *_time);
struct tm *gmtime (const time_t *_timer);
struct tm *localtime (const time_t *_timer);

size_t strftime (char *_s, size_t _maxsize, const char *_fmt, const struct tm *_t);

char *asctime_r (const struct tm *, char *);
char *ctime_r (const time_t *, char *);
struct tm *gmtime_r (const time_t *, struct tm *);
struct tm *localtime_r (const time_t *, struct tm *);

}


extern "C" {



char *strptime (const char *, const char *, struct tm *);
void tzset (void);
void _tzset_r (struct _reent *);

typedef struct __tzrule_struct
{
  char ch;
  int m;
  int n;
  int d;
  int s;
  time_t change;
  long offset;
} __tzrule_type;

typedef struct __tzinfo_struct
{
  int __tznorth;
  int __tzyear;
  __tzrule_type __tzrule[2];
} __tzinfo_type;

__tzinfo_type *__gettzinfo (void);
# 118 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 3
extern long _timezone;
extern int _daylight;
extern char *_tzname[2];
# 129 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 3
}
# 179 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 3
extern "C" {
# 257 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/time.h" 3
}
# 44 "/opt/devkitpro/libogc/include/ogc/system.h" 2
# 130 "/opt/devkitpro/libogc/include/ogc/system.h"
   extern "C" {







typedef u32 syswd_t;
# 154 "/opt/devkitpro/libogc/include/ogc/system.h"
typedef struct _syssram syssram;

struct _syssram {
 u16 checksum;
 u16 checksum_inv;
 u32 ead0;
 u32 ead1;
 u32 counter_bias;
 s8 display_offsetH;
 u8 ntd;
 u8 lang;
 u8 flags;
} __attribute__((packed));
# 180 "/opt/devkitpro/libogc/include/ogc/system.h"
typedef struct _syssramex syssramex;

struct _syssramex {
 u8 flash_id[2][12];
 u32 wirelessKbd_id;
 u16 wirelessPad_id[4];
 u8 dvderr_code;
 u8 __padding0;
 u16 flashID_chksum[2];
 u8 __padding1[4];
} __attribute__((packed));

typedef void (*alarmcallback)(syswd_t alarm,void *cb_arg);

typedef struct _sys_fontheader sys_fontheader;

struct _sys_fontheader {
 u16 font_type;
 u16 first_char;
 u16 last_char;
 u16 inval_char;
 u16 asc;
 u16 desc;
 u16 width;
 u16 leading;
    u16 cell_width;
    u16 cell_height;
    u32 sheet_size;
    u16 sheet_format;
    u16 sheet_column;
    u16 sheet_row;
    u16 sheet_width;
    u16 sheet_height;
    u16 width_table;
    u32 sheet_image;
    u32 sheet_fullsize;
    u8 c0;
    u8 c1;
    u8 c2;
    u8 c3;
} __attribute__((packed));

typedef void (*resetcallback)(void);
typedef void (*powercallback)(void);
typedef s32 (*resetfunction)(s32 final);
typedef struct _sys_resetinfo sys_resetinfo;

struct _sys_resetinfo {
 lwp_node node;
 resetfunction func;
 u32 prio;
};






void SYS_Init();
# 248 "/opt/devkitpro/libogc/include/ogc/system.h"
void* SYS_AllocateFramebuffer(GXRModeObj *rmode);


void SYS_ProtectRange(u32 chan,void *addr,u32 bytes,u32 cntrl);
void SYS_StartPMC(u32 mcr0val,u32 mcr1val);
void SYS_DumpPMC();
void SYS_StopPMC();
# 263 "/opt/devkitpro/libogc/include/ogc/system.h"
s32 SYS_CreateAlarm(syswd_t *thealarm);
# 274 "/opt/devkitpro/libogc/include/ogc/system.h"
s32 SYS_SetAlarm(syswd_t thealarm,const struct timespec *tp,alarmcallback cb,void *cbarg);
# 286 "/opt/devkitpro/libogc/include/ogc/system.h"
s32 SYS_SetPeriodicAlarm(syswd_t thealarm,const struct timespec *tp_start,const struct timespec *tp_period,alarmcallback cb,void *cbarg);
# 295 "/opt/devkitpro/libogc/include/ogc/system.h"
s32 SYS_RemoveAlarm(syswd_t thealarm);
# 304 "/opt/devkitpro/libogc/include/ogc/system.h"
s32 SYS_CancelAlarm(syswd_t thealarm);


void SYS_SetWirelessID(u32 chan,u32 id);
u32 SYS_GetWirelessID(u32 chan);
u32 SYS_GetFontEncoding();
u32 SYS_InitFont(sys_fontheader *font_data);
void SYS_GetFontTexture(s32 c,void **image,s32 *xpos,s32 *ypos,s32 *width);
void SYS_GetFontTexel(s32 c,void *image,s32 pos,s32 stride,s32 *width);
void SYS_ResetSystem(s32 reset,u32 reset_code,s32 force_menu);
void SYS_RegisterResetFunc(sys_resetinfo *info);
void SYS_UnregisterResetFunc(sys_resetinfo *info);
u32 SYS_GetArena1Size();
void SYS_SwitchFiber(u32 arg0,u32 arg1,u32 arg2,u32 arg3,u32 pc,u32 newsp);

void* SYS_GetArena1Lo();
void SYS_SetArena1Lo(void *newLo);
void* SYS_GetArena1Hi();
void SYS_SetArena1Hi(void *newHi);
u32 SYS_GetArena1Size();

resetcallback SYS_SetResetCallback(resetcallback cb);

u32 SYS_ResetButtonDown();


u32 SYS_GetHollywoodRevision();
void* SYS_GetArena2Lo();
void SYS_SetArena2Lo(void *newLo);
void* SYS_GetArena2Hi();
void SYS_SetArena2Hi(void *newHi);
u32 SYS_GetArena2Size();
powercallback SYS_SetPowerCallback(powercallback cb);


void kprintf(const char *str, ...);


   }
# 63 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/video.h" 1
# 42 "/opt/devkitpro/libogc/include/ogc/video.h"
# 1 "/opt/devkitpro/libogc/include/ogc/video_types.h" 1
# 152 "/opt/devkitpro/libogc/include/ogc/video_types.h"
extern GXRModeObj TVNtsc240Ds;
extern GXRModeObj TVNtsc240DsAa;
extern GXRModeObj TVNtsc240Int;
extern GXRModeObj TVNtsc240IntAa;
extern GXRModeObj TVNtsc480Int;
extern GXRModeObj TVNtsc480IntDf;
extern GXRModeObj TVNtsc480IntAa;
extern GXRModeObj TVNtsc480Prog;
extern GXRModeObj TVNtsc480ProgSoft;
extern GXRModeObj TVNtsc480ProgAa;
extern GXRModeObj TVMpal480IntDf;
extern GXRModeObj TVMpal480IntAa;
extern GXRModeObj TVMpal240Ds;
extern GXRModeObj TVMpal240DsAa;
extern GXRModeObj TVPal264Ds;
extern GXRModeObj TVPal264DsAa;
extern GXRModeObj TVPal264Int;
extern GXRModeObj TVPal264IntAa;
extern GXRModeObj TVPal524IntAa;
extern GXRModeObj TVPal528Int;
extern GXRModeObj TVPal528IntDf;
extern GXRModeObj TVPal574IntDfScale;
extern GXRModeObj TVEurgb60Hz240Ds;
extern GXRModeObj TVEurgb60Hz240DsAa;
extern GXRModeObj TVEurgb60Hz240Int;
extern GXRModeObj TVEurgb60Hz240IntAa;
extern GXRModeObj TVEurgb60Hz480Int;
extern GXRModeObj TVEurgb60Hz480IntDf;
extern GXRModeObj TVEurgb60Hz480IntAa;
extern GXRModeObj TVEurgb60Hz480Prog;
extern GXRModeObj TVEurgb60Hz480ProgSoft;
extern GXRModeObj TVEurgb60Hz480ProgAa;
# 43 "/opt/devkitpro/libogc/include/ogc/video.h" 2


   extern "C" {
# 54 "/opt/devkitpro/libogc/include/ogc/video.h"
typedef void (*VIRetraceCallback)(u32 retraceCnt);

typedef void (*VIPositionCallback)(u32 posX,u32 posY);

void* VIDEO_GetNextFramebuffer();
void* VIDEO_GetCurrentFramebuffer();
# 68 "/opt/devkitpro/libogc/include/ogc/video.h"
void VIDEO_Init();
# 77 "/opt/devkitpro/libogc/include/ogc/video.h"
void VIDEO_Flush();
# 88 "/opt/devkitpro/libogc/include/ogc/video.h"
void VIDEO_SetBlack(bool black);
# 97 "/opt/devkitpro/libogc/include/ogc/video.h"
u32 VIDEO_GetNextField();
# 106 "/opt/devkitpro/libogc/include/ogc/video.h"
u32 VIDEO_GetCurrentLine();
# 115 "/opt/devkitpro/libogc/include/ogc/video.h"
u32 VIDEO_GetCurrentTvMode();
# 126 "/opt/devkitpro/libogc/include/ogc/video.h"
void VIDEO_Configure(GXRModeObj *rmode);

u32 VIDEO_GetFrameBufferSize(GXRModeObj *rmode);
# 140 "/opt/devkitpro/libogc/include/ogc/video.h"
void VIDEO_ClearFrameBuffer(GXRModeObj *rmode,void *fb,u32 color);
# 149 "/opt/devkitpro/libogc/include/ogc/video.h"
void VIDEO_WaitVSync(void);
# 158 "/opt/devkitpro/libogc/include/ogc/video.h"
void VIDEO_SetNextFramebuffer(void *fb);
# 167 "/opt/devkitpro/libogc/include/ogc/video.h"
void VIDEO_SetNextRightFramebuffer(void *fb);
# 178 "/opt/devkitpro/libogc/include/ogc/video.h"
VIRetraceCallback VIDEO_SetPreRetraceCallback(VIRetraceCallback callback);
# 189 "/opt/devkitpro/libogc/include/ogc/video.h"
VIRetraceCallback VIDEO_SetPostRetraceCallback(VIRetraceCallback callback);
# 198 "/opt/devkitpro/libogc/include/ogc/video.h"
u32 VIDEO_HaveComponentCable(void);

GXRModeObj * VIDEO_GetPreferredMode(GXRModeObj *mode);


   }
# 64 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/usbgecko.h" 1






   extern "C" {


void usb_flush(s32 chn);
int usb_isgeckoalive(s32 chn);
int usb_recvbuffer(s32 chn,void *buffer,int size);
int usb_sendbuffer(s32 chn,const void *buffer,int size);
int usb_recvbuffer_safe(s32 chn,void *buffer,int size);
int usb_sendbuffer_safe(s32 chn,const void *buffer,int size);
int usb_recvbuffer_ex(s32 chn,void *buffer,int size, int retries);
int usb_sendbuffer_ex(s32 chn,const void *buffer,int size, int retries);
int usb_recvbuffer_safe_ex(s32 chn,void *buffer,int size, int retries);
int usb_sendbuffer_safe_ex(s32 chn,const void *buffer,int size, int retries);


   }
# 65 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/video_types.h" 1
# 66 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/texconv.h" 1
# 42 "/opt/devkitpro/libogc/include/ogc/texconv.h"
   extern "C" {


void MakeTexture565(const void *src,void *dst,s32 width,s32 height);


   }
# 67 "/opt/devkitpro/libogc/include/gccore.h" 2


# 1 "/opt/devkitpro/libogc/include/ogc/ipc.h" 1
# 53 "/opt/devkitpro/libogc/include/ogc/ipc.h"
   extern "C" {


typedef struct _ioctlv
{
 void *data;
 u32 len;
} ioctlv;

void __IPC_Reinitialize(void);

typedef s32 (*ipccallback)(s32 result,void *usrdata);

s32 iosCreateHeap(s32 size);
s32 iosDestroyHeap(s32 hid);
void* iosAlloc(s32 hid,s32 size);
void iosFree(s32 hid,void *ptr);

void* IPC_GetBufferLo();
void* IPC_GetBufferHi();
void IPC_SetBufferLo(void *bufferlo);
void IPC_SetBufferHi(void *bufferhi);

s32 IOS_Open(const char *filepath,u32 mode);
s32 IOS_OpenAsync(const char *filepath,u32 mode,ipccallback ipc_cb,void *usrdata);

s32 IOS_Close(s32 fd);
s32 IOS_CloseAsync(s32 fd,ipccallback ipc_cb,void *usrdata);

s32 IOS_Seek(s32 fd,s32 where,s32 whence);
s32 IOS_SeekAsync(s32 fd,s32 where,s32 whence,ipccallback ipc_cb,void *usrdata);
s32 IOS_Read(s32 fd,void *buf,s32 len);
s32 IOS_ReadAsync(s32 fd,void *buf,s32 len,ipccallback ipc_cb,void *usrdata);
s32 IOS_Write(s32 fd,const void *buf,s32 len);
s32 IOS_WriteAsync(s32 fd,const void *buf,s32 len,ipccallback ipc_cb,void *usrdata);

s32 IOS_Ioctl(s32 fd,s32 ioctl,void *buffer_in,s32 len_in,void *buffer_io,s32 len_io);
s32 IOS_IoctlAsync(s32 fd,s32 ioctl,void *buffer_in,s32 len_in,void *buffer_io,s32 len_io,ipccallback ipc_cb,void *usrdata);
s32 IOS_Ioctlv(s32 fd,s32 ioctl,s32 cnt_in,s32 cnt_io,ioctlv *argv);
s32 IOS_IoctlvAsync(s32 fd,s32 ioctl,s32 cnt_in,s32 cnt_io,ioctlv *argv,ipccallback ipc_cb,void *usrdata);

s32 IOS_IoctlvFormat(s32 hId,s32 fd,s32 ioctl,const char *format,...);
s32 IOS_IoctlvFormatAsync(s32 hId,s32 fd,s32 ioctl,ipccallback usr_cb,void *usr_data,const char *format,...);

s32 IOS_IoctlvReboot(s32 fd,s32 ioctl,s32 cnt_in,s32 cnt_io,ioctlv *argv);
s32 IOS_IoctlvRebootBackground(s32 fd,s32 ioctl,s32 cnt_in,s32 cnt_io,ioctlv *argv);


   }
# 70 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/es.h" 1
# 57 "/opt/devkitpro/libogc/include/ogc/es.h"
   extern "C" {


typedef u32 sigtype;
typedef sigtype sig_header;
typedef sig_header signed_blob;

typedef u8 sha1[20];
typedef u8 aeskey[16];

typedef struct _sig_rsa2048 {
 sigtype type;
 u8 sig[256];
 u8 fill[60];
} __attribute__((packed)) sig_rsa2048;

typedef struct _sig_rsa4096 {
 sigtype type;
 u8 sig[512];
 u8 fill[60];
} __attribute__((packed)) sig_rsa4096;

typedef struct _sig_ecdsa {
 sigtype type;
 u8 sig[60];
 u8 fill[64];
} __attribute__((packed)) sig_ecdsa;

typedef char sig_issuer[0x40];

typedef struct _tiklimit {
 u32 tag;
 u32 value;
} __attribute__((packed)) tiklimit;

typedef struct _tikview {
 u32 view;
 u64 ticketid;
 u32 devicetype;
 u64 titleid;
 u16 access_mask;
 u8 reserved[0x3c];
 u8 cidx_mask[0x40];
 u16 padding;
 tiklimit limits[8];
} __attribute__((packed)) tikview;

typedef struct _tik {
 sig_issuer issuer;
 u8 fill[63];
 aeskey cipher_title_key;
 u8 fill2;
 u64 ticketid;
 u32 devicetype;
 u64 titleid;
 u16 access_mask;
 u8 reserved[0x3c];
 u8 cidx_mask[0x40];
 u16 padding;
 tiklimit limits[8];
} __attribute__((packed)) tik;

typedef struct _tmd_content {
 u32 cid;
 u16 index;
 u16 type;
 u64 size;
 sha1 hash;
} __attribute__((packed)) tmd_content;

typedef struct _tmd {
 sig_issuer issuer;
 u8 version;
 u8 ca_crl_version;
 u8 signer_crl_version;
 u8 fill2;
 u64 sys_version;
 u64 title_id;
 u32 title_type;
 u16 group_id;
 u16 zero;
 u16 region;
 u8 ratings[16];
 u8 reserved[12];
 u8 ipc_mask[12];
 u8 reserved2[18];
 u32 access_rights;
 u16 title_version;
 u16 num_contents;
 u16 boot_index;
 u16 fill3;


 tmd_content contents[];
} __attribute__((packed)) tmd;

typedef struct _tmd_view_content
{
  u32 cid;
  u16 index;
  u16 type;
  u64 size;
} __attribute__((packed)) tmd_view_content;

typedef struct _tmdview
{
 u8 version;
 u8 filler[3];
 u64 sys_version;
 u64 title_id;
 u32 title_type;
 u16 group_id;
 u8 reserved[0x3e];
 u16 title_version;
 u16 num_contents;
 tmd_view_content contents[];
}__attribute__((packed)) tmd_view;

typedef struct _cert_header {
 sig_issuer issuer;
 u32 cert_type;
 char cert_name[64];
 u32 cert_id;
} __attribute__((packed)) cert_header;

typedef struct _cert_rsa2048 {
 sig_issuer issuer;
 u32 cert_type;
 char cert_name[64];
 u32 cert_id;
 u8 modulus[256];
 u32 exponent;
 u8 pad[0x34];
} __attribute__((packed)) cert_rsa2048;

typedef struct _cert_rsa4096 {
 sig_issuer issuer;
 u32 cert_type;
 char cert_name[64];
 u32 cert_id;
 u8 modulus[512];
 u32 exponent;
 u8 pad[0x34];
} __attribute__((packed)) cert_rsa4096;

typedef struct _cert_ecdsa {
 sig_issuer issuer;
 u32 cert_type;
 char cert_name[64];
 u32 cert_id;
 u8 r[30];
 u8 s[30];
 u8 pad[0x3c];
} __attribute__((packed)) cert_ecdsa;
# 253 "/opt/devkitpro/libogc/include/ogc/es.h"
s32 __ES_Init(void);
s32 __ES_Close(void);
s32 __ES_Reset(void);
s32 ES_GetTitleID(u64 *titleID);
s32 ES_SetUID(u64 uid);
s32 ES_GetDataDir(u64 titleID, char *filepath);
s32 ES_GetNumTicketViews(u64 titleID, u32 *cnt);
s32 ES_GetTicketViews(u64 titleID, tikview *views, u32 cnt);
s32 ES_GetNumOwnedTitles(u32 *cnt);
s32 ES_GetOwnedTitles(u64 *titles, u32 cnt);
s32 ES_GetNumTitles(u32 *cnt);
s32 ES_GetTitles(u64 *titles, u32 cnt);
s32 ES_GetNumStoredTMDContents(const signed_blob *stmd, u32 tmd_size, u32 *cnt);
s32 ES_GetStoredTMDContents(const signed_blob *stmd, u32 tmd_size, u32 *contents, u32 cnt);
s32 ES_GetStoredTMDSize(u64 titleID, u32 *size);
s32 ES_GetStoredTMD(u64 titleID, signed_blob *stmd, u32 size);
s32 ES_GetTitleContentsCount(u64 titleID, u32 *num);
s32 ES_GetTitleContents(u64 titleID, u8 *data, u32 size);
s32 ES_GetTMDViewSize(u64 titleID, u32 *size);
s32 ES_GetTMDView(u64 titleID, u8 *data, u32 size);
s32 ES_GetNumSharedContents(u32 *cnt);
s32 ES_GetSharedContents(sha1 *contents, u32 cnt);
s32 ES_LaunchTitle(u64 titleID, const tikview *view);
s32 ES_LaunchTitleBackground(u64 titleID, const tikview *view);
s32 ES_Identify(const signed_blob *certificates, u32 certificates_size, const signed_blob *tmd, u32 tmd_size, const signed_blob *ticket, u32 ticket_size, u32 *keyid);
s32 ES_AddTicket(const signed_blob *tik, u32 tik_size, const signed_blob *certificates, u32 certificates_size, const signed_blob *crl, u32 crl_size);
s32 ES_DeleteTicket(const tikview *view);
s32 ES_AddTitleTMD(const signed_blob *tmd, u32 tmd_size);
s32 ES_AddTitleStart(const signed_blob *tmd, u32 tmd_size, const signed_blob *certificatess, u32 certificatess_size, const signed_blob *crl, u32 crl_size);
s32 ES_AddContentStart(u64 titleID, u32 cid);
s32 ES_AddContentData(s32 cid, u8 *data, u32 data_size);
s32 ES_AddContentFinish(u32 cid);
s32 ES_AddTitleFinish(void);
s32 ES_AddTitleCancel(void);
s32 ES_ImportBoot(const signed_blob *tik, u32 tik_size,const signed_blob *tik_certs, u32 tik_certs_size,const signed_blob *tmd, u32 tmd_size,const signed_blob *tmd_certs, u32 tmd_certs_size,const u8 *content, u32 content_size);
s32 ES_OpenContent(u16 index);
s32 ES_OpenTitleContent(u64 titleID, tikview *views, u16 index);
s32 ES_ReadContent(s32 cfd, u8 *data, u32 data_size);
s32 ES_SeekContent(s32 cfd, s32 where, s32 whence);
s32 ES_CloseContent(s32 cfd);
s32 ES_DeleteTitle(u64 titleID);
s32 ES_DeleteTitleContent(u64 titleID);
s32 ES_Encrypt(u32 keynum, u8 *iv, u8 *source, u32 size, u8 *dest);
s32 ES_Decrypt(u32 keynum, u8 *iv, u8 *source, u32 size, u8 *dest);
s32 ES_Sign(u8 *source, u32 size, u8 *sig, u8 *certs);
s32 ES_GetDeviceCert(u8 *outbuf);
s32 ES_GetDeviceID(u32 *device_id);
s32 ES_GetBoot2Version(u32 *version);
signed_blob *ES_NextCert(const signed_blob *certs);


   }
# 71 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/stm.h" 1
# 47 "/opt/devkitpro/libogc/include/ogc/stm.h"
   extern "C" {


typedef void (*stmcallback)(u32 event);

s32 __STM_Init();
s32 __STM_Close();
s32 STM_ShutdownToStandby();
s32 STM_ShutdownToIdle();
s32 STM_SetLedMode(u32 mode);
s32 STM_RebootSystem();
stmcallback STM_RegisterEventHandler(stmcallback newhandler);


   }
# 72 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/ios.h" 1
# 45 "/opt/devkitpro/libogc/include/ogc/ios.h"
   extern "C" {


s32 __IOS_InitializeSubsystems(void);
s32 __IOS_ShutdownSubsystems(void);
s32 __IOS_LoadStartupIOS(void);
s32 __IOS_LaunchNewIOS(int version);
s32 IOS_GetPreferredVersion(void);
s32 IOS_ReloadIOS(int version);
s32 IOS_GetVersion();
s32 IOS_GetRevision();
s32 IOS_GetRevisionMajor();
s32 IOS_GetRevisionMinor();


   }
# 73 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/usb.h" 1
# 82 "/opt/devkitpro/libogc/include/ogc/usb.h"
   extern "C" {


typedef struct _usbendpointdesc
{
 u8 bLength;
 u8 bDescriptorType;
 u8 bEndpointAddress;
 u8 bmAttributes;
 u16 wMaxPacketSize;
 u8 bInterval;
} __attribute__((packed)) usb_endpointdesc;

typedef struct _usbinterfacedesc
{
 u8 bLength;
 u8 bDescriptorType;
 u8 bInterfaceNumber;
 u8 bAlternateSetting;
 u8 bNumEndpoints;
 u8 bInterfaceClass;
 u8 bInterfaceSubClass;
 u8 bInterfaceProtocol;
 u8 iInterface;
 u8 *extra;
 u8 extra_size;
 struct _usbendpointdesc *endpoints;
} __attribute__((packed)) usb_interfacedesc;

typedef struct _usbconfdesc
{
 u8 bLength;
 u8 bDescriptorType;
 u16 wTotalLength;
 u8 bNumInterfaces;
 u8 bConfigurationValue;
 u8 iConfiguration;
 u8 bmAttributes;
 u8 bMaxPower;
 struct _usbinterfacedesc *interfaces;
} __attribute__((packed)) usb_configurationdesc;

typedef struct _usbdevdesc
{
 u8 bLength;
 u8 bDescriptorType;
 u16 bcdUSB;
 u8 bDeviceClass;
 u8 bDeviceSubClass;
 u8 bDeviceProtocol;
 u8 bMaxPacketSize0;
 u16 idVendor;
 u16 idProduct;
 u16 bcdDevice;
 u8 iManufacturer;
 u8 iProduct;
 u8 iSerialNumber;
 u8 bNumConfigurations;
 struct _usbconfdesc *configurations;
} __attribute__((packed)) usb_devdesc;

typedef struct _usbhiddesc
{
 u8 bLength;
 u8 bDescriptorType;
 u16 bcdHID;
 u8 bCountryCode;
 u8 bNumDescriptors;
 struct {
  u8 bDescriptorType;
  u16 wDescriptorLength;
 } descr[1];
} __attribute__((packed)) usb_hiddesc;

typedef struct _usb_device_entry {
 s32 device_id;
 u16 vid;
 u16 pid;
 u32 token;
} usb_device_entry;

typedef s32 (*usbcallback)(s32 result,void *usrdata);

s32 USB_Initialize();
s32 USB_Deinitialize();

s32 USB_OpenDevice(s32 device_id,u16 vid,u16 pid,s32 *fd);
s32 USB_CloseDevice(s32 *fd);
s32 USB_CloseDeviceAsync(s32 *fd,usbcallback cb,void *usrdata);

s32 USB_GetDescriptors(s32 fd, usb_devdesc *udd);
void USB_FreeDescriptors(usb_devdesc *udd);

s32 USB_GetHIDDescriptor(s32 fd,usb_hiddesc *uhd);

s32 USB_GetDeviceDescription(s32 fd,usb_devdesc *devdesc);
s32 USB_DeviceRemovalNotifyAsync(s32 fd,usbcallback cb,void *userdata);
s32 USB_DeviceChangeNotifyAsync(u8 interface_class,usbcallback cb,void *userdata);

s32 USB_SuspendDevice(s32 fd);
s32 USB_ResumeDevice(s32 fd);

s32 USB_ReadIntrMsg(s32 fd,u8 bEndpoint,u16 wLength,void *rpData);
s32 USB_ReadIntrMsgAsync(s32 fd,u8 bEndpoint,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_ReadBlkMsg(s32 fd,u8 bEndpoint,u16 wLength,void *rpData);
s32 USB_ReadBlkMsgAsync(s32 fd,u8 bEndpoint,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_ReadCtrlMsg(s32 fd,u8 bmRequestType,u8 bmRequest,u16 wValue,u16 wIndex,u16 wLength,void *rpData);
s32 USB_ReadCtrlMsgAsync(s32 fd,u8 bmRequestType,u8 bmRequest,u16 wValue,u16 wIndex,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_WriteIntrMsg(s32 fd,u8 bEndpoint,u16 wLength,void *rpData);
s32 USB_WriteIntrMsgAsync(s32 fd,u8 bEndpoint,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_WriteBlkMsg(s32 fd,u8 bEndpoint,u16 wLength,void *rpData);
s32 USB_WriteBlkMsgAsync(s32 fd,u8 bEndpoint,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_WriteCtrlMsg(s32 fd,u8 bmRequestType,u8 bmRequest,u16 wValue,u16 wIndex,u16 wLength,void *rpData);
s32 USB_WriteCtrlMsgAsync(s32 fd,u8 bmRequestType,u8 bmRequest,u16 wValue,u16 wIndex,u16 wLength,void *rpData,usbcallback cb,void *usrdata);

s32 USB_GetConfiguration(s32 fd, u8 *configuration);
s32 USB_SetConfiguration(s32 fd, u8 configuration);
s32 USB_SetAlternativeInterface(s32 fd, u8 interface, u8 alternateSetting);
s32 USB_ClearHalt(s32 fd, u8 endpointAddress);
s32 USB_GetDeviceList(usb_device_entry *descr_buffer,u8 num_descr,u8 interface_class,u8 *cnt_descr);

s32 USB_GetAsciiString(s32 fd,u16 wIndex,u16 wLangID,u16 wLength,void *rpData);


   }
# 74 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/isfs.h" 1
# 19 "/opt/devkitpro/libogc/include/ogc/isfs.h"
   extern "C" {


typedef struct _fstats
{
 u32 file_length;
 u32 file_pos;
} fstats;

typedef s32 (*isfscallback)(s32 result,void *usrdata);

s32 ISFS_Initialize();
s32 ISFS_Deinitialize();

s32 ISFS_Open(const char *filepath,u8 mode);
s32 ISFS_OpenAsync(const char *filepath,u8 mode,isfscallback cb,void *usrdata);
s32 ISFS_Close(s32 fd);
s32 ISFS_CloseAsync(s32 fd,isfscallback cb,void *usrdata);
s32 ISFS_Delete(const char *filepath);
s32 ISFS_DeleteAsync(const char *filepath,isfscallback cb,void *usrdata);
s32 ISFS_ReadDir(const char *filepath,char *name_list,u32 *num);
s32 ISFS_ReadDirAsync(const char *filepath,char *name_list,u32 *num,isfscallback cb,void *usrdata);
s32 ISFS_CreateFile(const char *filepath,u8 attributes,u8 owner_perm,u8 group_perm,u8 other_perm);
s32 ISFS_CreateFileAsync(const char *filepath,u8 attributes,u8 owner_perm,u8 group_perm,u8 other_perm,isfscallback cb,void *usrdata);
s32 ISFS_Write(s32 fd,const void *buffer,u32 length);
s32 ISFS_WriteAsync(s32 fd,const void *buffer,u32 length,isfscallback cb,void *usrdata);
s32 ISFS_Read(s32 fd,void *buffer,u32 length);
s32 ISFS_ReadAsync(s32 fd,void *buffer,u32 length,isfscallback cb,void *usrdata);
s32 ISFS_Seek(s32 fd,s32 where,s32 whence);
s32 ISFS_SeekAsync(s32 fd,s32 where,s32 whence,isfscallback cb,void *usrdata);
s32 ISFS_CreateDir(const char *filepath,u8 attributes,u8 owner_perm,u8 group_perm,u8 other_perm);
s32 ISFS_CreateDirAsync(const char *filepath,u8 attributes,u8 owner_perm,u8 group_perm,u8 other_perm,isfscallback cb,void *usrdata);
s32 ISFS_GetStats(void *stats);
s32 ISFS_GetStatsAsync(void *stats,isfscallback cb,void *usrdata);
s32 ISFS_GetFileStats(s32 fd,fstats *status);
s32 ISFS_GetFileStatsAsync(s32 fd,fstats *status,isfscallback cb,void *usrdata);
s32 ISFS_GetAttr(const char *filepath,u32 *ownerID,u16 *groupID,u8 *attributes,u8 *ownerperm,u8 *groupperm,u8 *otherperm);
s32 ISFS_GetAttrAsync(const char *filepath,u32 *ownerID,u16 *groupID,u8 *attributes,u8 *ownerperm,u8 *groupperm,u8 *otherperm,isfscallback cb,void *usrdata);
s32 ISFS_Rename(const char *filepathOld,const char *filepathNew);
s32 ISFS_RenameAsync(const char *filepathOld,const char *filepathNew,isfscallback cb,void *usrdata);
s32 ISFS_SetAttr(const char *filepath,u32 ownerID,u16 groupID,u8 attributes,u8 ownerperm,u8 groupperm,u8 otherperm);
s32 ISFS_SetAttrAsync(const char *filepath,u32 ownerID,u16 groupID,u8 attributes,u8 ownerperm,u8 groupperm,u8 otherperm,isfscallback cb,void *usrdata);
s32 ISFS_GetUsage(const char* filepath, u32* usage1, u32* usage2);
s32 ISFS_GetUsageAsync(const char* filepath, u32* usage1, u32* usage2,isfscallback cb,void *usrdata);


   }
# 75 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/conf.h" 1
# 47 "/opt/devkitpro/libogc/include/ogc/conf.h"
   extern "C" {


enum {
 CONF_BIGARRAY = 1,
 CONF_SMALLARRAY,
 CONF_BYTE,
 CONF_SHORT,
 CONF_LONG,
 CONF_BOOL = 7
};

enum {
 CONF_VIDEO_NTSC = 0,
 CONF_VIDEO_PAL,
 CONF_VIDEO_MPAL
};

enum {
 CONF_REGION_JP = 0,
 CONF_REGION_US = 1,
 CONF_REGION_EU = 2,
 CONF_REGION_KR = 4,
 CONF_REGION_CN = 5
};

enum {
 CONF_AREA_JPN = 0,
 CONF_AREA_USA,
 CONF_AREA_EUR,
 CONF_AREA_AUS,
 CONF_AREA_BRA,
 CONF_AREA_TWN,
 CONF_AREA_ROC,
 CONF_AREA_KOR,
 CONF_AREA_HKG,
 CONF_AREA_ASI,
 CONF_AREA_LTN,
 CONF_AREA_SAF,
 CONF_AREA_CHN
};

enum {
 CONF_SHUTDOWN_STANDBY = 0,
 CONF_SHUTDOWN_IDLE
};

enum {
 CONF_LED_OFF = 0,
 CONF_LED_DIM,
 CONF_LED_BRIGHT
};

enum {
 CONF_SOUND_MONO = 0,
 CONF_SOUND_STEREO,
 CONF_SOUND_SURROUND
};

enum {
 CONF_LANG_JAPANESE = 0,
 CONF_LANG_ENGLISH,
 CONF_LANG_GERMAN,
 CONF_LANG_FRENCH,
 CONF_LANG_SPANISH,
 CONF_LANG_ITALIAN,
 CONF_LANG_DUTCH,
 CONF_LANG_SIMP_CHINESE,
 CONF_LANG_TRAD_CHINESE,
 CONF_LANG_KOREAN
};

enum {
 CONF_ASPECT_4_3 = 0,
 CONF_ASPECT_16_9
};

enum {
 CONF_SENSORBAR_BOTTOM = 0,
 CONF_SENSORBAR_TOP
};




typedef struct _conf_pad_device conf_pad_device;

struct _conf_pad_device {
 u8 bdaddr[6];
 char name[0x40];
} __attribute__((packed));

typedef struct _conf_pads conf_pads;

struct _conf_pads {
 u8 num_registered;
 conf_pad_device registered[10];
 conf_pad_device active[4];
 conf_pad_device balance_board;
 conf_pad_device unknown;
} __attribute__((packed));

s32 CONF_Init(void);
s32 CONF_GetLength(const char *name);
s32 CONF_GetType(const char *name);
s32 CONF_Get(const char *name, void *buffer, u32 length);
s32 CONF_GetShutdownMode(void);
s32 CONF_GetIdleLedMode(void);
s32 CONF_GetProgressiveScan(void);
s32 CONF_GetEuRGB60(void);
s32 CONF_GetIRSensitivity(void);
s32 CONF_GetSensorBarPosition(void);
s32 CONF_GetPadSpeakerVolume(void);
s32 CONF_GetPadMotorMode(void);
s32 CONF_GetSoundMode(void);
s32 CONF_GetLanguage(void);
s32 CONF_GetCounterBias(u32 *bias);
s32 CONF_GetScreenSaverMode(void);
s32 CONF_GetDisplayOffsetH(s8 *offset);
s32 CONF_GetPadDevices(conf_pads *pads);
s32 CONF_GetNickName(u8 *nickname);
s32 CONF_GetAspectRatio(void);
s32 CONF_GetEULA(void);
s32 CONF_GetParentalPassword(s8 *password);
s32 CONF_GetParentalAnswer(s8 *answer);
s32 CONF_GetWiiConnect24(void);
s32 CONF_GetRegion(void);
s32 CONF_GetArea(void);
s32 CONF_GetVideo(void);


   }
# 76 "/opt/devkitpro/libogc/include/gccore.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/usbstorage.h" 1






# 1 "/opt/devkitpro/libogc/include/ogc/mutex.h" 1
# 8 "/opt/devkitpro/libogc/include/ogc/usbstorage.h" 2



   extern "C" {
# 27 "/opt/devkitpro/libogc/include/ogc/usbstorage.h"
typedef struct
{
 u8 configuration;
 u32 interface;
 u32 altInterface;
 u8 bInterfaceSubClass;

 u8 ep_in;
 u8 ep_out;

 u8 max_lun;
 u32 *sector_size;

 s32 usb_fd;

 mutex_t lock;
 syswd_t alarm;
 s32 retval;

 u32 tag;
 u8 suspended;

 u8 *buffer;
} usbstorage_handle;

s32 USBStorage_Initialize();

s32 USBStorage_Open(usbstorage_handle *dev, s32 device_id, u16 vid, u16 pid);
s32 USBStorage_Close(usbstorage_handle *dev);
s32 USBStorage_Reset(usbstorage_handle *dev);

s32 USBStorage_GetMaxLUN(usbstorage_handle *dev);
s32 USBStorage_MountLUN(usbstorage_handle *dev, u8 lun);
s32 USBStorage_Suspend(usbstorage_handle *dev);

s32 USBStorage_ReadCapacity(usbstorage_handle *dev, u8 lun, u32 *sector_size, u32 *n_sectors);
s32 USBStorage_Read(usbstorage_handle *dev, u8 lun, u32 sector, u16 n_sectors, u8 *buffer);
s32 USBStorage_Write(usbstorage_handle *dev, u8 lun, u32 sector, u16 n_sectors, const u8 *buffer);
s32 USBStorage_StartStop(usbstorage_handle *dev, u8 lun, u8 lo_ej, u8 start, u8 imm);



extern DISC_INTERFACE __io_usbstorage;


   }
# 77 "/opt/devkitpro/libogc/include/gccore.h" 2

# 1 "/opt/devkitpro/libogc/include/ogc/wiilaunch.h" 1
# 62 "/opt/devkitpro/libogc/include/ogc/wiilaunch.h"
   extern "C" {


s32 WII_Initialize(void);
s32 WII_ReturnToMenu(void);
s32 WII_ReturnToSettings(void);
s32 WII_ReturnToSettingsPage(const char *page);
s32 WII_LaunchTitle(u64 titleID);
s32 WII_LaunchTitleWithArgs(u64 titleID, int launchcode, ...);
s32 WII_OpenURL(const char *url);


   }
# 79 "/opt/devkitpro/libogc/include/gccore.h" 2
# 99 "/opt/devkitpro/libogc/include/gccore.h"
   extern "C" {
# 141 "/opt/devkitpro/libogc/include/gccore.h"
s32 depackrnc1_ulen(void *packed);
s32 depackrnc1(void *packed,void *unpacked);

void depackrnc2(void *packed,void *unpacked);


   }
# 14 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireOgcDefines.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/gu.h" 1
# 15 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireOgcDefines.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/lwp_watchdog.h" 1




# 1 "/opt/devkitpro/libogc/include/ogc/lwp_queue.h" 1
# 6 "/opt/devkitpro/libogc/include/ogc/lwp_watchdog.h" 2
# 62 "/opt/devkitpro/libogc/include/ogc/lwp_watchdog.h"
extern "C" {


extern vu32 _wd_sync_level;
extern vu32 _wd_sync_count;
extern u32 _wd_ticks_since_boot;

extern lwp_queue _wd_ticks_queue;

extern u32 gettick();
extern u64 gettime();
extern void settime(u64);

u32 diff_sec(u64 start,u64 end);
u32 diff_msec(u64 start,u64 end);
u32 diff_usec(u64 start,u64 end);
u32 diff_nsec(u64 start,u64 end);

typedef void (*wd_service_routine)(void *);

typedef struct _wdcntrl {
 lwp_node node;
 u64 start;
 u32 id;
 u32 state;
 u64 fire;
 wd_service_routine routine;
 void *usr_data;
} wd_cntrl;

void __lwp_watchdog_init();
void __lwp_watchdog_settimer(wd_cntrl *wd);
void __lwp_wd_insert(lwp_queue *header,wd_cntrl *wd);
u32 __lwp_wd_remove(lwp_queue *header,wd_cntrl *wd);
void __lwp_wd_tickle(lwp_queue *queue);
void __lwp_wd_adjust(lwp_queue *queue,u32 dir,s64 interval);






 }
# 16 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireOgcDefines.h" 2
# 1 "/opt/devkitpro/libogc/include/ogc/machine/processor.h" 1




# 1 "/opt/devkitpro/libogc/include/ogc/machine/asm.h" 1
# 6 "/opt/devkitpro/libogc/include/ogc/machine/processor.h" 2
# 170 "/opt/devkitpro/libogc/include/ogc/machine/processor.h"
   extern "C" {


static inline u16 bswap16(u16 val)
{
 u16 tmp = val;
 return ({ register u16 res; __asm__ volatile ("lhbrx	%0,%1,%2" : "=r"(res) : "b%"(0), "r"(&tmp) : "memory"); res; });
}

static inline u32 bswap32(u32 val)
{
 u32 tmp = val;
 return ({ register u32 res; __asm__ volatile ("lwbrx	%0,%1,%2" : "=r"(res) : "b%"(0), "r"(&tmp) : "memory"); res; });
}

static inline u64 bswap64(u64 val)
{
 union ullc {
  u64 ull;
  u32 ul[2];
 } outv;
 u64 tmp = val;

 outv.ul[0] = ({ register u32 res; __asm__ volatile ("lwbrx	%0,%1,%2" : "=r"(res) : "b%"(4), "r"(&tmp) : "memory"); res; });
 outv.ul[1] = ({ register u32 res; __asm__ volatile ("lwbrx	%0,%1,%2" : "=r"(res) : "b%"(0), "r"(&tmp) : "memory"); res; });

 return outv.ull;
}



static inline u32 read32(u32 addr)
{
 u32 x;
 asm volatile("lwz %0,0(%1) ; sync" : "=r"(x) : "b"(0xc0000000 | addr));
 return x;
}

static inline void write32(u32 addr, u32 x)
{
 asm("stw %0,0(%1) ; eieio" : : "r"(x), "b"(0xc0000000 | addr));
}

static inline void mask32(u32 addr, u32 clear, u32 set)
{
 write32(addr, (read32(addr)&(~clear)) | set);
}

static inline u16 read16(u32 addr)
{
 u16 x;
 asm volatile("lhz %0,0(%1) ; sync" : "=r"(x) : "b"(0xc0000000 | addr));
 return x;
}

static inline void write16(u32 addr, u16 x)
{
 asm("sth %0,0(%1) ; eieio" : : "r"(x), "b"(0xc0000000 | addr));
}

static inline u8 read8(u32 addr)
{
 u8 x;
 asm volatile("lbz %0,0(%1) ; sync" : "=r"(x) : "b"(0xc0000000 | addr));
 return x;
}

static inline void write8(u32 addr, u8 x)
{
 asm("stb %0,0(%1) ; eieio" : : "r"(x), "b"(0xc0000000 | addr));
}

static inline void writef32(u32 addr, f32 x)
{
 asm("stfs %0,0(%1) ; eieio" : : "f"(x), "b"(0xc0000000 | addr));
}


   }
# 17 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireOgcDefines.h" 2
# 1 "/opt/devkitpro/libogc/include/wiiuse/wpad.h" 1
# 35 "/opt/devkitpro/libogc/include/wiiuse/wpad.h"
# 1 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h" 1
# 9 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h"
# 1 "/opt/devkitpro/libogc/include/bte/bte.h" 1




# 1 "/opt/devkitpro/libogc/include/bte/bd_addr.h" 1
# 39 "/opt/devkitpro/libogc/include/bte/bd_addr.h"
   extern "C" {


struct bd_addr {
  u8 addr[6];
};
# 76 "/opt/devkitpro/libogc/include/bte/bd_addr.h"
   }
# 6 "/opt/devkitpro/libogc/include/bte/bte.h" 2
# 70 "/opt/devkitpro/libogc/include/bte/bte.h"
   extern "C" {


struct l2cap_pcb;
struct ctrl_req_t;

struct inquiry_info
{
 struct bd_addr bdaddr;
 u8 cod[3];
};

struct inquiry_info_ex
{
 struct bd_addr bdaddr;
 u8 cod[3];
 u8 psrm;
 u8 psm;
 u16 co;
};

struct linkkey_info
{
 struct bd_addr bdaddr;
 u8 key[16];
};

struct bte_pcb
{
 u8 err;
 u32 state;
 void *cbarg;

 struct ctrl_req_t *ctrl_req_head;
 struct ctrl_req_t *ctrl_req_tail;

 lwpq_t cmdq;

 struct bd_addr bdaddr;

 struct l2cap_pcb *out_pcb;
 struct l2cap_pcb *in_pcb;


 s32 (*recv)(void *arg,void *buffer,u16 len);
 s32 (*conn_cfm)(void *arg,struct bte_pcb *pcb,u8 err);
 s32 (*disconn_cfm)(void *arg,struct bte_pcb *pcb,u8 err);
};

typedef s32 (*btecallback)(s32 result,void *userdata);

void BTE_Init();
void BTE_Shutdown();
s32 BTE_InitCore(btecallback cb);
s32 BTE_ApplyPatch(btecallback cb);
s32 BTE_InitSub(btecallback cb);
s32 BTE_ReadStoredLinkKey(struct linkkey_info *keys,u8 max_cnt,btecallback cb);
void (*BTE_SetDisconnectCallback(void (*callback)(struct bd_addr *bdaddr,u8 reason)))(struct bd_addr *bdaddr,u8 reason);

struct bte_pcb* bte_new();
void bte_arg(struct bte_pcb *pcb,void *arg);
void bte_received(struct bte_pcb *pcb, s32 (*recv)(void *arg,void *buffer,u16 len));
void bte_disconnected(struct bte_pcb *pcb,s32 (disconn_cfm)(void *arg,struct bte_pcb *pcb,u8 err));

s32 bte_registerdeviceasync(struct bte_pcb *pcb,struct bd_addr *bdaddr,s32 (*conn_cfm)(void *arg,struct bte_pcb *pcb,u8 err));

s32 bte_disconnect(struct bte_pcb *pcb);



s32 bte_inquiry(struct inquiry_info *info,u8 max_cnt,u8 flush);
s32 bte_inquiry_ex(struct inquiry_info_ex *info,u8 max_cnt,u8 flush);


s32 bte_senddata(struct bte_pcb *pcb,void *message,u16 len);
s32 bte_sendmessage(struct bte_pcb *pcb,void *message,u16 len);
s32 bte_sendmessageasync(struct bte_pcb *pcb,void *message,u16 len,s32 (*sent)(void *arg,struct bte_pcb *pcb,u8 err));


   }
# 10 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h" 2
# 109 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h"
typedef enum ir_position_t {
 WIIUSE_IR_ABOVE,
 WIIUSE_IR_BELOW
} ir_position_t;
# 187 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h"
typedef unsigned char ubyte;
typedef char sbyte;
typedef unsigned short uword;
typedef short sword;
typedef unsigned int uint;
typedef char sint;


struct wiimote_t;
struct vec3b_t;
struct orient_t;
struct gforce_t;


 typedef void (*wii_event_cb)(struct wiimote_t*, int event);
# 217 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h"
typedef void (*wiiuse_data_cb)(struct wiimote_t* wm, ubyte* data, unsigned short len);

typedef enum data_req_s
{
 REQ_READY = 0,
 REQ_SENT,
 REQ_DONE
} data_req_s;





struct data_req_t {
 lwp_node node;
 ubyte data[48];
 unsigned int len;
 data_req_s state;
 wiiuse_data_cb cb;
 struct data_req_t *next;
};

typedef void (*cmd_blk_cb)(struct wiimote_t *wm,ubyte *data,uword len);

typedef enum cmd_blk_s
{
 CMD_READY = 0,
 CMD_SENT,
 CMD_DONE
} cmd_blk_s;

struct cmd_blk_t
{
 lwp_node node;

 ubyte data[48];
 uint len;

 cmd_blk_s state;
 cmd_blk_cb cb;

 struct cmd_blk_t *next;
};






typedef struct vec2b_t {
 ubyte x, y;
} vec2b_t;






typedef struct vec3b_t {
 ubyte x, y, z;
} vec3b_t;





typedef struct vec3w_t {
 uword x, y, z;
} vec3w_t;






typedef struct vec3f_t {
 float x, y, z;
} vec3f_t;
# 303 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h"
typedef struct orient_t {
 float roll;
 float pitch;
 float yaw;

 float a_roll;
 float a_pitch;
} orient_t;






typedef struct gforce_t {
 float x, y, z;
} gforce_t;






typedef struct accel_t {
 struct vec3w_t cal_zero;
 struct vec3w_t cal_g;

 float st_roll;
 float st_pitch;
 float st_alpha;
} accel_t;






typedef struct ir_dot_t {
 ubyte visible;

 short rx;
 short ry;

 ubyte size;
} ir_dot_t;


typedef struct fdot_t {
 float x,y;
} fdot_t;

typedef struct sb_t {
 fdot_t dots[2];
 fdot_t acc_dots[2];
 fdot_t rot_dots[2];
 float angle;
 float off_angle;
 float score;
} sb_t;





typedef enum aspect_t {
 WIIUSE_ASPECT_4_3,
 WIIUSE_ASPECT_16_9
} aspect_t;






typedef struct ir_t {
 struct ir_dot_t dot[4];
 ubyte num_dots;

 int state;

 int raw_valid;
 sb_t sensorbar;
 float ax;
 float ay;
 float distance;
 float z;
 float angle;

 int smooth_valid;
 float sx;
 float sy;
 float error_cnt;
 float glitch_cnt;

 int valid;
 float x;
 float y;
 enum aspect_t aspect;
 enum ir_position_t pos;
 unsigned int vres[2];
 int offset[2];

} ir_t;
# 423 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h"
typedef struct joystick_t {
 struct vec2b_t max;
 struct vec2b_t min;
 struct vec2b_t center;
 struct vec2b_t pos;

 float ang;
 float mag;
} joystick_t;






typedef struct nunchuk_t {
 struct accel_t accel_calib;
 struct joystick_t js;

 int* flags;

 ubyte btns;
 ubyte btns_last;
 ubyte btns_held;
 ubyte btns_released;

 struct vec3w_t accel;
 struct orient_t orient;
 struct gforce_t gforce;
} nunchuk_t;






typedef struct classic_ctrl_t {
 short btns;
 short btns_last;
 short btns_held;
 short btns_released;

 ubyte rs_raw;
 ubyte ls_raw;

 float r_shoulder;
 float l_shoulder;

 struct joystick_t ljs;
 struct joystick_t rjs;
} classic_ctrl_t;






typedef struct guitar_hero_3_t {
 short btns;
 short btns_last;
 short btns_held;
 short btns_released;

 ubyte wb_raw;
 float whammy_bar;

 ubyte tb_raw;
 int touch_bar;

 struct joystick_t js;
} guitar_hero_3_t;





typedef struct wii_board_t {
 float tl;
 float tr;
 float bl;
 float br;
 short rtl;
 short rtr;
 short rbl;
 short rbr;
 short ctl[3];
 short ctr[3];
 short cbl[3];
 short cbr[3];
 float x;
 float y;
} wii_board_t;

typedef struct motion_plus_t
{
 short rx, ry, rz;
 ubyte status;
 ubyte ext;
} motion_plus_t;





typedef struct expansion_t {
 int type;

 union {
  struct nunchuk_t nunchuk;
  struct classic_ctrl_t classic;
  struct guitar_hero_3_t gh3;
   struct wii_board_t wb;
  struct motion_plus_t mp;
 };
} expansion_t;






typedef enum win_bt_stack_t {
 WIIUSE_STACK_UNKNOWN,
 WIIUSE_STACK_MS,
 WIIUSE_STACK_BLUESOLEIL
} win_bt_stack_t;






typedef struct wiimote_state_t {
 unsigned short btns;

 struct ir_t ir;
 struct vec3w_t accel;
 struct expansion_t exp;
} wiimote_state_t;






typedef enum WIIUSE_EVENT_TYPE {
 WIIUSE_NONE = 0,
 WIIUSE_EVENT,
 WIIUSE_STATUS,
 WIIUSE_CONNECT,
 WIIUSE_DISCONNECT,
 WIIUSE_UNEXPECTED_DISCONNECT,
 WIIUSE_READ_DATA,
 WIIUSE_WRITE_DATA,
 WIIUSE_NUNCHUK_INSERTED,
 WIIUSE_NUNCHUK_REMOVED,
 WIIUSE_CLASSIC_CTRL_INSERTED,
 WIIUSE_CLASSIC_CTRL_REMOVED,
 WIIUSE_GUITAR_HERO_3_CTRL_INSERTED,
  WIIUSE_GUITAR_HERO_3_CTRL_REMOVED,
  WIIUSE_WII_BOARD_INSERTED,
  WIIUSE_WII_BOARD_REMOVED,
  WIIUSE_MOTION_PLUS_ACTIVATED,
  WIIUSE_MOTION_PLUS_REMOVED
} WIIUSE_EVENT_TYPE;





typedef struct wiimote_t {
 const int unid;
# 604 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h"
  const lwp_queue cmdq;
  const struct bd_addr bdaddr;
  const char bdaddr_str[18];
  const struct bte_pcb *sock;
  const wii_event_cb event_cb;







 const int state;
 const ubyte leds;

 const ubyte battery_level;




 const int flags;

 const ubyte handshake_state;
 const ubyte expansion_state;

 const struct data_req_t* data_req;

 const struct cmd_blk_t *cmd_head;
 const struct cmd_blk_t *cmd_tail;

 const struct accel_t accel_calib;
 const struct expansion_t exp;

 const struct vec3w_t accel;
 const struct orient_t orient;
 const struct gforce_t gforce;

 const struct ir_t ir;

 const unsigned short btns;
 const unsigned short btns_last;
 const unsigned short btns_held;
 const unsigned short btns_released;

 const struct wiimote_state_t lstate;

 const WIIUSE_EVENT_TYPE event;
 const ubyte event_buf[32];

 const ubyte motion_plus_id[6];
} wiimote;






typedef struct wiimote_listen_t {
 const struct bd_addr bdaddr;
 const struct bte_pcb *sock;
 const struct wiimote_t *(*assign_cb)(struct bd_addr *bdaddr);
 const struct wiimote_t *wm;
} wiimote_listen;
# 690 "/opt/devkitpro/libogc/include/wiiuse/wiiuse.h"
extern "C" {



 extern const char* wiiuse_version();




 extern int wiiuse_register(struct wiimote_listen_t *wml, struct bd_addr *bdaddr, struct wiimote_t *(*assign_cb)(struct bd_addr *bdaddr));
 extern struct wiimote_t** wiiuse_init(int wiimotes, wii_event_cb event_cb);
 extern void wiiuse_sensorbar_enable(int enable);


 extern void wiiuse_disconnected(struct wiimote_t* wm);
 extern void wiiuse_cleanup(struct wiimote_t** wm, int wiimotes);
 extern void wiiuse_rumble(struct wiimote_t* wm, int status);
 extern void wiiuse_toggle_rumble(struct wiimote_t* wm);
 extern void wiiuse_set_leds(struct wiimote_t* wm, int leds,cmd_blk_cb cb);
 extern void wiiuse_motion_sensing(struct wiimote_t* wm, int status);
 extern int wiiuse_read_data(struct wiimote_t* wm, ubyte* buffer, unsigned int offset, unsigned short len, cmd_blk_cb cb);
 extern int wiiuse_write_data(struct wiimote_t *wm,unsigned int addr,ubyte *data,ubyte len,cmd_blk_cb cb);
 extern void wiiuse_status(struct wiimote_t *wm,cmd_blk_cb cb);
 extern struct wiimote_t* wiiuse_get_by_id(struct wiimote_t** wm, int wiimotes, int unid);
 extern int wiiuse_set_flags(struct wiimote_t* wm, int enable, int disable);
 extern float wiiuse_set_smooth_alpha(struct wiimote_t* wm, float alpha);
 extern void wiiuse_set_bluetooth_stack(struct wiimote_t** wm, int wiimotes, enum win_bt_stack_t type);
 extern void wiiuse_resync(struct wiimote_t* wm);
 extern void wiiuse_set_timeout(struct wiimote_t** wm, int wiimotes, ubyte normal_timeout, ubyte exp_timeout);
 extern int wiiuse_write_streamdata(struct wiimote_t *wm,ubyte *data,ubyte len,cmd_blk_cb cb);


 extern int wiiuse_find(struct wiimote_t** wm, int max_wiimotes, int timeout);
 extern int wiiuse_connect(struct wiimote_t** wm, int wiimotes);
 extern void wiiuse_disconnect(struct wiimote_t* wm);


 extern int wiiuse_poll(struct wiimote_t** wm, int wiimotes);


 extern void wiiuse_set_ir_mode(struct wiimote_t *wm);
 extern void wiiuse_set_ir(struct wiimote_t* wm, int status);
 extern void wiiuse_set_ir_vres(struct wiimote_t* wm, unsigned int x, unsigned int y);
 extern void wiiuse_set_ir_position(struct wiimote_t* wm, enum ir_position_t pos);
 extern void wiiuse_set_aspect_ratio(struct wiimote_t* wm, enum aspect_t aspect);
 extern void wiiuse_set_ir_sensitivity(struct wiimote_t* wm, int level);


 extern void wiiuse_set_motion_plus(struct wiimote_t *wm, int status);


 extern void wiiuse_set_speaker(struct wiimote_t *wm, int status);


}
# 36 "/opt/devkitpro/libogc/include/wiiuse/wpad.h" 2



enum {
 WPAD_CHAN_ALL = -1,
 WPAD_CHAN_0,
 WPAD_CHAN_1,
 WPAD_CHAN_2,
 WPAD_CHAN_3,
 WPAD_BALANCE_BOARD,
 WPAD_MAX_WIIMOTES,
};
# 90 "/opt/devkitpro/libogc/include/wiiuse/wpad.h"
enum {
 WPAD_EXP_NONE = 0,
 WPAD_EXP_NUNCHUK,
 WPAD_EXP_CLASSIC,
 WPAD_EXP_GUITARHERO3,
  WPAD_EXP_WIIBOARD,
 WPAD_EXP_UNKNOWN = 255
};

enum {
 WPAD_FMT_BTNS = 0,
 WPAD_FMT_BTNS_ACC,
 WPAD_FMT_BTNS_ACC_IR
};

enum {
 WPAD_STATE_DISABLED,
 WPAD_STATE_ENABLING,
 WPAD_STATE_ENABLED
};
# 140 "/opt/devkitpro/libogc/include/wiiuse/wpad.h"
   extern "C" {


typedef struct _wpad_data
{
 s16 err;

 u32 data_present;
 u8 battery_level;

 u32 btns_h;
 u32 btns_l;
 u32 btns_d;
 u32 btns_u;

 struct ir_t ir;
 struct vec3w_t accel;
 struct orient_t orient;
 struct gforce_t gforce;
 struct expansion_t exp;
} WPADData;

typedef struct _wpad_encstatus
{
 u8 data[32];
}WPADEncStatus;

typedef void (*WPADDataCallback)(s32 chan, const WPADData *data);
typedef void (*WPADShutdownCallback)(s32 chan);

s32 WPAD_Init();
s32 WPAD_ControlSpeaker(s32 chan,s32 enable);
s32 WPAD_ReadEvent(s32 chan, WPADData *data);
s32 WPAD_DroppedEvents(s32 chan);
s32 WPAD_Flush(s32 chan);
s32 WPAD_ReadPending(s32 chan, WPADDataCallback datacb);
s32 WPAD_SetDataFormat(s32 chan, s32 fmt);
s32 WPAD_SetMotionPlus(s32 chan, u8 enable);
s32 WPAD_SetVRes(s32 chan,u32 xres,u32 yres);
s32 WPAD_GetStatus();
s32 WPAD_Probe(s32 chan,u32 *type);
s32 WPAD_SetEventBufs(s32 chan, WPADData *bufs, u32 cnt);
s32 WPAD_Disconnect(s32 chan);
s32 WPAD_IsSpeakerEnabled(s32 chan);
s32 WPAD_SendStreamData(s32 chan,void *buf,u32 len);
void WPAD_Shutdown();
void WPAD_SetIdleTimeout(u32 seconds);
void WPAD_SetPowerButtonCallback(WPADShutdownCallback cb);
void WPAD_SetBatteryDeadCallback(WPADShutdownCallback cb);
s32 WPAD_ScanPads();
s32 WPAD_Rumble(s32 chan, int status);
s32 WPAD_SetIdleThresholds(s32 chan, s32 btns, s32 ir, s32 accel, s32 js, s32 wb, s32 mp);
void WPAD_EncodeData(WPADEncStatus *info,u32 flag,const s16 *pcmSamples,s32 numSamples,u8 *encData);
WPADData *WPAD_Data(int chan);
u8 WPAD_BatteryLevel(int chan);
u32 WPAD_ButtonsUp(int chan);
u32 WPAD_ButtonsDown(int chan);
u32 WPAD_ButtonsHeld(int chan);
void WPAD_IR(int chan, struct ir_t *ir);
void WPAD_Orientation(int chan, struct orient_t *orient);
void WPAD_GForce(int chan, struct gforce_t *gforce);
void WPAD_Accel(int chan, struct vec3w_t *accel);
void WPAD_Expansion(int chan, struct expansion_t *exp);


   }
# 18 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireOgcDefines.h" 2

typedef guVector Vec;
# 24 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h" 2
# 37 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h"
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/float.h" 1 3 4
# 38 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h" 2
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include-fixed/limits.h" 1 3 4
# 34 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include-fixed/limits.h" 3 4
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include-fixed/syslimits.h" 1 3 4






# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include-fixed/limits.h" 1 3 4
# 169 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include-fixed/limits.h" 3 4
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/limits.h" 1 3 4
# 170 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include-fixed/limits.h" 2 3 4
# 8 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include-fixed/syslimits.h" 2 3 4
# 35 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include-fixed/limits.h" 2 3 4
# 39 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h" 2
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 1 3
# 34 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 3
# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stddef.h" 1 3 4
# 35 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 2 3


# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stdarg.h" 1 3 4
# 40 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 38 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 2 3
# 48 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 3
extern "C" {

typedef __FILE FILE;
# 59 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 3
typedef _fpos_t fpos_t;





# 1 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/stdio.h" 1 3
# 9 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/stdio.h" 3
     extern void __flockfile(FILE *fp);
# 18 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/sys/stdio.h" 3
     extern void __funlockfile(FILE *fp);
# 66 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 2 3
# 175 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);
int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *, const char *, FILE *);
void setbuf (FILE *, char *);
int setvbuf (FILE *, char *, int, size_t);
int fprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int printf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int scanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int sscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int vfprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int vsprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int fgetc (FILE *);
char * fgets (char *, int, FILE *);
int fputc (int, FILE *);
int fputs (const char *, FILE *);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *, size_t _size, size_t _n, FILE *);
size_t fwrite (const void * , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *, fpos_t *);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *_name, const char *_type);
int sprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int remove (const char *);
int rename (const char *, const char *);






int fseeko (FILE *, off_t, int);
off_t ftello ( FILE *);




int asiprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
char * asniprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * asnprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int asprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int diprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int fcloseall (void);
int fiprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fiscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int iprintf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int iscanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int siprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int siscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int snprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int sniprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * tempnam (const char *, const char *);
int vasiprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vasprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vdiprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vfscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int viprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int viscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vsiprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vsiscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vsniprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsnprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
# 317 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 3
FILE * fdopen (int, const char *);

int fileno (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE * popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);
# 342 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 3
int dprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

FILE * fmemopen (void *, size_t, const char *);


FILE * open_memstream (char **, size_t *);



int vdprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;







int _asiprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
char * _asnprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _asprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _diprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _dprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *, int, FILE *);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fiscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
FILE * _fmemopen_r (struct _reent *, void *, size_t, const char *);
FILE * _fopen_r (struct _reent *, const char *, const char *);
FILE * _freopen_r (struct _reent *, const char *, const char *, FILE *);
int _fprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *, FILE *);
size_t _fread_r (struct _reent *, void *, size_t _size, size_t _n, FILE *);
int _fscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _fseek_r (struct _reent *, FILE *, long, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void * , size_t _size, size_t _n, FILE *);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _iscanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new)
                                          ;
int _scanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int _siprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _siscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _snprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _sprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _sscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vfprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _vscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsnprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 519 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 539 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 3
FILE *funopen (const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))



                                   ;
FILE *_funopen_r (struct _reent *, const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))



                                   ;







typedef ssize_t cookie_read_function_t(void *__cookie, char *__buf, size_t __n);
typedef ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
     size_t __n);




typedef int cookie_seek_function_t(void *__cookie, off_t *__off, int __whence);

typedef int cookie_close_function_t(void *__cookie);
typedef struct
{


  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
FILE *fopencookie (void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
FILE *_fopencookie_r (struct _reent *, void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
# 687 "/opt/devkitpro/devkitPPC/lib/gcc/powerpc-eabi/4.5.1/../../../../powerpc-eabi/include/stdio.h" 3
}
# 40 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h" 2


# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMemory.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireMemory.h"
       
# 43 "/home/pete/code/wire3d/Wire/Foundation/WireSystem.h" 2

namespace Wire
{

class System
{
public:
 static const UInt MAX_UINT;
 static const Int MAX_INT;

 static void* Memcpy(void* pDst, size_t dstSize, const void* pSrc,
  size_t srcSize);
 static void Memset(void* pDst, Int value, size_t count);
 static Int Memcmp(const void* pBuf1, const void* pBuf2, size_t size);

 static Double GetTime();
 static void Print(const Char* pFormat, ...);
 static void Assert(const Char* pExpression, const Char* pFile,
  Int lineNumber);


 static Bool Load(const Char* pFilename, Char*& rBuffer, Int& rSize);
 static Bool Load(const Char* pFilename, UChar*& rBuffer, Int& rSize);
 static Bool Save(const Char* pFilename, const Char* pBuffer, Int size);
 static Bool Save(const Char* pFilename, const UChar* pBuffer, Int size);

 static FILE* Fopen(const Char* pFilename, const Char* pMode);
  static Int Fprintf(FILE* pFile, const Char* pFormat, ...);
 static Int Fclose(FILE* pFile);

 static Char* Strcpy(Char* pDst, size_t dstSize, const Char* pSrc);
 static Char* Strcat(Char* pDst, size_t dstSize, const Char* pSrc);
 static Char* Strncpy(Char* pDst, size_t dstSize, const Char* pSrc,
        size_t srcSize);
 static UInt Strlen(const Char* pString);
 static Int Sprintf (Char* pDst, size_t dstSize, const Char* pFormat, ...);

 static Int Toupper(Int c);
 static Int Tolower(Int c);

private:
 static Bool s_InitializedTime;
};

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireSmartPointer.h" 2

namespace Wire
{

template <class T>
class Pointer
{
public:

 Pointer(T* pObject = __null);
 Pointer(const Pointer& rPointer);
 ~Pointer();


 inline operator T* () const;
 inline T& operator* () const;
 inline T* operator-> () const;

 inline T* Get() const;


 Pointer& operator= (T* pObject);
 Pointer& operator= (const Pointer& rReference);


 inline Bool operator== (T* pObject) const;
 inline Bool operator!= (T* pObject) const;
 inline Bool operator== (const Pointer& rReference) const;
 inline Bool operator!= (const Pointer& rReference) const;

protected:

    T* mpObject;
};

# 1 "/home/pete/code/wire3d/Wire/Engine/WireSmartPointer.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireSmartPointer.inl"
template <class T>
Pointer<T>::Pointer(T* pObject)
{
    mpObject = pObject;
    if (mpObject)
    {
        mpObject->IncrementReferences();
    }
}


template <class T>
Pointer<T>::Pointer(const Pointer& rPointer)
{
    mpObject = rPointer.mpObject;
    if (mpObject)
    {
        mpObject->IncrementReferences();
    }
}


template <class T>
Pointer<T>::~Pointer()
{
    if (mpObject)
    {
        mpObject->DecrementReferences();
    }
}


template <class T>
inline Pointer<T>::operator T* () const
{
    return mpObject;
}


template <class T>
inline T& Pointer<T>::operator* () const
{
    return *mpObject;
}


template <class T>
inline T* Pointer<T>::operator-> () const
{
    return mpObject;
}


template <class T>
inline T* Pointer<T>::Get() const
{
 return mpObject;
}


template <class T>
Pointer<T>& Pointer<T>::operator= (T* pObject)
{
    if (mpObject != pObject)
    {
        if (pObject)
        {
            pObject->IncrementReferences();
        }

        if (mpObject)
        {
            mpObject->DecrementReferences();
        }

        mpObject = pObject;
    }

 return *this;
}


template <class T>
Pointer<T>& Pointer<T>::operator= (const Pointer& rPointer)
{
    if (mpObject != rPointer.mpObject)
    {
        if (rPointer.mpObject)
        {
            rPointer.mpObject->IncrementReferences();
        }

        if (mpObject)
        {
            mpObject->DecrementReferences();
        }

        mpObject = rPointer.mpObject;
    }

    return *this;
}


template <class T>
inline Bool Pointer<T>::operator== (T* pObject) const
{
    return mpObject == pObject;
}


template <class T>
inline Bool Pointer<T>::operator!= (T* pObject) const
{
    return mpObject != pObject;
}


template <class T>
inline Bool Pointer<T>::operator== (const Pointer& rPointer) const
{
    return mpObject == rPointer.mpObject;
}


template <class T>
inline Bool Pointer<T>::operator!= (const Pointer& rPointer) const
{
    return mpObject != rPointer.mpObject;
}
# 50 "/home/pete/code/wire3d/Wire/Engine/WireSmartPointer.h" 2

}
# 15 "/home/pete/code/wire3d/Wire/Engine/WireObject.h" 2

namespace Wire
{

class Object
{
public:
 virtual ~Object();


 static const Rtti TYPE;
 inline virtual const Rtti& GetType() const;
 inline Bool IsExactly(const Rtti& rType) const;
 inline Bool IsDerived(const Rtti& rType) const;
 inline Bool IsExactlyTypeOf(const Object* pObject) const;
 inline Bool IsDerivedTypeOf(const Object* pObject) const;


 inline void IncrementReferences();
 void DecrementReferences();
 Int GetReferences() const;

protected:
 Object();

private:
 Int mReferences;
};


template <class T> T* StaticCast(Object* pObj);
template <class T> const T* StaticCast(const Object* pObj);
template <class T> T* DynamicCast(Object* pObj);
template <class T> const T* DynamicCast(const Object* pObj);

typedef Pointer<Object> ObjectPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireObject.inl" 1
# 12 "/home/pete/code/wire3d/Wire/Engine/WireObject.inl"
inline void Object::IncrementReferences()
{
 mReferences++;
}


inline Int Object::GetReferences() const
{
 return mReferences;
}




inline const Rtti& Object::GetType() const
{
 return TYPE;
}


inline Bool Object::IsExactly(const Rtti& rType) const
{
 return GetType().IsExactly(rType);
}


inline Bool Object::IsDerived(const Rtti& rType) const
{
 return GetType().IsDerived(rType);
}


inline Bool Object::IsExactlyTypeOf(const Object* pObj) const
{
 return pObj && GetType().IsExactly(pObj->GetType());
}


inline Bool Object::IsDerivedTypeOf(const Object* pObj) const
{
 return pObj && GetType().IsDerived(pObj->GetType());
}


template <class T>
inline T* StaticCast(Object* pObj)
{
 return static_cast<T*>(pObj);
}


template <class T>
inline const T* StaticCast(const Object* pObj)
{
 return static_cast<const T*>(pObj);
}


template <class T>
T* DynamicCast(Object* pObj)
{
 return pObj && pObj->IsDerived(T::TYPE) ? static_cast<T*>(pObj) : 0;
}


template <class T>
const T* DynamicCast(const Object* pObj)
{
 return pObj && pObj->IsDerived(T::TYPE) ? static_cast<const T*>(pObj) : 0;
}
# 52 "/home/pete/code/wire3d/Wire/Engine/WireObject.h" 2

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireBoundingVolume.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WirePlane3.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WirePlane3.h"
       



# 1 "/home/pete/code/wire3d/Wire/Foundation/WireVector3.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireVector3.h"
       




# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMath.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireMath.h"
       





namespace Wire
{

template <class Real>
class Math
{
public:
 static Real ACos(Real value);
 static Real ASin(Real value);
 static Real ATan(Real value);
    static Real ATan2(Real y, Real x);
 static Real Cos(Real value);
 static Real FAbs(Real value);
 static Real Floor(Real value);
 static Real FMod(Real x, Real y);
 static Real InvSqrt (Real value);
 static Real Sin(Real value);
 static Real Sqrt(Real value);
 static Real Tan(Real value);

 static Real Min(Real value1, Real value2);
 static Real Max(Real value1, Real value2);

 static Real Clamp(Real min, Real value, Real max);


 static const Real MAX_REAL;
 static const Real PI;
 static const Real TWO_PI;
 static const Real HALF_PI;
 static const Real DEG_TO_RAD;
 static const Real RAD_TO_DEG;
 static const Real ZERO_TOLERANCE;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMath.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireMath.inl"
template <class Real>
Real Math<Real>::ACos(Real value)
{
 if (-static_cast<Real>(1.0) < value)
 {
  if (value < static_cast<Real>(1.0))
  {
   return static_cast<Real>(acos(static_cast<Double>(value)));
  }
  else
  {
   return static_cast<Real>(0.0);
  }
 }
 else
 {
  return PI;
 }
}


template <class Real>
Real Math<Real>::ASin(Real value)
{
 if (-static_cast<Real>(1.0) < value)
 {
  if (value < static_cast<Real>(1.0))
  {
   return static_cast<Real>(asin(static_cast<Double>(value)));
  }
  else
  {
   return HALF_PI;
  }
 }
 else
 {
  return -HALF_PI;
 }
}


template <class Real>
Real Math<Real>::ATan(Real value)
{
 return static_cast<Real>(atan(static_cast<Double>(value)));
}


template <class Real>
Real Math<Real>::ATan2(Real y, Real x)
{
    return static_cast<Real>(atan2(static_cast<Double>(y),
  static_cast<Double>(x)));
}


template <class Real>
Real Math<Real>::Cos(Real value)
{
 return static_cast<Real>(cos(static_cast<Double>(value)));
}


template <class Real>
Real Math<Real>::FAbs(Real value)
{
 return static_cast<Real>(fabs(static_cast<Double>(value)));
}


template <class Real>
Real Math<Real>::Floor(Real value)
{
 return static_cast<Real>(floor(static_cast<Double>(value)));
}


template <class Real>
Real Math<Real>::FMod(Real x, Real y)
{
 return static_cast<Real>(
  fmod(static_cast<Double>(x), static_cast<Double>(y)));
}


template <class Real>
Real Math<Real>::InvSqrt(Real value)
{
 return static_cast<Real>(1.0/sqrt(static_cast<Double>(value)));
}


template <class Real>
Real Math<Real>::Sin(Real value)
{
 return static_cast<Real>(sin(static_cast<Double>(value)));
}


template <class Real>
Real Math<Real>::Sqrt(Real value)
{
 return static_cast<Real>(sqrt(static_cast<Double>(value)));
}


template <class Real>
Real Math<Real>::Tan(Real value)
{
 return static_cast<Real>(tan(static_cast<Double>(value)));
}


template <class Real>
Real Math<Real>::Min(Real value1, Real value2)
{
 return value1 < value2 ? value1 : value2;
}


template <class Real>
Real Math<Real>::Max(Real value1, Real value2)
{
 return value1 > value2 ? value1 : value2;
}


template <class Real>
Real Math<Real>::Clamp(Real min, Real value, Real max)
{
 if (value < min)
 {
  return min;
 }

 if (value > max)
 {
  return max;
 }

 return value;
}
# 51 "/home/pete/code/wire3d/Wire/Foundation/WireMath.h" 2

typedef Math<Float> MathF;
typedef Math<Double> MathD;

}
# 15 "/home/pete/code/wire3d/Wire/Foundation/WireVector3.h" 2

namespace Wire
{

template <class Real>
class Vector3
{
public:

 Vector3();
 Vector3(Real x, Real y, Real z);


 inline operator Real* ();
 inline operator const Real* () const;
 inline Real X() const;
 inline Real& X();
 inline Real Y() const;
 inline Real& Y();
 inline Real Z() const;
 inline Real& Z();


 inline Vector3& operator= (const Vector3& rVector);


  inline Bool operator== (const Vector3& rVector) const;
  inline Bool operator!= (const Vector3& rVector) const;


 inline Vector3 operator+ (const Vector3& rVector) const;
 inline Vector3 operator- (const Vector3& rVector) const;
 inline Vector3 operator* (Real scalar) const;
 inline Vector3 operator/ (Real scalar) const;
 inline Vector3 operator- () const;


 inline Vector3& operator+= (const Vector3& rVector);
 inline Vector3& operator-= (const Vector3& rVector);
 inline Vector3& operator*= (Real scalar);
 inline Vector3& operator/= (Real scalar);


 inline Real Length() const;
 inline Real SquaredLength() const;
 inline Real Dot(const Vector3& rVector) const;
 inline Real Normalize();






 inline Vector3 Cross(const Vector3& rVector) const;




 static void Orthonormalize(Vector3& rU, Vector3& rV, Vector3& rW);





 static void GenerateOrthonormalBasis(Vector3& rU, Vector3& rV,
  Vector3& rW);




 static void GenerateComplementBasis(Vector3& rU, Vector3& rV,
  const Vector3& rW);

 static const Vector3 ZERO;
 static const Vector3 UNIT_X;
 static const Vector3 UNIT_Y;
 static const Vector3 UNIT_Z;
 static const Vector3 ONE;

private:


 Vec mTuple;



};


template <class Real>
Vector3<Real> operator* (Real scalar, const Vector3<Real>& rVector);


# 1 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireVector3Wii.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireVector3Wii.inl"
template <class Real>
Vector3<Real>::Vector3()
{

}


template <class Real>
Vector3<Real>::Vector3(Real x, Real y, Real z)
{
 mTuple.x = x;
 mTuple.y = y;
 mTuple.z = z;
}


template <class Real>
inline Vector3<Real>::operator Real* ()
{
 return reinterpret_cast<Real*>(&mTuple);
}


template <class Real>
inline Vector3<Real>::operator const Real* () const
{
 return reinterpret_cast<Real*>(const_cast<Vec*>(&mTuple));
}


template <class Real>
inline Real Vector3<Real>::X() const
{
 return mTuple.x;
}


template <class Real>
inline Real& Vector3<Real>::X()
{
 return mTuple.x;
}


template <class Real>
inline Real Vector3<Real>::Y() const
{
 return mTuple.y;
}


template <class Real>
inline Real& Vector3<Real>::Y()
{
 return mTuple.y;
}


template <class Real>
inline Real Vector3<Real>::Z() const
{
 return mTuple.z;
}


template <class Real>
inline Real& Vector3<Real>::Z()
{
 return mTuple.z;
}


template <class Real>
inline Vector3<Real>& Vector3<Real>::operator= (const Vector3& rVector)
{
 mTuple.x = rVector.mTuple.x;
 mTuple.y = rVector.mTuple.y;
 mTuple.z = rVector.mTuple.z;
 return *this;
}


template <class Real>
Bool Vector3<Real>::operator== (const Vector3& rVector) const
{
 return (
  mTuple.x == rVector.mTuple.x &&
  mTuple.y == rVector.mTuple.y &&
  mTuple.z == rVector.mTuple.z);
}


template <class Real>
Bool Vector3<Real>::operator!= (const Vector3& rVector) const
{
 return !(
  mTuple.x == rVector.mTuple.x &&
  mTuple.y == rVector.mTuple.y &&
  mTuple.z == rVector.mTuple.z);

}


template <class Real>
inline Vector3<Real>& Vector3<Real>::operator+= (const Vector3& rVector)
{
 ps_guVecAdd(&mTuple, const_cast<Vec*>(&rVector.mTuple), &mTuple);
 return *this;
}


template <class Real>
inline Vector3<Real>& Vector3<Real>::operator-= (const Vector3& rVector)
{
 ps_guVecSub(&mTuple, const_cast<Vec*>(&rVector.mTuple), &mTuple);
 return *this;
}


template <class Real>
inline Vector3<Real>& Vector3<Real>::operator*= (Real scalar)
{
 ps_guVecScale(&mTuple, &mTuple, scalar);
 return *this;
}


template <class Real>
inline Vector3<Real>& Vector3<Real>::operator/= (Real scalar)
{
 if (scalar != static_cast<Real>(0.0))
 {
  Real invScalar = (static_cast<Real>(1.0)) / scalar;
  ps_guVecScale(&mTuple, &mTuple, invScalar);
 }
 else
 {
  mTuple.x = Math<Real>::MAX_REAL;
  mTuple.y = Math<Real>::MAX_REAL;
  mTuple.z = Math<Real>::MAX_REAL;
 }

 return *this;
}


template <class Real>
inline Real Vector3<Real>::Length() const
{


 return Math<Real>::Sqrt(
  mTuple.x * mTuple.x +
  mTuple.y * mTuple.y +
  mTuple.z * mTuple.z);
}


template <class Real>
inline Real Vector3<Real>::SquaredLength() const
{


 return
  mTuple.x * mTuple.x +
  mTuple.y * mTuple.y +
  mTuple.z * mTuple.z;
}


template <class Real>
inline Vector3<Real> Vector3<Real>::operator+ (const Vector3& rVector)
const
{
 Vector3 result;
 ps_guVecAdd(const_cast<Vec*>(&mTuple), const_cast<Vec*>(&rVector.
  mTuple), &result.mTuple);
 return result;
}


template <class Real>
inline Vector3<Real> Vector3<Real>::operator- (const Vector3& rVector)
const
{
 Vector3 result;
 ps_guVecSub(const_cast<Vec*>(&mTuple), const_cast<Vec*>(&rVector.
  mTuple), &result.mTuple);
 return result;
}


template <class Real>
inline Vector3<Real> Vector3<Real>::operator* (Real scalar) const
{
 Vector3 result;
 ps_guVecScale(const_cast<Vec*>(&mTuple), &result.mTuple, scalar);
 return result;
}


template <class Real>
inline Vector3<Real> Vector3<Real>::operator/ (Real scalar) const
{
 Vector3 quot;

 if (scalar != static_cast<Real>(0.0))
 {
  Real invScalar = (static_cast<Real>(1.0)) / scalar;
  ps_guVecScale(const_cast<Vec*>(&mTuple), &quot.mTuple, invScalar);
 }
 else
 {
  quot.mTuple.x = Math<Real>::MAX_REAL;
   quot.mTuple.y = Math<Real>::MAX_REAL;
   quot.mTuple.z = Math<Real>::MAX_REAL;
 }

 return quot;
}


template <class Real>
inline Vector3<Real> Vector3<Real>::operator- () const
{
 return Vector3(
  -mTuple.x,
  -mTuple.y,
  -mTuple.z);
}


template <class Real>
inline Vector3<Real> Vector3<Real>::Cross(const Vector3& rVector) const
{
 Vector3 result;
 ps_guVecCross(const_cast<Vec*>(&mTuple),
  const_cast<Vec*>(&rVector.mTuple), &result.mTuple);
 return result;
}


template <class Real>
inline Real Vector3<Real>::Dot(const Vector3& rVector) const
{
 return ps_guVecDotProduct(const_cast<Vec*>(&mTuple),
  const_cast<Vec*>(&rVector.mTuple));
}


template <class Real>
inline Real Vector3<Real>::Normalize()
{
 Real length = Length();

 if (length > Math<Real>::ZERO_TOLERANCE)
 {
  Real invLength = (static_cast<Real>(1.0)) / length;
  mTuple.x *= invLength;
  mTuple.y *= invLength;
  mTuple.z *= invLength;
 }
 else
 {
  length = static_cast<Real>(0.0);
  mTuple.x = static_cast<Real>(0.0);
  mTuple.y = static_cast<Real>(0.0);
  mTuple.z = static_cast<Real>(0.0);
 }

 return length;
}


template <class Real>
void Vector3<Real>::Orthonormalize(Vector3& rU, Vector3& rV, Vector3& rW)
{
# 298 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireVector3Wii.inl"
 rU.Normalize();


 Real dot0 = rU.Dot(rV);
 rV -= dot0*rU;
 rV.Normalize();


 Real dot1 = rV.Dot(rW);
 dot0 = rU.Dot(rW);
 rW -= dot0*rU + dot1*rV;
 rW.Normalize();
}


template <class Real>
void Vector3<Real>::GenerateOrthonormalBasis(Vector3& rU, Vector3& rV,
 Vector3& rW)
{
 rW.Normalize();
 GenerateComplementBasis(rU, rV, rW);
}


template <class Real>
void Vector3<Real>::GenerateComplementBasis(Vector3& rU, Vector3& rV,
 const Vector3& rW)
{
 if (Math<Real>::FAbs(rW.mTuple.x) >= Math<Real>::FAbs(rW.mTuple.y))
 {

  Real invLength = Math<Real>::InvSqrt(rW.mTuple.x * rW.mTuple.x +
   rW.mTuple.z * rW.mTuple.z);
  rU.mTuple.x = -rW.mTuple.z * invLength;
  rU.mTuple.y = static_cast<Real>(0.0);
  rU.mTuple.z = +rW.mTuple.x * invLength;
  rV.mTuple.x = rW.mTuple.y * rU.mTuple.z;
  rV.mTuple.y = rW.mTuple.z*rU.mTuple.x - rW.mTuple.x*rU.mTuple.z;
  rV.mTuple.z = -rW.mTuple.y * rU.mTuple.x;
 }
 else
 {

  Real invLength = Math<Real>::InvSqrt(rW.mTuple.y * rW.mTuple.y +
   rW.mTuple.z * rW.mTuple.z);
  rU.mTuple.x = static_cast<Real>(0.0);
  rU.mTuple.y = +rW.mTuple.z * invLength;
  rU.mTuple.z = -rW.mTuple.y * invLength;
  rV.mTuple.x = rW.mTuple.y*rU.mTuple.z - rW.mTuple.z*rU.mTuple.y;
  rV.mTuple.y = -rW.mTuple.x * rU.mTuple.z;
  rV.mTuple.z = rW.mTuple.x * rU.mTuple.y;
 }
}


template <class Real>
inline Vector3<Real> operator* (Real scalar, const Vector3<Real>& rVector)
{
 Vector3<Real> result;
 ps_guVecScale(reinterpret_cast<Vec*>(const_cast<Vector3<Real>*>(&rVector)),
  reinterpret_cast<Vec*>(&result), scalar);
 return result;
}
# 109 "/home/pete/code/wire3d/Wire/Foundation/WireVector3.h" 2




typedef Vector3<Float> Vector3F;
typedef Vector3<Double> Vector3D;

}
# 14 "/home/pete/code/wire3d/Wire/Foundation/WirePlane3.h" 2

namespace Wire
{

template <class Real>
class Plane3
{
public:





    Plane3();
    Plane3(const Plane3& rPlane);






 Real DistanceTo(const Vector3<Real>& rQ) const;





 Int WhichSide(const Vector3<Real>& rP) const;

 Vector3<Real> Normal;
 Real Constant;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WirePlane3.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WirePlane3.inl"
template <class Real>
Plane3<Real>::Plane3()
{

}


template <class Real>
Plane3<Real>::Plane3(const Plane3& rPlane)
 :
 Normal(rPlane.Normal)
{
 Constant = rPlane.Constant;
}


template <class Real>
Real Plane3<Real>::DistanceTo(const Vector3<Real>& rP) const
{
    return Normal.Dot(rP) - Constant;
}


template <class Real>
Int Plane3<Real>::WhichSide(const Vector3<Real>& rQ) const
{
 Real distance = DistanceTo(rQ);

 if (distance < static_cast<Real>(0.0))
 {
  return -1;
 }

 if (distance > static_cast<Real>(0.0))
 {
  return +1;
 }

 return 0;
}
# 48 "/home/pete/code/wire3d/Wire/Foundation/WirePlane3.h" 2

typedef Plane3<Float> Plane3F;
typedef Plane3<Double> Plane3D;

}
# 15 "/home/pete/code/wire3d/Wire/Engine/WireBoundingVolume.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireTransformation.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireTransformation.h"
       



# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix3.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix3.h"
       
# 42 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix3.h"
namespace Wire
{

template <class Real>
class Matrix3
{
public:
 Matrix3();



 Matrix3(Bool zero);


 Matrix3(Real m00, Real m01, Real m02,
  Real m10, Real m11, Real m12,
  Real m20, Real m21, Real m22);


 Matrix3(const Vector3<Real>& rU, const Vector3<Real>& rV,
  const Vector3<Real>& rW, Bool isColumn);



 Matrix3(const Vector3<Real>& rAxis, Real angle);


 void MakeZero();
 void MakeIdentity();
    void FromAxisAngle(const Vector3<Real>& rAxis, Real angle);


 inline operator const Real* () const;
 inline operator Real* ();
 inline const Real* operator[] (Int row) const;
 inline Real* operator[] (Int row);
 inline Real operator() (UInt row, UInt col) const;
 inline Real& operator() (UInt row, UInt col);
 void SetRow(UInt row, const Vector3<Real>& rV);
 Vector3<Real> GetRow(UInt row) const;
 void SetColumn(UInt col, const Vector3<Real>& rV);
 Vector3<Real> GetColumn(UInt col) const;


 inline Matrix3 operator* (const Matrix3& rMatrix) const;
 inline Matrix3 operator* (Real scalar) const;


 inline Vector3<Real> operator* (const Vector3<Real>& rV) const;


 Matrix3 Transpose() const;
 Matrix3 TransposeTimes(const Matrix3& rM) const;
 Matrix3 TimesTranspose(const Matrix3& rM) const;
 Matrix3 Inverse() const;
 Matrix3 TimesDiagonal(const Vector3<Real>& rDiag) const;


 static const Matrix3 ZERO;
 static const Matrix3 IDENTITY;

private:
    Real mEntry[9];
};


template <class Real>
inline Matrix3<Real> operator* (Real scalar, const Matrix3<Real>& rM);


template <class Real>
inline Vector3<Real> operator* (const Vector3<Real>& rV,
 const Matrix3<Real>& rM);

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix3.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix3.inl"
template <class Real>
Matrix3<Real>::Matrix3()
{

}


template <class Real>
Matrix3<Real>::Matrix3(Bool zero)
{
 if (zero)
 {
  MakeZero();
 }
 else
 {
  MakeIdentity();
 }
}


template <class Real>
Matrix3<Real>::Matrix3(Real m00, Real m01, Real m02, Real m10, Real m11,
 Real m12, Real m20, Real m21, Real m22)
{
 mEntry[0] = m00;
 mEntry[1] = m01;
 mEntry[2] = m02;
 mEntry[3] = m10;
 mEntry[4] = m11;
 mEntry[5] = m12;
 mEntry[6] = m20;
 mEntry[7] = m21;
 mEntry[8] = m22;
}


template <class Real>
Matrix3<Real>::Matrix3(const Vector3<Real>& rAxis, Real angle)
{
 FromAxisAngle(rAxis, angle);
}


template <class Real>
Matrix3<Real>::Matrix3(const Vector3<Real>& rU, const Vector3<Real>& rV,
 const Vector3<Real>& rW, Bool isColumn)
{
 if (isColumn)
 {
  mEntry[0] = rU[0];
  mEntry[1] = rV[0];
  mEntry[2] = rW[0];
  mEntry[3] = rU[1];
  mEntry[4] = rV[1];
  mEntry[5] = rW[1];
  mEntry[6] = rU[2];
  mEntry[7] = rV[2];
  mEntry[8] = rW[2];
 }
 else
 {
  mEntry[0] = rU[0];
  mEntry[1] = rU[1];
  mEntry[2] = rU[2];
  mEntry[3] = rV[0];
  mEntry[4] = rV[1];
  mEntry[5] = rV[2];
  mEntry[6] = rW[0];
  mEntry[7] = rW[1];
  mEntry[8] = rW[2];
 }
}


template <class Real>
void Matrix3<Real>::MakeZero()
{
 mEntry[0] = static_cast<Real>(0.0);
 mEntry[1] = static_cast<Real>(0.0);
 mEntry[2] = static_cast<Real>(0.0);
 mEntry[3] = static_cast<Real>(0.0);
 mEntry[4] = static_cast<Real>(0.0);
 mEntry[5] = static_cast<Real>(0.0);
 mEntry[6] = static_cast<Real>(0.0);
 mEntry[7] = static_cast<Real>(0.0);
 mEntry[8] = static_cast<Real>(0.0);
}


template <class Real>
void Matrix3<Real>::MakeIdentity()
{
 mEntry[0] = static_cast<Real>(1.0);
 mEntry[1] = static_cast<Real>(0.0);
 mEntry[2] = static_cast<Real>(0.0);
 mEntry[3] = static_cast<Real>(0.0);
 mEntry[4] = static_cast<Real>(1.0);
 mEntry[5] = static_cast<Real>(0.0);
 mEntry[6] = static_cast<Real>(0.0);
 mEntry[7] = static_cast<Real>(0.0);
 mEntry[8] = static_cast<Real>(1.0);
}


template <class Real>
void Matrix3<Real>::FromAxisAngle(const Vector3<Real>& rAxis,
 Real angle)
{
 Vector3<Real> axis = rAxis;
 Vector3<Real> u = axis / axis.Length();
 Real c = Math<Real>::Cos(angle);
 Real s = Math<Real>::Sin(angle);
 Real t = (static_cast<Real>(1.0)) - c;

 Real tuxuy = t*u.X()*u.Y();
 Real tuxuz = t*u.X()*u.Z();
 Real tuyuz = t*u.Y()*u.Z();

 mEntry[0] = t*u.X()*u.X() + c;
 mEntry[1] = tuxuy - s*u.Z();
 mEntry[2] = tuxuz + s*u.Y();

 mEntry[3] = tuxuy + s*u.Z();
 mEntry[4] = t*u.Y()*u.Y() + c;
 mEntry[5] = tuyuz - s*u.X();

 mEntry[6] = tuxuz - s*u.Y();
 mEntry[7] = tuyuz + s*u.X();
 mEntry[8] = t*u.Z()*u.Z() + c;
# 166 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix3.inl"
}


template <class Real>
inline Matrix3<Real>::operator const Real* () const
{
 return mEntry;
}


template <class Real>
inline Matrix3<Real>::operator Real* ()
{
 return mEntry;
}


template <class Real>
inline const Real* Matrix3<Real>::operator[] (Int row) const
{
 return &mEntry[3 * row];
}


template <class Real>
inline Real* Matrix3<Real>::operator[] (Int row)
{
 return &mEntry[3 * row];
}


template <class Real>
inline Real Matrix3<Real>::operator() (UInt row, UInt col) const
{
 return mEntry[col + 3 * row];
}


template <class Real>
inline Real& Matrix3<Real>::operator() (UInt row, UInt col)
{
 return mEntry[col + 3 * row];
}


template <class Real>
void Matrix3<Real>::SetRow(UInt row, const Vector3<Real>& rV)
{
 const UInt offset = 3*row;
 mEntry[offset] = rV[0];
 mEntry[offset+1] = rV[1];
 mEntry[offset+2] = rV[2];
}


template <class Real>
Vector3<Real> Matrix3<Real>::GetRow(UInt row) const
{
 const UInt offset = 3*row;
 return Vector3<Real>(mEntry[offset], mEntry[offset+1], mEntry[offset+2]);
}


template <class Real>
void Matrix3<Real>::SetColumn(UInt col, const Vector3<Real>& rVector)
{
 mEntry[col] = rVector[0];
 mEntry[col+3] = rVector[1];
 mEntry[col+6] = rVector[2];
}


template <class Real>
Vector3<Real> Matrix3<Real>::GetColumn(UInt col) const
{
 return Vector3<Real>(mEntry[col], mEntry[col+3], mEntry[col+6]);
}


template <class Real>
inline Matrix3<Real> Matrix3<Real>::operator* (const Matrix3& rMatrix) const
{
 return Matrix3<Real>(
  mEntry[0] * rMatrix.mEntry[0] +
  mEntry[1] * rMatrix.mEntry[3] +
  mEntry[2] * rMatrix.mEntry[6],

  mEntry[0] * rMatrix.mEntry[1] +
  mEntry[1] * rMatrix.mEntry[4] +
  mEntry[2] * rMatrix.mEntry[7],

  mEntry[0] * rMatrix.mEntry[2] +
  mEntry[1] * rMatrix.mEntry[5] +
  mEntry[2] * rMatrix.mEntry[8],

  mEntry[3] * rMatrix.mEntry[0] +
  mEntry[4] * rMatrix.mEntry[3] +
  mEntry[5] * rMatrix.mEntry[6],

  mEntry[3] * rMatrix.mEntry[1] +
  mEntry[4] * rMatrix.mEntry[4] +
  mEntry[5] * rMatrix.mEntry[7],

  mEntry[3] * rMatrix.mEntry[2] +
  mEntry[4] * rMatrix.mEntry[5] +
  mEntry[5] * rMatrix.mEntry[8],

  mEntry[6] * rMatrix.mEntry[0] +
  mEntry[7] * rMatrix.mEntry[3] +
  mEntry[8] * rMatrix.mEntry[6],

  mEntry[6] * rMatrix.mEntry[1] +
  mEntry[7] * rMatrix.mEntry[4] +
  mEntry[8] * rMatrix.mEntry[7],

  mEntry[6] * rMatrix.mEntry[2] +
  mEntry[7] * rMatrix.mEntry[5] +
  mEntry[8] * rMatrix.mEntry[8]);
}


template <class Real>
inline Matrix3<Real> Matrix3<Real>::operator* (Real scalar) const
{
 return Matrix3<Real>(
  scalar * mEntry[0],
  scalar * mEntry[1],
  scalar * mEntry[2],
  scalar * mEntry[3],
  scalar * mEntry[4],
  scalar * mEntry[5],
  scalar * mEntry[6],
  scalar * mEntry[7],
  scalar * mEntry[8]);
}


template <class Real>
inline Vector3<Real> Matrix3<Real>::operator* (const Vector3<Real>& rV) const
{
 return Vector3<Real>(
  mEntry[0] * rV[0] + mEntry[1] * rV[1] + mEntry[2] * rV[2],
  mEntry[3] * rV[0] + mEntry[4] * rV[1] + mEntry[5] * rV[2],
  mEntry[6] * rV[0] + mEntry[7] * rV[1] + mEntry[8] * rV[2]);
}


template <class Real>
Matrix3<Real> Matrix3<Real>::Transpose() const
{
 return Matrix3<Real>(
  mEntry[0],
  mEntry[3],
  mEntry[6],
  mEntry[1],
  mEntry[4],
  mEntry[7],
  mEntry[2],
  mEntry[5],
  mEntry[8]);
}


template <class Real>
Matrix3<Real> Matrix3<Real>::TransposeTimes(const Matrix3& rM) const
{

 return Matrix3<Real>(
  mEntry[0] * rM.mEntry[0] +
  mEntry[3] * rM.mEntry[3] +
  mEntry[6] * rM.mEntry[6],

  mEntry[0] * rM.mEntry[1] +
  mEntry[3] * rM.mEntry[4] +
  mEntry[6] * rM.mEntry[7],

  mEntry[0] * rM.mEntry[2] +
  mEntry[3] * rM.mEntry[5] +
  mEntry[6] * rM.mEntry[8],

  mEntry[1] * rM.mEntry[0] +
  mEntry[4] * rM.mEntry[3] +
  mEntry[7] * rM.mEntry[6],

  mEntry[1] * rM.mEntry[1] +
  mEntry[4] * rM.mEntry[4] +
  mEntry[7] * rM.mEntry[7],

  mEntry[1] * rM.mEntry[2] +
  mEntry[4] * rM.mEntry[5] +
  mEntry[7] * rM.mEntry[8],

  mEntry[2] * rM.mEntry[0] +
  mEntry[5] * rM.mEntry[3] +
  mEntry[8] * rM.mEntry[6],

  mEntry[2] * rM.mEntry[1] +
  mEntry[5] * rM.mEntry[4] +
  mEntry[8] * rM.mEntry[7],

  mEntry[2] * rM.mEntry[2] +
  mEntry[5] * rM.mEntry[5] +
  mEntry[8] * rM.mEntry[8]);
}


template <class Real>
Matrix3<Real> Matrix3<Real>::TimesTranspose(const Matrix3& rM) const
{

 return Matrix3<Real>(
  mEntry[0] * rM.mEntry[0] +
  mEntry[1] * rM.mEntry[1] +
  mEntry[2] * rM.mEntry[2],

  mEntry[0] * rM.mEntry[3] +
  mEntry[1] * rM.mEntry[4] +
  mEntry[2] * rM.mEntry[5],

  mEntry[0] * rM.mEntry[6] +
  mEntry[1] * rM.mEntry[7] +
  mEntry[2] * rM.mEntry[8],

  mEntry[3] * rM.mEntry[0] +
  mEntry[4] * rM.mEntry[1] +
  mEntry[5] * rM.mEntry[2],

  mEntry[3] * rM.mEntry[3] +
  mEntry[4] * rM.mEntry[4] +
  mEntry[5] * rM.mEntry[5],

  mEntry[3] * rM.mEntry[6] +
  mEntry[4] * rM.mEntry[7] +
  mEntry[5] * rM.mEntry[8],

  mEntry[6] * rM.mEntry[0] +
  mEntry[7] * rM.mEntry[1] +
  mEntry[8] * rM.mEntry[2],

  mEntry[6] * rM.mEntry[3] +
  mEntry[7] * rM.mEntry[4] +
  mEntry[8] * rM.mEntry[5],

  mEntry[6] * rM.mEntry[6] +
  mEntry[7] * rM.mEntry[7] +
  mEntry[8] * rM.mEntry[8]);
}


template <class Real>
Matrix3<Real> Matrix3<Real>::Inverse() const
{



 Matrix3 inverse;

 inverse.mEntry[0] = mEntry[4] * mEntry[8] - mEntry[5] * mEntry[7];
 inverse.mEntry[1] = mEntry[2] * mEntry[7] - mEntry[1] * mEntry[8];
 inverse.mEntry[2] = mEntry[1] * mEntry[5] - mEntry[2] * mEntry[4];
 inverse.mEntry[3] = mEntry[5] * mEntry[6] - mEntry[3] * mEntry[8];
 inverse.mEntry[4] = mEntry[0] * mEntry[8] - mEntry[2] * mEntry[6];
 inverse.mEntry[5] = mEntry[2] * mEntry[3] - mEntry[0] * mEntry[5];
 inverse.mEntry[6] = mEntry[3] * mEntry[7] - mEntry[4] * mEntry[6];
 inverse.mEntry[7] = mEntry[1] * mEntry[6] - mEntry[0] * mEntry[7];
 inverse.mEntry[8] = mEntry[0] * mEntry[4] - mEntry[1] * mEntry[3];

 Real det =
  mEntry[0] * inverse.mEntry[0] +
  mEntry[1] * inverse.mEntry[3] +
  mEntry[2] * inverse.mEntry[6];

 if (Math<Real>::FAbs(det) <= Math<Real>::ZERO_TOLERANCE)
 {
  return ZERO;
 }

 Real invDet = (static_cast<Real>(1.0)) / det;
 inverse.mEntry[0] *= invDet;
 inverse.mEntry[1] *= invDet;
 inverse.mEntry[2] *= invDet;
 inverse.mEntry[3] *= invDet;
 inverse.mEntry[4] *= invDet;
 inverse.mEntry[5] *= invDet;
 inverse.mEntry[6] *= invDet;
 inverse.mEntry[7] *= invDet;
 inverse.mEntry[8] *= invDet;
 return inverse;
}


template <class Real>
Matrix3<Real> Matrix3<Real>::TimesDiagonal(const Vector3<Real>& rDiag) const
{
 return Matrix3<Real>(
  mEntry[0] * rDiag[0], mEntry[1] * rDiag[1], mEntry[2] * rDiag[2],
  mEntry[3] * rDiag[0], mEntry[4] * rDiag[1], mEntry[5] * rDiag[2],
  mEntry[6] * rDiag[0], mEntry[7] * rDiag[1], mEntry[8] * rDiag[2]);
}


template <class Real>
inline Matrix3<Real> operator* (Real scalar, const Matrix3<Real>& rM)
{
 return rM * scalar;
}


template <class Real>
inline Vector3<Real> operator* (const Vector3<Real>& rV,
 const Matrix3<Real>& rM)
{
 return Vector3<Real>(
  rV[0]*rM[0][0] + rV[1]*rM[1][0] + rV[2]*rM[2][0],
  rV[0]*rM[0][1] + rV[1]*rM[1][1] + rV[2]*rM[2][1],
  rV[0]*rM[0][2] + rV[1]*rM[1][2] + rV[2]*rM[2][2]);
}
# 117 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix3.h" 2

typedef Matrix3<Float> Matrix3F;
typedef Matrix3<Double> Matrix3D;

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireTransformation.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix34.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix34.h"
       
# 46 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix34.h"
namespace Wire
{

template <class Real>
class Matrix34
{
public:
 typedef Real Real4[4];

 Matrix34();



 Matrix34(Bool zero);


 Matrix34(Real m00, Real m01, Real m02, Real m03,
  Real m10, Real m11, Real m12, Real m13,
  Real m20, Real m21, Real m22, Real m23);



 Matrix34(const Vector3<Real>& rAxis, Real angle);



 Matrix34(const Vector3<Real>& rU, const Vector3<Real>& rV,
  const Vector3<Real>& rW, Bool isColumn);


 Matrix34(const Matrix3<Real>& rM, const Vector3<Real>& rV);


 void SetMatrix3(const Matrix3<Real>& rM);


 void MakeZero();
 void MakeIdentity();
 void FromAxisAngle(const Vector3<Real>& rAxis, Real angle);


 inline operator Real4* ();
 inline operator const Real* () const;
  inline const Real* operator[] (Int row) const;
  inline Real* operator[] (Int row);
 inline Real operator() (UInt row, UInt col) const;
    inline Real& operator() (UInt row, UInt col);
 void SetRow(UInt row, const Vector3<Real>& rV);
 Vector3<Real> GetRow(UInt row) const;
 void SetColumn(UInt col, const Vector3<Real>& rV);
 Vector3<Real> GetColumn(UInt col) const;


 inline Matrix34 operator* (const Matrix34& rMatrix) const;
 inline Matrix34 operator* (Real scalar) const;


 inline Vector3<Real> operator* (const Vector3<Real>& rV) const;


 Matrix34 TimesDiagonal(const Vector3<Real>& rDiag) const;
    Matrix34 Inverse() const;


    static const Matrix34 ZERO;
    static const Matrix34 IDENTITY;

private:
 Real mEntry[3][4];
};


template <class Real>
inline Vector3<Real> operator* (const Vector3<Real>& rV,
 const Matrix34<Real>& rM);


# 1 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireMatrix34Wii.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireMatrix34Wii.inl"
template <class Real>
Matrix34<Real>::Matrix34()
{

}


template <class Real>
Matrix34<Real>::Matrix34(Bool zero)
{
 if (zero)
 {
  MakeZero();
 }
 else
 {
  MakeIdentity();
 }
}


template <class Real>
Matrix34<Real>::Matrix34(
 Real m00, Real m01, Real m02, Real m03,
 Real m10, Real m11, Real m12, Real m13,
 Real m20, Real m21, Real m22, Real m23)
{
 mEntry[0][0] = m00;
 mEntry[0][1] = m01;
 mEntry[0][2] = m02;
 mEntry[0][3] = m03;
 mEntry[1][0] = m10;
 mEntry[1][1] = m11;
 mEntry[1][2] = m12;
 mEntry[1][3] = m13;
 mEntry[2][0] = m20;
 mEntry[2][1] = m21;
 mEntry[2][2] = m22;
 mEntry[2][3] = m23;
}


template <class Real>
Matrix34<Real>::Matrix34(const Vector3<Real>& rAxis, Real angle)
{
 FromAxisAngle(rAxis, angle);
}


template <class Real>
Matrix34<Real>::Matrix34(const Vector3<Real>& rU, const Vector3<Real>& rV,
 const Vector3<Real>& rW, Bool isColumn)
{
 mEntry[0][3] = static_cast<Real>(0.0);
 mEntry[1][3] = static_cast<Real>(0.0);
 mEntry[2][3] = static_cast<Real>(0.0);

 if (isColumn)
 {
  mEntry[0][0] = rU[0];
  mEntry[0][1] = rV[0];
  mEntry[0][2] = rW[0];
  mEntry[1][0] = rU[1];
  mEntry[1][1] = rV[1];
  mEntry[1][2] = rW[1];
  mEntry[2][0] = rU[2];
  mEntry[2][1] = rV[2];
  mEntry[2][2] = rW[2];
 }
 else
 {
  mEntry[0][0] = rU[0];
  mEntry[0][1] = rU[1];
  mEntry[0][2] = rU[2];
  mEntry[1][0] = rV[0];
  mEntry[1][1] = rV[1];
  mEntry[1][2] = rV[2];
  mEntry[2][0] = rW[0];
  mEntry[2][1] = rW[1];
  mEntry[2][2] = rW[2];
 }
}


template <class Real>
Matrix34<Real>::Matrix34(const Matrix3<Real>& rM, const Vector3<Real>& rV)
{
 mEntry[0][0] = rM[0][0];
 mEntry[0][1] = rM[0][1];
 mEntry[0][2] = rM[0][2];
 mEntry[0][3] = rV[0];
 mEntry[1][0] = rM[1][0];
 mEntry[1][1] = rM[1][1];
 mEntry[1][2] = rM[1][2];
 mEntry[1][3] = rV[1];
 mEntry[2][0] = rM[2][0];
 mEntry[2][1] = rM[2][1];
 mEntry[2][2] = rM[2][2];
 mEntry[2][3] = rV[2];
}


template <class Real>
void Matrix34<Real>::SetMatrix3(const Matrix3<Real>& rM)
{
 mEntry[0][0] = rM[0][0];
 mEntry[0][1] = rM[0][1];
 mEntry[0][2] = rM[0][2];
 mEntry[1][0] = rM[1][0];
 mEntry[1][1] = rM[1][1];
 mEntry[1][2] = rM[1][2];
 mEntry[2][0] = rM[2][0];
 mEntry[2][1] = rM[2][1];
 mEntry[2][2] = rM[2][2];
}


template <class Real>
void Matrix34<Real>::MakeZero()
{
 mEntry[0][0] = static_cast<Real>(0.0);
 mEntry[0][1] = static_cast<Real>(0.0);
 mEntry[0][2] = static_cast<Real>(0.0);
 mEntry[0][3] = static_cast<Real>(0.0);

 mEntry[1][0] = static_cast<Real>(0.0);
 mEntry[1][1] = static_cast<Real>(0.0);
 mEntry[1][2] = static_cast<Real>(0.0);
 mEntry[1][3] = static_cast<Real>(0.0);

 mEntry[2][0] = static_cast<Real>(0.0);
 mEntry[2][1] = static_cast<Real>(0.0);
 mEntry[2][2] = static_cast<Real>(0.0);
 mEntry[2][3] = static_cast<Real>(0.0);
}


template <class Real>
void Matrix34<Real>::MakeIdentity()
{
 ps_guMtxIdentity(mEntry);
}


template <class Real>
void Matrix34<Real>::FromAxisAngle(const Vector3<Real>& rAxis,
 Real angle)
{
 Vector3<Real>* pAxis = const_cast<Vector3<Real>*>(&rAxis);
 ps_guMtxRotAxisRad(mEntry, reinterpret_cast<Vec*>(pAxis), angle);
}


template <class Real>
inline Matrix34<Real>::operator Real4* ()
{
 return mEntry;
}


template <class Real>
inline Matrix34<Real>::operator const Real* () const
{
 return mEntry;
}


template <class Real>
inline const Real* Matrix34<Real>::operator[] (Int row) const
{
 return &mEntry[row][0];
}


template <class Real>
inline Real* Matrix34<Real>::operator[] (Int row)
{
 return &mEntry[row][0];
}


template <class Real>
inline Real Matrix34<Real>::operator() (UInt row, UInt col) const
{
 return mEntry[row][col];
}


template <class Real>
inline Real& Matrix34<Real>::operator() (UInt row, UInt col)
{
 return mEntry[row][col];
}


template <class Real>
void Matrix34<Real>::SetRow(UInt row, const Vector3<Real>& rV)
{
 mEntry[row][0] = rV[0];
 mEntry[row][1] = rV[1];
 mEntry[row][2] = rV[2];
}


template <class Real>
Vector3<Real> Matrix34<Real>::GetRow(UInt row) const
{
 return Vector3<Real>(mEntry[row][0], mEntry[row][1], mEntry[row][1]);
}


template <class Real>
void Matrix34<Real>::SetColumn(UInt col, const Vector3<Real>& rV)
{
 mEntry[0][col] = rV.X();
 mEntry[1][col] = rV.Y();
 mEntry[2][col] = rV.Z();
}


template <class Real>
Vector3<Real> Matrix34<Real>::GetColumn(UInt col) const
{
 return Vector3<Real>(mEntry[0][col], mEntry[1][col], mEntry[2][col]);
}


template <class Real>
inline Matrix34<Real> Matrix34<Real>::operator* (const Matrix34& rMatrix)
const
{
 Matrix34<Real> result;
 ps_guMtxConcat(const_cast<Real4*>(mEntry), const_cast<Matrix34&>(rMatrix),
  result);
 return result;
}


template <class Real>
inline Matrix34<Real> Matrix34<Real>::operator* (Real scalar) const
{
 return Matrix34<Real>(
  scalar * mEntry[0][0], scalar * mEntry[0][1], scalar * mEntry[0][2],
   mEntry[0][3],
  scalar * mEntry[1][0], scalar * mEntry[1][1], scalar * mEntry[1][2],
   mEntry[1][3],
  scalar * mEntry[2][0], scalar * mEntry[2][1], scalar * mEntry[2][2],
   mEntry[2][3]);
}


template <class Real>
inline Vector3<Real> Matrix34<Real>::operator* (const Vector3<Real>& rV) const
{
 Vector3<Real> result;
 Vector3<Real>* pResult = const_cast<Vector3<Real>*>(&result);
 Vector3<Real>* pVector = const_cast<Vector3<Real>*>(&rV);
 ps_guVecMultiplySR(const_cast<Real4*>(mEntry), reinterpret_cast<Vec*>(pVector),
  reinterpret_cast<Vec*>(pResult));
 return result;
}


template <class Real>
Matrix34<Real> Matrix34<Real>::TimesDiagonal(const Vector3<Real>& rDiag) const
{
 return Matrix34<Real>(
  mEntry[0][0]*rDiag[0], mEntry[0][1]*rDiag[1], mEntry[0][2]*rDiag[2],
   mEntry[0][3],
  mEntry[1][0]*rDiag[0], mEntry[1][1]*rDiag[1], mEntry[1][2]*rDiag[2],
   mEntry[1][3],
  mEntry[2][0]*rDiag[0], mEntry[2][1]*rDiag[1], mEntry[2][2]*rDiag[2],
   mEntry[2][3]);
}



template <class Real>
Matrix34<Real> Matrix34<Real>::Inverse() const
{



 Matrix34<Real> inverse;

 inverse.mEntry[0][0] = mEntry[1][1]*mEntry[2][2] -
  mEntry[1][2]*mEntry[2][1];
 inverse.mEntry[0][1] = mEntry[0][2]*mEntry[2][1] -
  mEntry[0][1]*mEntry[2][2];
 inverse.mEntry[0][2] = mEntry[0][1]*mEntry[1][2] -
  mEntry[0][2]*mEntry[1][1];
 inverse.mEntry[1][0] = mEntry[1][2]*mEntry[2][0] -
  mEntry[1][0]*mEntry[2][2];
 inverse.mEntry[1][1] = mEntry[0][0]*mEntry[2][2] -
  mEntry[0][2]*mEntry[2][0];
 inverse.mEntry[1][2] = mEntry[0][2]*mEntry[1][0] -
  mEntry[0][0]*mEntry[1][2];
 inverse.mEntry[2][0] = mEntry[1][0]*mEntry[2][1] -
  mEntry[1][1]*mEntry[2][0];
 inverse.mEntry[2][1] = mEntry[0][1]*mEntry[2][0] -
  mEntry[0][0]*mEntry[2][1];
 inverse.mEntry[2][2] = mEntry[0][0]*mEntry[1][1] -
  mEntry[0][1]*mEntry[1][0];

 Real det =
  mEntry[0][0]*inverse.mEntry[0][0] +
  mEntry[0][1]*inverse.mEntry[1][0] +
  mEntry[0][2]*inverse.mEntry[2][0];

 if (Math<Real>::FAbs(det) <= Math<Real>::ZERO_TOLERANCE)
 {
  return ZERO;
 }

 Real invDet = (static_cast<Real>(1.0)) / det;
 inverse.mEntry[0][0] *= invDet;
 inverse.mEntry[0][1] *= invDet;
 inverse.mEntry[0][2] *= invDet;
 inverse.mEntry[1][0] *= invDet;
 inverse.mEntry[1][1] *= invDet;
 inverse.mEntry[1][2] *= invDet;
 inverse.mEntry[2][0] *= invDet;
 inverse.mEntry[2][1] *= invDet;
 inverse.mEntry[2][2] *= invDet;

 return inverse;
}


template <class Real>
inline Vector3<Real> operator* (const Vector3<Real>& rV,
 const Matrix34<Real>& rM)
{
 return Vector3<Real>(
  rV[0]*rM[0][0] + rV[1]*rM[1][0] + rV[2]*rM[2][0],
  rV[0]*rM[0][1] + rV[1]*rM[1][1] + rV[2]*rM[2][1],
  rV[0]*rM[0][2] + rV[1]*rM[1][2] + rV[2]*rM[2][2]);
}
# 124 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix34.h" 2




typedef Matrix34<Float> Matrix34F;

}
# 15 "/home/pete/code/wire3d/Wire/Engine/WireTransformation.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix4.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix4.h"
       
# 25 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix4.h"
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireVector4.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireVector4.h"
       






namespace Wire
{

template <class Real>
class Vector4
{
public:

 Vector4();
 Vector4(Real x, Real y, Real z, Real w);


 inline operator Real* ();
 inline operator const Real* () const;
 inline Real X() const;
 inline Real& X();
 inline Real Y() const;
 inline Real& Y();
 inline Real Z() const;
 inline Real& Z();
 inline Real W() const;
 inline Real& W();


  inline Vector4& operator= (const Vector4& rVector);


 Bool operator== (const Vector4& rVector) const;
 Bool operator!= (const Vector4& rVector) const;


 inline Vector4 operator+ (const Vector4& rVector) const;
 inline Vector4 operator- (const Vector4& rVector) const;
 inline Vector4 operator* (Real scalar) const;
 inline Vector4 operator/ (Real scalar) const;
 inline Vector4 operator- () const;


 inline Vector4& operator+= (const Vector4& rVector);
 inline Vector4& operator-= (const Vector4& rVector);
 inline Vector4& operator*= (Real scalar);
 inline Vector4& operator/= (Real scalar);


 inline Real Length() const;
 inline Real SquaredLength() const;
 inline Real Dot(const Vector4& rVector) const;
 inline Real Normalize();

 static const Vector4 ZERO;
 static const Vector4 UNIT_X;
 static const Vector4 UNIT_Y;
 static const Vector4 UNIT_Z;
 static const Vector4 UNIT_W;
 static const Vector4 ONE;

private:
 Real mTuple[4];
};


template <class Real>
Vector4<Real> operator* (Real scalar, const Vector4<Real>& rVector);

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireVector4.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireVector4.inl"
template <class Real>
Vector4<Real>::Vector4()
{

}


template <class Real>
Vector4<Real>::Vector4(Real x, Real y, Real z, Real w)
{
 mTuple[0] = x;
 mTuple[1] = y;
 mTuple[2] = z;
 mTuple[3] = w;
}


template <class Real>
inline Vector4<Real>::operator Real* ()
{
 return mTuple;
}


template <class Real>
inline Vector4<Real>::operator const Real* () const
{
 return mTuple;
}


template <class Real>
inline Real Vector4<Real>::X() const
{
 return mTuple[0];
}


template <class Real>
inline Real& Vector4<Real>::X()
{
 return mTuple[0];
}


template <class Real>
inline Real Vector4<Real>::Y() const
{
 return mTuple[1];
}


template <class Real>
inline Real& Vector4<Real>::Y()
{
 return mTuple[1];
}


template <class Real>
inline Real Vector4<Real>::Z() const
{
 return mTuple[2];
}


template <class Real>
inline Real& Vector4<Real>::Z()
{
 return mTuple[2];
}


template <class Real>
inline Real Vector4<Real>::W() const
{
 return mTuple[3];
}


template <class Real>
inline Real& Vector4<Real>::W()
{
 return mTuple[3];
}


template <class Real>
inline Vector4<Real>& Vector4<Real>::operator= (const Vector4& rVector)
{
 mTuple[0] = rVector.mTuple[0];
 mTuple[1] = rVector.mTuple[1];
 mTuple[2] = rVector.mTuple[2];
 mTuple[3] = rVector.mTuple[3];
 return *this;
}


template <class Real>
inline Bool Vector4<Real>::operator== (const Vector4& rVector) const
{
 return (
  mTuple[0] == rVector.mTuple[0] &&
  mTuple[1] == rVector.mTuple[1] &&
  mTuple[2] == rVector.mTuple[2] &&
  mTuple[3] == rVector.mTuple[3]);
}


template <class Real>
inline Bool Vector4<Real>::operator!= (const Vector4& rVector) const
{
 return !(
  mTuple[0] == rVector.mTuple[0] &&
  mTuple[1] == rVector.mTuple[1] &&
  mTuple[2] == rVector.mTuple[2] &&
  mTuple[3] == rVector.mTuple[3]);
}


template <class Real>
inline Vector4<Real> Vector4<Real>::operator+ (const Vector4& rVector) const
{
 return Vector4(
  mTuple[0] + rVector.mTuple[0],
  mTuple[1] + rVector.mTuple[1],
  mTuple[2] + rVector.mTuple[2],
  mTuple[3] + rVector.mTuple[3]);
}


template <class Real>
inline Vector4<Real> Vector4<Real>::operator- (const Vector4& rVector) const
{
 return Vector4(
  mTuple[0] - rVector.mTuple[0],
  mTuple[1] - rVector.mTuple[1],
  mTuple[2] - rVector.mTuple[2],
  mTuple[3] - rVector.mTuple[3]);
}


template <class Real>
inline Vector4<Real> Vector4<Real>::operator* (Real scalar) const
{
 return Vector4(
  scalar * mTuple[0],
  scalar * mTuple[1],
  scalar * mTuple[2],
  scalar * mTuple[3]);
}


template <class Real>
inline Vector4<Real> Vector4<Real>::operator/ (Real scalar) const
{
 Vector4 quot;

 if (scalar != static_cast<Real>(0.0))
 {
  Real invScalar = (static_cast<Real>(1.0)) / scalar;
  quot.mTuple[0] = invScalar * mTuple[0];
  quot.mTuple[1] = invScalar * mTuple[1];
  quot.mTuple[2] = invScalar * mTuple[2];
  quot.mTuple[3] = invScalar * mTuple[3];
 }
 else
 {
  quot.mTuple[0] = Math<Real>::MAX_REAL;
  quot.mTuple[1] = Math<Real>::MAX_REAL;
  quot.mTuple[2] = Math<Real>::MAX_REAL;
  quot.mTuple[3] = Math<Real>::MAX_REAL;
 }

 return quot;
}


template <class Real>
inline Vector4<Real> Vector4<Real>::operator- () const
{
 return Vector4(
  -mTuple[0],
  -mTuple[1],
  -mTuple[2],
  -mTuple[3]);
}


template <class Real>
inline Vector4<Real>& Vector4<Real>::operator+= (const Vector4& rVector)
{
 mTuple[0] += rVector.mTuple[0];
 mTuple[1] += rVector.mTuple[1];
 mTuple[2] += rVector.mTuple[2];
 mTuple[3] += rVector.mTuple[3];
 return *this;
}


template <class Real>
inline Vector4<Real>& Vector4<Real>::operator-= (const Vector4& rVector)
{
 mTuple[0] -= rVector.mTuple[0];
 mTuple[1] -= rVector.mTuple[1];
 mTuple[2] -= rVector.mTuple[2];
 mTuple[3] -= rVector.mTuple[3];
 return *this;
}


template <class Real>
inline Vector4<Real>& Vector4<Real>::operator*= (Real scalar)
{
 mTuple[0] *= scalar;
 mTuple[1] *= scalar;
 mTuple[2] *= scalar;
 mTuple[3] *= scalar;
 return *this;
}


template <class Real>
inline Vector4<Real>& Vector4<Real>::operator/= (Real scalar)
{
 if (scalar != static_cast<Real>(0.0))
 {
  Real invScalar = (static_cast<Real>(1.0)) / scalar;
  mTuple[0] *= invScalar;
  mTuple[1] *= invScalar;
  mTuple[2] *= invScalar;
  mTuple[3] *= invScalar;
 }
 else
 {
  mTuple[0] = Math<Real>::MAX_REAL;
  mTuple[1] = Math<Real>::MAX_REAL;
  mTuple[2] = Math<Real>::MAX_REAL;
  mTuple[3] = Math<Real>::MAX_REAL;
 }

 return *this;
}


template <class Real>
inline Real Vector4<Real>::Length() const
{
 return Math<Real>::Sqrt(
  mTuple[0] * mTuple[0] +
  mTuple[1] * mTuple[1] +
  mTuple[2] * mTuple[2] +
  mTuple[3] * mTuple[3]);
}


template <class Real>
inline Real Vector4<Real>::SquaredLength() const
{
 return
  mTuple[0] * mTuple[0] +
  mTuple[1] * mTuple[1] +
  mTuple[2] * mTuple[2] +
  mTuple[3] * mTuple[3];
}


template <class Real>
inline Real Vector4<Real>::Dot(const Vector4& rVector) const
{
 return
  mTuple[0] * rVector.mTuple[0] +
  mTuple[1] * rVector.mTuple[1] +
  mTuple[2] * rVector.mTuple[2] +
  mTuple[3] * rVector.mTuple[3];
}


template <class Real>
inline Real Vector4<Real>::Normalize()
{
 Real length = Length();

 if (length > Math<Real>::ZERO_TOLERANCE)
 {
  Real invLength = (static_cast<Real>(1.0)) / length;
  mTuple[0] *= invLength;
  mTuple[1] *= invLength;
  mTuple[2] *= invLength;
  mTuple[3] *= invLength;
 }
 else
 {
  length = static_cast<Real>(0.0);
  mTuple[0] = static_cast<Real>(0.0);
  mTuple[1] = static_cast<Real>(0.0);
  mTuple[2] = static_cast<Real>(0.0);
  mTuple[3] = static_cast<Real>(0.0);
 }

 return length;
}


template <class Real>
inline Vector4<Real> operator* (Real scalar, const Vector4<Real>& rVector)
{
 return Vector4<Real>(
  scalar * rVector[0],
  scalar * rVector[1],
  scalar * rVector[2],
  scalar * rVector[3]);
}
# 81 "/home/pete/code/wire3d/Wire/Foundation/WireVector4.h" 2

typedef Vector4<Float> Vector4F;
typedef Vector4<Double> Vector4D;

}
# 26 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix4.h" 2

namespace Wire
{

template <class Real>
class Matrix4
{
public:
 Matrix4();



 Matrix4(Bool zero);


 Matrix4(Real m00, Real m01, Real m02, Real m03,
  Real m10, Real m11, Real m12, Real m13,
  Real m20, Real m21, Real m22, Real m23,
  Real m30, Real m31, Real m32, Real m33);


 Matrix4(const Vector4<Real>& rV0, const Vector4<Real>& rV1,
  const Vector4<Real>& rV2, const Vector4<Real>& rV3, Bool isColumn);

 void MakeZero();
 void MakeIdentity();


 inline operator const Real* () const;
 inline operator Real* ();
 inline const Real* operator[] (Int row) const;
 inline Real* operator[] (Int row);
 inline Real operator() (UInt row, UInt col) const;
 inline Real& operator() (UInt row, UInt col);
 void SetRow(UInt row, const Vector4<Real>& rV);
 Vector4<Real> GetRow(UInt row) const;
 void SetColumn(UInt col, const Vector4<Real>& rV);
 Vector4<Real> GetColumn(UInt col) const;


 inline Matrix4 operator* (const Matrix4& rMatrix) const;
 inline Matrix4 operator* (Real scalar) const;


 inline Vector4<Real> operator* (const Vector4<Real>& rV) const;


 Matrix4 Transpose() const;
 Matrix4 TransposeTimes(const Matrix4& rM) const;
 Matrix4 TimesTranspose(const Matrix4& rM) const;
 Matrix4 Inverse() const;


 static const Matrix4 ZERO;
 static const Matrix4 IDENTITY;

private:
 Real mEntry[16];
};


template <class Real>
inline Matrix4<Real> operator* (Real scalar, const Matrix4<Real>& rM);


template <class Real>
inline Vector4<Real> operator* (const Vector4<Real>& rV,
 const Matrix4<Real>& rM);

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix4.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix4.inl"
template <class Real>
Matrix4<Real>::Matrix4()
{

}


template <class Real>
Matrix4<Real>::Matrix4(Bool zero)
{
 if (zero)
 {
  MakeZero();
 }
 else
 {
  MakeIdentity();
 }
}


template <class Real>
Matrix4<Real>::Matrix4(
 Real m00, Real m01, Real m02, Real m03,
 Real m10, Real m11, Real m12, Real m13,
 Real m20, Real m21, Real m22, Real m23,
 Real m30, Real m31, Real m32, Real m33)
{
 mEntry[ 0] = m00;
 mEntry[ 1] = m01;
 mEntry[ 2] = m02;
 mEntry[ 3] = m03;
 mEntry[ 4] = m10;
 mEntry[ 5] = m11;
 mEntry[ 6] = m12;
 mEntry[ 7] = m13;
 mEntry[ 8] = m20;
 mEntry[ 9] = m21;
 mEntry[10] = m22;
 mEntry[11] = m23;
 mEntry[12] = m30;
 mEntry[13] = m31;
 mEntry[14] = m32;
 mEntry[15] = m33;
}


template <class Real>
Matrix4<Real>::Matrix4(const Vector4<Real>& rV0, const Vector4<Real>& rV1,
 const Vector4<Real>& rV2, const Vector4<Real>& rV3, Bool isColumn)
{
 if (isColumn)
 {
  mEntry[ 0] = rV0[0];
  mEntry[ 1] = rV1[0];
  mEntry[ 2] = rV2[0];
  mEntry[ 3] = rV3[0];
  mEntry[ 4] = rV0[1];
  mEntry[ 5] = rV1[1];
  mEntry[ 6] = rV2[1];
  mEntry[ 7] = rV3[1];
  mEntry[ 8] = rV0[2];
  mEntry[ 9] = rV1[2];
  mEntry[10] = rV2[2];
  mEntry[11] = rV3[2];
  mEntry[12] = rV0[3];
  mEntry[13] = rV1[3];
  mEntry[14] = rV2[3];
  mEntry[15] = rV3[3];
 }
 else
 {
  mEntry[ 0] = rV0[0];
  mEntry[ 1] = rV0[1];
  mEntry[ 2] = rV0[2];
  mEntry[ 3] = rV0[3];
  mEntry[ 4] = rV1[0];
  mEntry[ 5] = rV1[1];
  mEntry[ 6] = rV1[2];
  mEntry[ 7] = rV1[3];
  mEntry[ 8] = rV2[0];
  mEntry[ 9] = rV2[1];
  mEntry[10] = rV2[2];
  mEntry[11] = rV2[3];
  mEntry[12] = rV3[0];
  mEntry[13] = rV3[1];
  mEntry[14] = rV3[2];
  mEntry[15] = rV3[3];
 }
}


template <class Real>
void Matrix4<Real>::MakeZero()
{
 mEntry[ 0] = static_cast<Real>(0.0);
 mEntry[ 1] = static_cast<Real>(0.0);
 mEntry[ 2] = static_cast<Real>(0.0);
 mEntry[ 3] = static_cast<Real>(0.0);
 mEntry[ 4] = static_cast<Real>(0.0);
 mEntry[ 5] = static_cast<Real>(0.0);
 mEntry[ 6] = static_cast<Real>(0.0);
 mEntry[ 7] = static_cast<Real>(0.0);
 mEntry[ 8] = static_cast<Real>(0.0);
 mEntry[ 9] = static_cast<Real>(0.0);
 mEntry[10] = static_cast<Real>(0.0);
 mEntry[11] = static_cast<Real>(0.0);
 mEntry[12] = static_cast<Real>(0.0);
 mEntry[13] = static_cast<Real>(0.0);
 mEntry[14] = static_cast<Real>(0.0);
 mEntry[15] = static_cast<Real>(0.0);
}


template <class Real>
void Matrix4<Real>::MakeIdentity()
{
 mEntry[ 0] = static_cast<Real>(1.0);
 mEntry[ 1] = static_cast<Real>(0.0);
 mEntry[ 2] = static_cast<Real>(0.0);
 mEntry[ 3] = static_cast<Real>(0.0);
 mEntry[ 4] = static_cast<Real>(0.0);
 mEntry[ 5] = static_cast<Real>(1.0);
 mEntry[ 6] = static_cast<Real>(0.0);
 mEntry[ 7] = static_cast<Real>(0.0);
 mEntry[ 8] = static_cast<Real>(0.0);
 mEntry[ 9] = static_cast<Real>(0.0);
 mEntry[10] = static_cast<Real>(1.0);
 mEntry[11] = static_cast<Real>(0.0);
 mEntry[12] = static_cast<Real>(0.0);
 mEntry[13] = static_cast<Real>(0.0);
 mEntry[14] = static_cast<Real>(0.0);
 mEntry[15] = static_cast<Real>(1.0);
}


template <class Real>
inline Matrix4<Real>::operator const Real* () const
{
 return mEntry;
}


template <class Real>
inline Matrix4<Real>::operator Real* ()
{
 return mEntry;
}


template <class Real>
inline const Real* Matrix4<Real>::operator[] (Int row) const
{
 return &mEntry[4 * row];
}


template <class Real>
inline Real* Matrix4<Real>::operator[] (Int row)
{
 return &mEntry[4 * row];
}


template <class Real>
inline Real Matrix4<Real>::operator() (UInt row, UInt col) const
{
 return mEntry[col + 4*row];
}


template <class Real>
inline Real& Matrix4<Real>::operator() (UInt row, UInt col)
{
 return mEntry[col + 4*row];
}


template <class Real>
void Matrix4<Real>::SetRow(UInt row, const Vector4<Real>& rkV)
{
 const UInt offset = 4*row;
 mEntry[offset] = rkV[0];
 mEntry[offset+1] = rkV[1];
 mEntry[offset+2] = rkV[2];
 mEntry[offset+3] = rkV[3];
}


template <class Real>
Vector4<Real> Matrix4<Real>::GetRow(UInt row) const
{
 const UInt offset = 4*row;
 return Vector4<Real>(mEntry[offset], mEntry[offset+1], mEntry[offset+2],
  mEntry[offset+3]);
}


template <class Real>
void Matrix4<Real>::SetColumn(UInt col, const Vector4<Real>& rV)
{
 mEntry[col] = rV[0];
 mEntry[col+4] = rV[1];
 mEntry[col+8] = rV[2];
 mEntry[col+12] = rV[3];
}


template <class Real>
Vector4<Real> Matrix4<Real>::GetColumn(UInt col) const
{
 return Vector4<Real>(mEntry[col], mEntry[col+4] , mEntry[col+8],
  mEntry[col+12]);
}


template <class Real>
inline Matrix4<Real> Matrix4<Real>::operator* (const Matrix4& rM) const
{
 return Matrix4<Real>(
  mEntry[ 0] * rM.mEntry[ 0] +
  mEntry[ 1] * rM.mEntry[ 4] +
  mEntry[ 2] * rM.mEntry[ 8] +
  mEntry[ 3] * rM.mEntry[12],

  mEntry[ 0] * rM.mEntry[ 1] +
  mEntry[ 1] * rM.mEntry[ 5] +
  mEntry[ 2] * rM.mEntry[ 9] +
  mEntry[ 3] * rM.mEntry[13],

  mEntry[ 0] * rM.mEntry[ 2] +
  mEntry[ 1] * rM.mEntry[ 6] +
  mEntry[ 2] * rM.mEntry[10] +
  mEntry[ 3] * rM.mEntry[14],

  mEntry[ 0] * rM.mEntry[ 3] +
  mEntry[ 1] * rM.mEntry[ 7] +
  mEntry[ 2] * rM.mEntry[11] +
  mEntry[ 3] * rM.mEntry[15],

  mEntry[ 4] * rM.mEntry[ 0] +
  mEntry[ 5] * rM.mEntry[ 4] +
  mEntry[ 6] * rM.mEntry[ 8] +
  mEntry[ 7] * rM.mEntry[12],

  mEntry[ 4] * rM.mEntry[ 1] +
  mEntry[ 5] * rM.mEntry[ 5] +
  mEntry[ 6] * rM.mEntry[ 9] +
  mEntry[ 7] * rM.mEntry[13],

  mEntry[ 4] * rM.mEntry[ 2] +
  mEntry[ 5] * rM.mEntry[ 6] +
  mEntry[ 6] * rM.mEntry[10] +
  mEntry[ 7] * rM.mEntry[14],

  mEntry[ 4] * rM.mEntry[ 3] +
  mEntry[ 5] * rM.mEntry[ 7] +
  mEntry[ 6] * rM.mEntry[11] +
  mEntry[ 7] * rM.mEntry[15],

  mEntry[ 8] * rM.mEntry[ 0] +
  mEntry[ 9] * rM.mEntry[ 4] +
  mEntry[10] * rM.mEntry[ 8] +
  mEntry[11] * rM.mEntry[12],

  mEntry[ 8] * rM.mEntry[ 1] +
  mEntry[ 9] * rM.mEntry[ 5] +
  mEntry[10] * rM.mEntry[ 9] +
  mEntry[11] * rM.mEntry[13],

  mEntry[ 8] * rM.mEntry[ 2] +
  mEntry[ 9] * rM.mEntry[ 6] +
  mEntry[10] * rM.mEntry[10] +
  mEntry[11] * rM.mEntry[14],

  mEntry[ 8] * rM.mEntry[ 3] +
  mEntry[ 9] * rM.mEntry[ 7] +
  mEntry[10] * rM.mEntry[11] +
  mEntry[11] * rM.mEntry[15],

  mEntry[12] * rM.mEntry[ 0] +
  mEntry[13] * rM.mEntry[ 4] +
  mEntry[14] * rM.mEntry[ 8] +
  mEntry[15] * rM.mEntry[12],

  mEntry[12] * rM.mEntry[ 1] +
  mEntry[13] * rM.mEntry[ 5] +
  mEntry[14] * rM.mEntry[ 9] +
  mEntry[15] * rM.mEntry[13],

  mEntry[12] * rM.mEntry[ 2] +
  mEntry[13] * rM.mEntry[ 6] +
  mEntry[14] * rM.mEntry[10] +
  mEntry[15] * rM.mEntry[14],

  mEntry[12] * rM.mEntry[ 3] +
  mEntry[13] * rM.mEntry[ 7] +
  mEntry[14] * rM.mEntry[11] +
  mEntry[15] * rM.mEntry[15]);
}


template <class Real>
inline Matrix4<Real> Matrix4<Real>::operator* (Real scalar) const
{
 return Matrix4<Real>(
  scalar * mEntry[ 0],
  scalar * mEntry[ 1],
  scalar * mEntry[ 2],
  scalar * mEntry[ 3],
  scalar * mEntry[ 4],
  scalar * mEntry[ 5],
  scalar * mEntry[ 6],
  scalar * mEntry[ 7],
  scalar * mEntry[ 8],
  scalar * mEntry[ 9],
  scalar * mEntry[10],
  scalar * mEntry[11],
  scalar * mEntry[12],
  scalar * mEntry[13],
  scalar * mEntry[14],
  scalar * mEntry[15]);
}


template <class Real>
inline Vector4<Real> Matrix4<Real>::operator* (const Vector4<Real>& rV) const
{
 return Vector4<Real>(
  mEntry[ 0] * rV[0] +
  mEntry[ 1] * rV[1] +
  mEntry[ 2] * rV[2] +
  mEntry[ 3] * rV[3],

  mEntry[ 4] * rV[0] +
  mEntry[ 5] * rV[1] +
  mEntry[ 6] * rV[2] +
  mEntry[ 7] * rV[3],

  mEntry[ 8] * rV[0] +
  mEntry[ 9] * rV[1] +
  mEntry[10] * rV[2] +
  mEntry[11] * rV[3],

  mEntry[12] * rV[0] +
  mEntry[13] * rV[1] +
  mEntry[14] * rV[2] +
  mEntry[15] * rV[3]);
}


template <class Real>
Matrix4<Real> Matrix4<Real>::Transpose() const
{
 return Matrix4<Real>(
  mEntry[ 0],
  mEntry[ 4],
  mEntry[ 8],
  mEntry[12],
  mEntry[ 1],
  mEntry[ 5],
  mEntry[ 9],
  mEntry[13],
  mEntry[ 2],
  mEntry[ 6],
  mEntry[10],
  mEntry[14],
  mEntry[ 3],
  mEntry[ 7],
  mEntry[11],
  mEntry[15]);
}


template <class Real>
Matrix4<Real> Matrix4<Real>::TransposeTimes(const Matrix4& rM) const
{

 return Matrix4<Real>(
  mEntry[ 0] * rM.mEntry[ 0] +
  mEntry[ 4] * rM.mEntry[ 4] +
  mEntry[ 8] * rM.mEntry[ 8] +
  mEntry[12] * rM.mEntry[12],

  mEntry[ 0] * rM.mEntry[ 1] +
  mEntry[ 4] * rM.mEntry[ 5] +
  mEntry[ 8] * rM.mEntry[ 9] +
  mEntry[12] * rM.mEntry[13],

  mEntry[ 0] * rM.mEntry[ 2] +
  mEntry[ 4] * rM.mEntry[ 6] +
  mEntry[ 8] * rM.mEntry[10] +
  mEntry[12] * rM.mEntry[14],

  mEntry[ 0] * rM.mEntry[ 3] +
  mEntry[ 4] * rM.mEntry[ 7] +
  mEntry[ 8] * rM.mEntry[11] +
  mEntry[12] * rM.mEntry[15],

  mEntry[ 1] * rM.mEntry[ 0] +
  mEntry[ 5] * rM.mEntry[ 4] +
  mEntry[ 9] * rM.mEntry[ 8] +
  mEntry[13] * rM.mEntry[12],

  mEntry[ 1] * rM.mEntry[ 1] +
  mEntry[ 5] * rM.mEntry[ 5] +
  mEntry[ 9] * rM.mEntry[ 9] +
  mEntry[13] * rM.mEntry[13],

  mEntry[ 1] * rM.mEntry[ 2] +
  mEntry[ 5] * rM.mEntry[ 6] +
  mEntry[ 9] * rM.mEntry[10] +
  mEntry[13] * rM.mEntry[14],

  mEntry[ 1] * rM.mEntry[ 3] +
  mEntry[ 5] * rM.mEntry[ 7] +
  mEntry[ 9] * rM.mEntry[11] +
  mEntry[13] * rM.mEntry[15],

  mEntry[ 2] * rM.mEntry[ 0] +
  mEntry[ 6] * rM.mEntry[ 4] +
  mEntry[10] * rM.mEntry[ 8] +
  mEntry[14] * rM.mEntry[12],

  mEntry[ 2] * rM.mEntry[ 1] +
  mEntry[ 6] * rM.mEntry[ 5] +
  mEntry[10] * rM.mEntry[ 9] +
  mEntry[14] * rM.mEntry[13],

  mEntry[ 2] * rM.mEntry[ 2] +
  mEntry[ 6] * rM.mEntry[ 6] +
  mEntry[10] * rM.mEntry[10] +
  mEntry[14] * rM.mEntry[14],

  mEntry[ 2] * rM.mEntry[ 3] +
  mEntry[ 6] * rM.mEntry[ 7] +
  mEntry[10] * rM.mEntry[11] +
  mEntry[14] * rM.mEntry[15],

  mEntry[ 3] * rM.mEntry[ 0] +
  mEntry[ 7] * rM.mEntry[ 4] +
  mEntry[11] * rM.mEntry[ 8] +
  mEntry[15] * rM.mEntry[12],

  mEntry[ 3] * rM.mEntry[ 1] +
  mEntry[ 7] * rM.mEntry[ 5] +
  mEntry[11] * rM.mEntry[ 9] +
  mEntry[15] * rM.mEntry[13],

  mEntry[ 3] * rM.mEntry[ 2] +
  mEntry[ 7] * rM.mEntry[ 6] +
  mEntry[11] * rM.mEntry[10] +
  mEntry[15] * rM.mEntry[14],

  mEntry[ 3] * rM.mEntry[ 3] +
  mEntry[ 7] * rM.mEntry[ 7] +
  mEntry[11] * rM.mEntry[11] +
  mEntry[15] * rM.mEntry[15]);
}


template <class Real>
Matrix4<Real> Matrix4<Real>::TimesTranspose(const Matrix4& rM) const
{

 return Matrix4<Real>(
  mEntry[ 0] * rM.mEntry[ 0] +
  mEntry[ 1] * rM.mEntry[ 1] +
  mEntry[ 2] * rM.mEntry[ 2] +
  mEntry[ 3] * rM.mEntry[ 3],

  mEntry[ 0] * rM.mEntry[ 4] +
  mEntry[ 1] * rM.mEntry[ 5] +
  mEntry[ 2] * rM.mEntry[ 6] +
  mEntry[ 3] * rM.mEntry[ 7],

  mEntry[ 0] * rM.mEntry[ 8] +
  mEntry[ 1] * rM.mEntry[ 9] +
  mEntry[ 2] * rM.mEntry[10] +
  mEntry[ 3] * rM.mEntry[11],

  mEntry[ 0] * rM.mEntry[12] +
  mEntry[ 1] * rM.mEntry[13] +
  mEntry[ 2] * rM.mEntry[14] +
  mEntry[ 3] * rM.mEntry[15],

  mEntry[ 4] * rM.mEntry[ 0] +
  mEntry[ 5] * rM.mEntry[ 1] +
  mEntry[ 6] * rM.mEntry[ 2] +
  mEntry[ 7] * rM.mEntry[ 3],

  mEntry[ 4] * rM.mEntry[ 4] +
  mEntry[ 5] * rM.mEntry[ 5] +
  mEntry[ 6] * rM.mEntry[ 6] +
  mEntry[ 7] * rM.mEntry[ 7],

  mEntry[ 4] * rM.mEntry[ 8] +
  mEntry[ 5] * rM.mEntry[ 9] +
  mEntry[ 6] * rM.mEntry[10] +
  mEntry[ 7] * rM.mEntry[11],

  mEntry[ 4] * rM.mEntry[12] +
  mEntry[ 5] * rM.mEntry[13] +
  mEntry[ 6] * rM.mEntry[14] +
  mEntry[ 7] * rM.mEntry[15],

  mEntry[ 8] * rM.mEntry[ 0] +
  mEntry[ 9] * rM.mEntry[ 1] +
  mEntry[10] * rM.mEntry[ 2] +
  mEntry[11] * rM.mEntry[ 3],

  mEntry[ 8] * rM.mEntry[ 4] +
  mEntry[ 9] * rM.mEntry[ 5] +
  mEntry[10] * rM.mEntry[ 6] +
  mEntry[11] * rM.mEntry[ 7],

  mEntry[ 8] * rM.mEntry[ 8] +
  mEntry[ 9] * rM.mEntry[ 9] +
  mEntry[10] * rM.mEntry[10] +
  mEntry[11] * rM.mEntry[11],

  mEntry[ 8] * rM.mEntry[12] +
  mEntry[ 9] * rM.mEntry[13] +
  mEntry[10] * rM.mEntry[14] +
  mEntry[11] * rM.mEntry[15],

  mEntry[12] * rM.mEntry[ 0] +
  mEntry[13] * rM.mEntry[ 1] +
  mEntry[14] * rM.mEntry[ 2] +
  mEntry[15] * rM.mEntry[ 3],

  mEntry[12] * rM.mEntry[ 4] +
  mEntry[13] * rM.mEntry[ 5] +
  mEntry[14] * rM.mEntry[ 6] +
  mEntry[15] * rM.mEntry[ 7],

  mEntry[12] * rM.mEntry[ 8] +
  mEntry[13] * rM.mEntry[ 9] +
  mEntry[14] * rM.mEntry[10] +
  mEntry[15] * rM.mEntry[11],

  mEntry[12] * rM.mEntry[12] +
  mEntry[13] * rM.mEntry[13] +
  mEntry[14] * rM.mEntry[14] +
  mEntry[15] * rM.mEntry[15]);
}


template <class Real>
Matrix4<Real> Matrix4<Real>::Inverse () const
{
 Real a0 = mEntry[ 0] * mEntry[ 5] - mEntry[ 1] * mEntry[ 4];
 Real a1 = mEntry[ 0] * mEntry[ 6] - mEntry[ 2] * mEntry[ 4];
 Real a2 = mEntry[ 0] * mEntry[ 7] - mEntry[ 3] * mEntry[ 4];
 Real a3 = mEntry[ 1] * mEntry[ 6] - mEntry[ 2] * mEntry[ 5];
 Real a4 = mEntry[ 1] * mEntry[ 7] - mEntry[ 3] * mEntry[ 5];
 Real a5 = mEntry[ 2] * mEntry[ 7] - mEntry[ 3] * mEntry[ 6];
 Real b0 = mEntry[ 8] * mEntry[13] - mEntry[ 9] * mEntry[12];
 Real b1 = mEntry[ 8] * mEntry[14] - mEntry[10] * mEntry[12];
 Real b2 = mEntry[ 8] * mEntry[15] - mEntry[11] * mEntry[12];
 Real b3 = mEntry[ 9] * mEntry[14] - mEntry[10] * mEntry[13];
 Real b4 = mEntry[ 9] * mEntry[15] - mEntry[11] * mEntry[13];
 Real b5 = mEntry[10] * mEntry[15] - mEntry[11] * mEntry[14];

 Real det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;
 if (Math<Real>::FAbs(det) <= Math<Real>::ZERO_TOLERANCE)
 {
  return Matrix4<Real>::ZERO;
 }

 Matrix4 inv;
 inv.mEntry[ 0] = + mEntry[ 5] * b5 - mEntry[ 6] * b4 + mEntry[ 7] * b3;
 inv.mEntry[ 4] = - mEntry[ 4] * b5 + mEntry[ 6] * b2 - mEntry[ 7] * b1;
 inv.mEntry[ 8] = + mEntry[ 4] * b4 - mEntry[ 5] * b2 + mEntry[ 7] * b0;
 inv.mEntry[12] = - mEntry[ 4] * b3 + mEntry[ 5] * b1 - mEntry[ 6] * b0;
 inv.mEntry[ 1] = - mEntry[ 1] * b5 + mEntry[ 2] * b4 - mEntry[ 3] * b3;
 inv.mEntry[ 5] = + mEntry[ 0] * b5 - mEntry[ 2] * b2 + mEntry[ 3] * b1;
 inv.mEntry[ 9] = - mEntry[ 0] * b4 + mEntry[ 1] * b2 - mEntry[ 3] * b0;
 inv.mEntry[13] = + mEntry[ 0] * b3 - mEntry[ 1] * b1 + mEntry[ 2] * b0;
 inv.mEntry[ 2] = + mEntry[13] * a5 - mEntry[14] * a4 + mEntry[15] * a3;
 inv.mEntry[ 6] = - mEntry[12] * a5 + mEntry[14] * a2 - mEntry[15] * a1;
 inv.mEntry[10] = + mEntry[12] * a4 - mEntry[13] * a2 + mEntry[15] * a0;
 inv.mEntry[14] = - mEntry[12] * a3 + mEntry[13] * a1 - mEntry[14] * a0;
 inv.mEntry[ 3] = - mEntry[ 9] * a5 + mEntry[10] * a4 - mEntry[11] * a3;
 inv.mEntry[ 7] = + mEntry[ 8] * a5 - mEntry[10] * a2 + mEntry[11] * a1;
 inv.mEntry[11] = - mEntry[ 8] * a4 + mEntry[ 9] * a2 - mEntry[11] * a0;
 inv.mEntry[15] = + mEntry[ 8] * a3 - mEntry[ 9] * a1 + mEntry[10] * a0;

 Real invDet = static_cast<Real>(1.0) / det;
 inv.mEntry[ 0] *= invDet;
 inv.mEntry[ 1] *= invDet;
 inv.mEntry[ 2] *= invDet;
 inv.mEntry[ 3] *= invDet;
 inv.mEntry[ 4] *= invDet;
 inv.mEntry[ 5] *= invDet;
 inv.mEntry[ 6] *= invDet;
 inv.mEntry[ 7] *= invDet;
 inv.mEntry[ 8] *= invDet;
 inv.mEntry[ 9] *= invDet;
 inv.mEntry[10] *= invDet;
 inv.mEntry[11] *= invDet;
 inv.mEntry[12] *= invDet;
 inv.mEntry[13] *= invDet;
 inv.mEntry[14] *= invDet;
 inv.mEntry[15] *= invDet;

 return inv;
}


template <class Real>
inline Matrix4<Real> operator* (Real scalar, const Matrix4<Real>& rM)
{
 return rM * scalar;
}


template <class Real>
inline Vector4<Real> operator* (const Vector4<Real>& rV,
 const Matrix4<Real>& rM)
{
 return Vector4<Real>(
  rV[0]*rM[0][0] + rV[1]*rM[1][0] + rV[2]*rM[2][0] + rV[3]*rM[3][0],
  rV[0]*rM[0][1] + rV[1]*rM[1][1] + rV[2]*rM[2][1] + rV[3]*rM[3][1],
  rV[0]*rM[0][2] + rV[1]*rM[1][2] + rV[2]*rM[2][2] + rV[3]*rM[3][2],
  rV[0]*rM[0][3] + rV[1]*rM[1][3] + rV[2]*rM[2][3] + rV[3]*rM[3][3]);
}
# 96 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix4.h" 2

typedef Matrix4<Float> Matrix4F;
typedef Matrix4<Double> Matrix4D;

}
# 16 "/home/pete/code/wire3d/Wire/Engine/WireTransformation.h" 2


namespace Wire
{

class Transformation
{
public:
 Transformation();
  ~Transformation();



 inline Bool IsIdentity() const;
 inline Bool IsRSMatrix() const;
 inline Bool IsUniformScale() const;

 inline operator Matrix34F ();
  inline operator const Matrix34F () const;

 void SetRotate(const Matrix3F& rMatrix);
 Matrix3F GetRotate() const;
 void SetRotate(const Matrix34F& rMatrix);
 void SetMatrix(const Matrix34F& rMatrix);
 inline const Matrix34F& GetMatrix() const;
 void SetTranslate(const Vector3F& rTranslate);
 inline Vector3F GetTranslate() const;
 void SetScale(const Vector3F& rScale);
 inline const Vector3F& GetScale() const;
 void SetUniformScale(Float scale);
 inline Float GetUniformScale() const;


 void GetTransformation(Matrix34F& rMatrix) const;



 void GetHomogeneous(Matrix4F& rHMatrix) const;




 Float GetNorm() const;


 Vector3F ApplyForward(const Vector3F& rInput) const;


 void Product(const Transformation& rA, const Transformation& kB);



    Vector3F ApplyInverse(const Vector3F& rInput) const;

private:
 Matrix34F mMatrix;
 Vector3F mScale;

 Bool mIsIdentity;
 Bool mIsRSMatrix;
 Bool mIsUniformScale;
};

# 1 "/home/pete/code/wire3d/Wire/Engine/WireTransformation.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireTransformation.inl"
inline Bool Transformation::IsIdentity() const
{
 return mIsIdentity;
}

inline Bool Transformation::IsRSMatrix() const
{
 return mIsRSMatrix;
}

inline Bool Transformation::IsUniformScale() const
{
 return mIsRSMatrix && mIsUniformScale;
}


inline Transformation::operator Matrix34F ()
{
 Matrix34F transformation;
 GetTransformation(transformation);
 return transformation;
}


inline Transformation::operator const Matrix34F () const
{
 Matrix34F transformation;
 GetTransformation(transformation);
 return transformation;
}


inline const Matrix34F& Transformation::GetMatrix() const
{
 return mMatrix;
}


inline Vector3F Transformation::GetTranslate() const
{
 return mMatrix.GetColumn(3);
}


inline const Vector3F& Transformation::GetScale() const
{
 ;
 return mScale;
}


inline Float Transformation::GetUniformScale() const
{
 ;
 return mScale.X();
}
# 80 "/home/pete/code/wire3d/Wire/Engine/WireTransformation.h" 2

}
# 16 "/home/pete/code/wire3d/Wire/Engine/WireBoundingVolume.h" 2

# 1 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.h"
       



# 1 "/home/pete/code/wire3d/Wire/Engine/WireBuffer.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireBuffer.h"
       





namespace Wire
{

class Buffer : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:


 enum UsageType
 {
  UT_STATIC,
  UT_DYNAMIC,
  UT_DYNAMIC_WRITE_ONLY,
  UT_QUANTITY
 };


 enum LockingMode
 {
  LM_READ_ONLY,
  LM_WRITE_ONLY,
  LM_READ_WRITE,
  LM_QUANTITY
 };

 inline UsageType GetUsage() const;

protected:
 Buffer(UsageType mUsage);
 virtual ~Buffer();

protected:
 UsageType mUsage;
};

typedef Pointer<Buffer> BufferPtr;

# 1 "/home/pete/code/wire3d/Wire/Engine/WireBuffer.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireBuffer.inl"
inline Buffer::UsageType Buffer::GetUsage() const
{
 return mUsage;
}
# 55 "/home/pete/code/wire3d/Wire/Engine/WireBuffer.h" 2

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGB.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGB.h"
       





namespace Wire
{

class ColorRGB
{
public:
 ColorRGB();
 ColorRGB(Float red, Float green, Float blue);

 inline Float R() const;
 inline Float& R();
 inline Float G() const;
 inline Float& G();
 inline Float B() const;
 inline Float& B();


 ColorRGB operator* (Float scalar) const;
 friend ColorRGB operator* (Float scalar, const ColorRGB& rCol);


 ColorRGB& operator*= (Float scalar);

 static const ColorRGB BLACK;
 static const ColorRGB WHITE;
 static const ColorRGB RED;
 static const ColorRGB GREEN;
 static const ColorRGB BLUE;

private:
 Float mTuple[3];
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGB.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGB.inl"
inline Float ColorRGB::R() const
{
 return mTuple[0];
}


inline Float& ColorRGB::R()
{
 return mTuple[0];
}


inline Float ColorRGB::G() const
{
 return mTuple[1];
}


inline Float& ColorRGB::G()
{
 return mTuple[1];
}


inline Float ColorRGB::B() const
{
 return mTuple[2];
}


inline Float& ColorRGB::B()
{
 return mTuple[2];
}
# 49 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGB.h" 2

}
# 15 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGBA.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGBA.h"
       





namespace Wire
{

class ColorRGBA
{
public:
 ColorRGBA();
 ColorRGBA(Float red, Float green, Float blue, Float alpha);

 inline Float R() const;
 inline Float& R();
 inline Float G() const;
 inline Float& G();
 inline Float B() const;
 inline Float& B();
 inline Float A() const;
 inline Float& A();


 ColorRGBA operator* (Float scalar) const;
 friend ColorRGBA operator* (Float scalar, const ColorRGBA& rCol);


 ColorRGBA& operator*= (Float scalar);

 static const ColorRGBA BLACK;
 static const ColorRGBA WHITE;
 static const ColorRGBA RED;
 static const ColorRGBA GREEN;
 static const ColorRGBA BLUE;

private:
 Float mTuple[4];
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGBA.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGBA.inl"
inline Float ColorRGBA::R() const
{
 return mTuple[0];
}


inline Float& ColorRGBA::R()
{
 return mTuple[0];
}


inline Float ColorRGBA::G() const
{
 return mTuple[1];
}


inline Float& ColorRGBA::G()
{
 return mTuple[1];
}


inline Float ColorRGBA::B() const
{
 return mTuple[2];
}


inline Float& ColorRGBA::B()
{
 return mTuple[2];
}


inline Float ColorRGBA::A() const
{
 return mTuple[3];
}


inline Float& ColorRGBA::A()
{
 return mTuple[3];
}
# 51 "/home/pete/code/wire3d/Wire/Foundation/WireColorRGBA.h" 2

}
# 16 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireVector2.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireVector2.h"
       






namespace Wire
{

template <class Real>
class Vector2
{
public:

 Vector2();
 Vector2(Real x, Real y);


 inline operator Real* ();
 inline operator const Real* () const;
 inline Real X() const;
 inline Real& X();
 inline Real Y() const;
 inline Real& Y();


 inline Vector2& operator= (const Vector2& rVector);


 inline Bool operator== (const Vector2& rVector) const;
 inline Bool operator!= (const Vector2& rVector) const;


 inline Vector2 operator+ (const Vector2& rVector) const;
 inline Vector2 operator- (const Vector2& rVector) const;
 inline Vector2 operator* (Real scalar) const;
 inline Vector2 operator/ (Real scalar) const;
 inline Vector2 operator- () const;


 inline Vector2& operator+= (const Vector2& rVector);
 inline Vector2& operator-= (const Vector2& rVector);
 inline Vector2& operator*= (Real scalar);
 inline Vector2& operator/= (Real scalar);


 inline Real Length() const;
 inline Real SquaredLength() const;
 inline Real Dot(const Vector2& rVector) const;
 inline Real Normalize();




 static void Orthonormalize(Vector2& rU, Vector2& rV);

 static const Vector2 ZERO;
 static const Vector2 UNIT_X;
 static const Vector2 UNIT_Y;
 static const Vector2 ONE;

private:
 Real mTuple[2];
};


template <class Real>
Vector2<Real> operator* (Real scalar, const Vector2<Real>& rVector);

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireVector2.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireVector2.inl"
template <class Real>
Vector2<Real>::Vector2()
{

}


template <class Real>
Vector2<Real>::Vector2(Real x, Real y)
{
 mTuple[0] = x;
 mTuple[1] = y;
}


template <class Real>
inline Vector2<Real>::operator Real* ()
{
 return mTuple;
}


template <class Real>
inline Vector2<Real>::operator const Real* () const
{
 return mTuple;
}


template <class Real>
inline Real Vector2<Real>::X() const
{
 return mTuple[0];
}


template <class Real>
inline Real& Vector2<Real>::X()
{
 return mTuple[0];
}


template <class Real>
inline Real Vector2<Real>::Y() const
{
 return mTuple[1];
}


template <class Real>
inline Real& Vector2<Real>::Y()
{
 return mTuple[1];
}


template <class Real>
inline Vector2<Real>& Vector2<Real>::operator= (const Vector2& rVector)
{
 mTuple[0] = rVector.mTuple[0];
 mTuple[1] = rVector.mTuple[1];
 return *this;
}


template <class Real>
inline Bool Vector2<Real>::operator== (const Vector2& rVector) const
{
 return (
  mTuple[0] == rVector.mTuple[0] &&
  mTuple[1] == rVector.mTuple[1]);
}


template <class Real>
inline Bool Vector2<Real>::operator!= (const Vector2& rVector) const
{
 return !(
  mTuple[0] == rVector.mTuple[0] &&
  mTuple[1] == rVector.mTuple[1]);

}


template <class Real>
inline Vector2<Real> Vector2<Real>::operator+ (const Vector2& rVector) const
{
 return Vector2(
  mTuple[0] + rVector.mTuple[0],
  mTuple[1] + rVector.mTuple[1]);
}


template <class Real>
inline Vector2<Real> Vector2<Real>::operator- (const Vector2& rVector) const
{
 return Vector2(
  mTuple[0] - rVector.mTuple[0],
  mTuple[1] - rVector.mTuple[1]);
}


template <class Real>
inline Vector2<Real> Vector2<Real>::operator* (Real scalar) const
{
 return Vector2(
  scalar * mTuple[0],
  scalar * mTuple[1]);
}


template <class Real>
inline Vector2<Real> Vector2<Real>::operator/ (Real scalar) const
{
 Vector2 quot;

 if (scalar != static_cast<Real>(0.0))
 {
  Real invScalar = (static_cast<Real>(1.0)) / scalar;
  quot.mTuple[0] = invScalar * mTuple[0];
  quot.mTuple[1] = invScalar * mTuple[1];
 }
 else
 {
  quot.mTuple[0] = Math<Real>::MAX_REAL;
  quot.mTuple[1] = Math<Real>::MAX_REAL;
 }

 return quot;
}


template <class Real>
inline Vector2<Real> Vector2<Real>::operator- () const
{
 return Vector2(
  -mTuple[0],
  -mTuple[1]);
}


template <class Real>
inline Vector2<Real>& Vector2<Real>::operator+= (const Vector2& rVector)
{
 mTuple[0] += rVector.mTuple[0];
 mTuple[1] += rVector.mTuple[1];
 return *this;
}


template <class Real>
inline Vector2<Real>& Vector2<Real>::operator-= (const Vector2& rVector)
{
 mTuple[0] -= rVector.mTuple[0];
 mTuple[1] -= rVector.mTuple[1];
 return *this;
}


template <class Real>
inline Vector2<Real>& Vector2<Real>::operator*= (Real scalar)
{
 mTuple[0] *= scalar;
 mTuple[1] *= scalar;
 return *this;
}


template <class Real>
inline Vector2<Real>& Vector2<Real>::operator/= (Real scalar)
{
 if (scalar != static_cast<Real>(0.0))
 {
  Real invScalar = (static_cast<Real>(1.0)) / scalar;
  mTuple[0] *= invScalar;
  mTuple[1] *= invScalar;
 }
 else
 {
  mTuple[0] = Math<Real>::MAX_REAL;
  mTuple[1] = Math<Real>::MAX_REAL;
 }

 return *this;
}


template <class Real>
inline Real Vector2<Real>::Length() const
{
 return Math<Real>::Sqrt(
  mTuple[0] * mTuple[0] +
  mTuple[1] * mTuple[1]);
}


template <class Real>
inline Real Vector2<Real>::SquaredLength() const
{
 return
  mTuple[0] * mTuple[0] +
  mTuple[1] * mTuple[1];
}


template <class Real>
inline Real Vector2<Real>::Dot(const Vector2& rVector) const
{
 return
  mTuple[0] * rVector.mTuple[0] +
  mTuple[1] * rVector.mTuple[1];
}


template <class Real>
inline Real Vector2<Real>::Normalize()
{
 Real length = Length();

 if (length > Math<Real>::ZERO_TOLERANCE)
 {
  Real invLength = (static_cast<Real>(1.0)) / length;
  mTuple[0] *= invLength;
  mTuple[1] *= invLength;
 }
 else
 {
  length = static_cast<Real>(0.0);
  mTuple[0] = static_cast<Real>(0.0);
  mTuple[1] = static_cast<Real>(0.0);
 }

 return length;
}


template <class Real>
void Vector2<Real>::Orthonormalize(Vector2& rU, Vector2& rV)
{
# 260 "/home/pete/code/wire3d/Wire/Foundation/WireVector2.inl"
 rU.Normalize();


 Real dot0 = rU.Dot(rV);
 rV -= rU * dot0;
 rV.Normalize();
}


template <class Real>
inline Vector2<Real> operator* (Real scalar, const Vector2<Real>& rVector)
{
 return Vector2<Real>(
  scalar * rVector[0],
  scalar * rVector[1]);
}
# 80 "/home/pete/code/wire3d/Wire/Foundation/WireVector2.h" 2

typedef Vector2<Float> Vector2F;
typedef Vector2<Double> Vector2D;

}
# 17 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.h" 2

# 1 "/home/pete/code/wire3d/Wire/Engine/WireVertexAttributes.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireVertexAttributes.h"
       



# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTArray.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireTArray.h"
       





namespace Wire
{

template <class T>
class TArray
{
public:

 TArray(UInt quantity = 0, UInt growBy = 1);
 TArray(const TArray& rObject);
 ~TArray();


 TArray& operator= (const TArray& rObject);


 inline UInt GetQuantity() const;
 inline T* GetArray();
 inline const T* GetArray() const;
 inline T& operator[] (UInt i);
 inline const T& operator[] (UInt i) const;


 void Append(const T& rElement);
 void Insert(UInt i, const T& rElement);
 void SetElement(UInt i, const T& rElement);
# 50 "/home/pete/code/wire3d/Wire/Foundation/WireTArray.h"
 Bool Remove(const T& rElement);


 void RemoveAt(UInt i);


 void RemoveLast();


 void RemoveAll();


 void SetMaxQuantity(UInt newMaxQuantity, Bool copy = true);
 inline UInt GetMaxQuantity() const;
 inline void SetGrowBy(UInt growBy);
 inline UInt GetGrowBy() const;


 void SetQuantity(UInt newQuantity, Bool copy = true);

private:
 UInt mQuantity;
 UInt mMaxQuantity;
 UInt mGrowBy;
 T* mpArray;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTArray.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireTArray.inl"
template <class T>
TArray<T>::TArray(UInt quantity, UInt growBy)
{
 mQuantity = 0;
 mMaxQuantity = quantity;
 mGrowBy = growBy;
 mpArray = (mMaxQuantity > 0 ? new T[mMaxQuantity] : __null);
}


template <class T>
TArray<T>::TArray(const TArray& rObject)
{
 mpArray = __null;
 *this = rObject;
}


template <class T>
TArray<T>::~TArray()
{
 delete[] mpArray;
}


template <class T>
TArray<T>& TArray<T>::operator= (const TArray& rObject)
{
 mQuantity = rObject.mQuantity;
 mMaxQuantity = rObject.mMaxQuantity;
 mGrowBy = rObject.mGrowBy;

 delete[] mpArray;

 if (mMaxQuantity > 0)
 {
  mpArray = new T[mMaxQuantity];
  for (UInt i = 0; i < mMaxQuantity; i++)
  {
   mpArray[i] = rObject.mpArray[i];
  }
 }
 else
 {
  mpArray = __null;
 }

 return *this;
}


template <class T>
inline UInt TArray<T>::GetQuantity() const
{
 return mQuantity;
}


template <class T>
inline T* TArray<T>::GetArray()
{
 return mpArray;
}


template <class T>
inline const T* TArray<T>::GetArray() const
{
 return mpArray;
}


template <class T>
inline T& TArray<T>::operator[] (UInt i)
{
 ;
 if (i >= mQuantity)
 {
  i = mQuantity-1;
 }

 return mpArray[i];
}


template <class T>
inline const T& TArray<T>::operator[] (UInt i) const
{
 ;
 if (i >= mQuantity)
 {
  i = mQuantity-1;
 }

 return mpArray[i];
}


template <class T>
void TArray<T>::RemoveAt(UInt i)
{
 ;
 if (i >= mQuantity)
 {
  return;
 }

 for (UInt j = i+1; j < mQuantity; i = j++)
 {
  mpArray[i] = mpArray[j];
 }

 mpArray[mQuantity-1] = T();
 mQuantity--;
}


template <class T>
Bool TArray<T>::Remove(const T& rElement)
{
 for (UInt i = 0; i < mQuantity; i++)
 {
  if (mpArray[i] == rElement)
  {
   RemoveAt(i);
   return true;
  }
 }

 return false;
}


template <class T>
void TArray<T>::RemoveLast()
{
 RemoveAt(mQuantity-1);
}


template <class T>
void TArray<T>::RemoveAll()
{
 for (UInt i = 0; i < mQuantity; i++)
 {
  mpArray[i] = T();
 }

 mQuantity = 0;
}


template <class T>
void TArray<T>::SetMaxQuantity(UInt newMaxQuantity, Bool copy)
{
 if (newMaxQuantity == 0)
 {
  delete[] mpArray;
  mpArray = __null;
  mQuantity = 0;
  mMaxQuantity = 0;
  return;
 }

 if (newMaxQuantity != mMaxQuantity)
 {
  T* pNewArray = new T[newMaxQuantity];

  if (copy)
  {
   UInt copyQuantity;
   if (newMaxQuantity > mMaxQuantity)
   {
    copyQuantity = mMaxQuantity;
   }
   else
   {
    copyQuantity = newMaxQuantity;
   }

   for (UInt i = 0; i < copyQuantity; i++)
   {
    pNewArray[i] = mpArray[i];
   }

   if (mQuantity > newMaxQuantity)
   {
    mQuantity = newMaxQuantity;
   }
  }
  else
  {
   mQuantity = 0;
  }

  delete[] mpArray;
  mpArray = pNewArray;
  mMaxQuantity = newMaxQuantity;
 }
}


template <class T>
inline UInt TArray<T>::GetMaxQuantity() const
{
 return mMaxQuantity;
}


template <class T>
inline void TArray<T>::SetGrowBy(UInt growBy)
{
 mGrowBy = growBy;
}


template <class T>
void TArray<T>::SetQuantity(UInt newQuantity, Bool copy)
{
 if (newQuantity > mMaxQuantity)
 {
  SetMaxQuantity(newQuantity, copy);
 }

 mQuantity = newQuantity;
}


template <class T>
inline UInt TArray<T>::GetGrowBy() const
{
 return mGrowBy;
}


template <class T>
void TArray<T>::Append(const T& rElement)
{
 if (++mQuantity > mMaxQuantity)
 {
  if (mGrowBy > 0)
  {




   T saveElement(rElement);
   SetMaxQuantity(mMaxQuantity + mGrowBy, true);
   mpArray[mQuantity-1] = saveElement;
   return;
  }


  ;
  --mQuantity;
 }

 mpArray[mQuantity-1] = rElement;
}


template <class T>
void TArray<T>::Insert(UInt i, const T& rElement)
{
 ;
 if (mQuantity == mMaxQuantity)
 {
  SetMaxQuantity(mMaxQuantity+mGrowBy);
 }

 SetQuantity(mQuantity+1);

 for (UInt j = GetQuantity()-1; j > 0 && j > i; j--)
 {
  mpArray[j] = mpArray[j-1];
 }

 mpArray[i] = rElement;
}


template <class T>
void TArray<T>::SetElement(UInt i, const T& rElement)
{
 if (i >= mQuantity)
 {
  if (i >= mMaxQuantity)
  {
   if (mGrowBy > 0)
   {

    if (i+1 >= mMaxQuantity)
    {
     UInt n = 1 + static_cast<Int>(0.5F + (i+1 - mMaxQuantity) /
      static_cast<Float>(mGrowBy));






     T saveElement(rElement);
     SetMaxQuantity(mMaxQuantity + n * mGrowBy, true);
     mQuantity = i+1;
     mpArray[i] = saveElement;
     return;
    }
   }
   else
   {

    ;
    i = mQuantity-1;
   }
  }

  mQuantity = i+1;
 }

 mpArray[i] = rElement;
}
# 78 "/home/pete/code/wire3d/Wire/Foundation/WireTArray.h" 2

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireVertexAttributes.h" 2

namespace Wire
{

class VertexAttributes
{

public:
 VertexAttributes();
 virtual ~VertexAttributes();

 inline UInt GetChannelQuantity() const;
 inline UInt GetColorChannelQuantity() const;
 inline UInt GetTCoordChannelQuantity() const;

 void SetPositionChannels(UInt positionChannels);
 void SetColorChannels(UInt colorChannels, UInt unit = 0);
 void SetNormalChannels(UInt normalChannels);
 void SetTCoordChannels(UInt tCoordChannels, UInt unit = 0);

 inline Bool HasPosition() const;
 inline Bool HasColor(UInt unit = 0) const;
 inline Bool HasNormal() const;
 inline Bool HasTCoord(UInt unit = 0) const;

 inline UInt GetPositionChannels() const;
 inline UInt GetColorChannels(UInt unit = 0) const;
 inline UInt GetNormalChannels() const;
 inline UInt GetTCoordChannels(UInt unit = 0) const;

 inline UInt GetPositionOffset() const;
 inline UInt GetColorOffset(UInt unit = 0) const;
 inline UInt GetNormalOffset() const;
 inline UInt GetTCoordOffset(UInt unit = 0) const;

private:
 void UpdateOffsets();
 void ResetOffsets();

 UInt mChannelQuantity;

 Int mPositionChannels;
 Int mPositionOffset;

 TArray<Int> mColorChannels;
 TArray<Int> mColorOffset;

 Int mNormalChannels;
 Int mNormalOffset;

 TArray<Int> mTCoordChannels;
 TArray<Int> mTCoordOffset;
};

# 1 "/home/pete/code/wire3d/Wire/Engine/WireVertexAttributes.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireVertexAttributes.inl"
inline UInt VertexAttributes::GetChannelQuantity() const
{
 return mChannelQuantity;
}


inline UInt VertexAttributes::GetColorChannelQuantity() const
{
 return mColorChannels.GetQuantity();
}


inline UInt VertexAttributes::GetTCoordChannelQuantity() const
{
 return mTCoordChannels.GetQuantity();
}


inline Bool VertexAttributes::HasPosition() const
{
 return mPositionChannels > 0;
}


inline Bool VertexAttributes::HasColor(UInt unit) const
{
 if (unit >= mColorChannels.GetQuantity())
 {
  return false;
 }

 return mColorChannels[unit] > 0;
}


inline Bool VertexAttributes::HasNormal() const
{
 return mNormalChannels > 0;
}


inline Bool VertexAttributes::HasTCoord(UInt unit) const
{
 if (unit >= mTCoordChannels.GetQuantity())
 {
  return false;
 }

 return mTCoordChannels[unit] > 0;
}


inline UInt VertexAttributes::GetPositionChannels() const
{
 return mPositionChannels;
}


inline UInt VertexAttributes::GetColorChannels(UInt unit) const
{
 ;
 return mColorChannels[unit];
}


inline UInt VertexAttributes::GetNormalChannels() const
{
 return mNormalChannels;
}


inline UInt VertexAttributes::GetTCoordChannels(UInt unit) const
{
 ;
 return mTCoordChannels[unit];
}


inline UInt VertexAttributes::GetPositionOffset() const
{
 return mPositionOffset;
}


inline UInt VertexAttributes::GetColorOffset(UInt unit) const
{
 ;
 return mColorOffset[unit];
}


inline UInt VertexAttributes::GetNormalOffset() const
{
 return mNormalOffset;
}


inline UInt VertexAttributes::GetTCoordOffset(UInt unit) const
{
 ;
 return mTCoordOffset[unit];
}
# 69 "/home/pete/code/wire3d/Wire/Engine/WireVertexAttributes.h" 2

}
# 19 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.h" 2

namespace Wire
{

class VertexBuffer : public Buffer
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 VertexBuffer(const VertexAttributes& rAttributes, UInt vertexQuantity,
  UsageType usage = UT_STATIC);
 virtual ~VertexBuffer();

 inline UInt GetVertexQuantity() const;
 inline Float* GetData();
 inline const Float* GetData() const;
 inline const VertexAttributes& GetAttributes() const;

 Vector3F& Position3(UInt i);
 Vector3F Position3(UInt i) const;

 ColorRGB& Color3(UInt i, UInt unit = 0);
 ColorRGB Color3(UInt i, UInt unit = 0) const;

 ColorRGBA& Color4(UInt i, UInt unit = 0);
 ColorRGBA Color4(UInt i, UInt unit = 0) const;

 Vector3F& Normal3(UInt i);
 Vector3F Normal3(UInt i) const;

 Vector2F& TCoord2(UInt i, UInt unit = 0);
 Vector2F TCoord2(UInt i, UInt unit = 0) const;

 inline Float* GetPosition(UInt i = 0);
 inline const Float* GetPosition(UInt i = 0) const;

  inline Float* GetColor(UInt i = 0, UInt unit = 0);
  inline const Float* GetColor(UInt i = 0, UInt unit = 0) const;

 inline Float* GetNormal(UInt i = 0);
 inline const Float* GetNormal(UInt i = 0) const;

 inline Float* GetTCoord(UInt i = 0, UInt unit = 0);
 inline const Float* GetTCoord(UInt i = 0, UInt unit = 0) const;

 void GeneratePlatonicNormals();

private:
 VertexAttributes mAttributes;


 UInt mVertexQuantity;


 Float* mpChannel;
};

typedef Pointer<VertexBuffer> VertexBufferPtr;

# 1 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.inl"
inline UInt VertexBuffer::GetVertexQuantity() const
{
 return mVertexQuantity;
}


inline Float* VertexBuffer::GetData()
{
 return mpChannel;
}


inline const Float* VertexBuffer::GetData() const
{
 return mpChannel;
}


inline const VertexAttributes& VertexBuffer::GetAttributes() const
{
 return mAttributes;
}


inline Float* VertexBuffer::GetPosition(UInt i)
{
 UInt index = mAttributes.GetChannelQuantity() * i +
  mAttributes.GetPositionOffset();
 return mpChannel + index;
}


inline const Float* VertexBuffer::GetPosition(UInt i) const
{
 UInt index = mAttributes.GetChannelQuantity() * i +
  mAttributes.GetPositionOffset();
 return mpChannel + index;
}


inline Float* VertexBuffer::GetColor(UInt i, UInt unit)
{
 Float* pChannel = mpChannel + mAttributes.GetChannelQuantity() * i +
  mAttributes.GetColorOffset(unit);
 return pChannel;
}


inline const Float* VertexBuffer::GetColor(UInt i, UInt unit) const
{
 Float* pChannel = mpChannel + mAttributes.GetChannelQuantity() * i +
  mAttributes.GetColorOffset(unit);
 return pChannel;
}


inline Float* VertexBuffer::GetNormal(UInt i)
{
 Float* pChannel = mpChannel + mAttributes.GetChannelQuantity() * i +
  mAttributes.GetNormalOffset();
 return pChannel;
}


inline const Float* VertexBuffer::GetNormal(UInt i) const
{
 Float* pChannel = mpChannel + mAttributes.GetChannelQuantity() * i +
  mAttributes.GetNormalOffset();
 return pChannel;
}


inline Float* VertexBuffer::GetTCoord(UInt i, UInt unit)
{
 Float* pChannel = mpChannel + mAttributes.GetChannelQuantity() * i +
  mAttributes.GetTCoordOffset(unit);
 return pChannel;
}


inline const Float* VertexBuffer::GetTCoord(UInt i, UInt unit) const
{
 Float* pChannel = mpChannel + mAttributes.GetChannelQuantity() * i +
  mAttributes.GetTCoordOffset(unit);
 return pChannel;
}
# 79 "/home/pete/code/wire3d/Wire/Engine/WireVertexBuffer.h" 2

}
# 18 "/home/pete/code/wire3d/Wire/Engine/WireBoundingVolume.h" 2

namespace Wire
{

class BoundingVolume : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:

 virtual ~BoundingVolume();




 static BoundingVolume* Create();


 virtual void SetCenter(const Vector3F& rCenter) = 0;
 virtual void SetRadius(Float radius) = 0;
 virtual Vector3F GetCenter() const = 0;
 virtual Float GetRadius() const = 0;


 virtual void ComputeFromData(const VertexBuffer* pVBuffer) = 0;


 virtual void TransformBy(const Transformation& rTransform,
  BoundingVolume* pResult) = 0;






 virtual Int WhichSide(const Plane3F& rPlane) const = 0;


 virtual void CopyFrom(const BoundingVolume* pInput) = 0;



 virtual void GrowToContain(const BoundingVolume* pInput) = 0;

protected:
 BoundingVolume();
};

typedef Pointer<BoundingVolume> BoundingVolumePtr;

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2

# 1 "/home/pete/code/wire3d/Wire/Engine/WireCamera.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireCamera.h"
       






namespace Wire
{

class Camera : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 Camera(Bool isPerspective = true);
 Camera(const Vector3F& location, const Vector3F& direction,
  const Vector3F& up, Bool isPerspective = true);
 virtual ~Camera();

 enum
 {
  VF_DMIN = 0,
  VF_DMAX = 1,
  VF_UMIN = 2,
  VF_UMAX = 3,
  VF_RMIN = 4,
  VF_RMAX = 5,
  VF_QUANTITY = 6
 };

 inline Vector3F GetLocation() const;
 inline Vector3F GetDVector() const;
 inline Vector3F GetUVector() const;
 inline Vector3F GetRVector() const;






 void SetFrame(const Vector3F& rLocation, const Vector3F& rDVector,
  const Vector3F& rUVector, const Vector3F& rRVector);

 void LookAt(const Vector3F& rLocation, const Vector3F& rLookAt,
  const Vector3F& rUp);

 void SetAxes(const Vector3F& rDVector, const Vector3F& rUVector,
  const Vector3F& rRVector);







 void SetFrustum(Float rMin, Float rMax, Float uMin, Float uMax,
  Float dMin, Float dMax);







 void SetFrustum(Float upFovDegrees, Float aspectRatio, Float dMin,
  Float dMax);

 void GetFrustum(Float& rRMin, Float& rRMax, Float& rUMin, Float& rUMax,
  Float& rDMin, Float& rDMax) const;




 Bool GetFrustum(Float& rUpFovDegrees, Float& rAspectRatio,
  Float& rDMin, Float& rDMax) const;


 inline const Float* GetFrustum() const;


 inline Float GetDMin() const;
 inline Float GetDMax() const;
 inline Float GetUMin() const;
 inline Float GetUMax() const;
 inline Float GetRMin() const;
 inline Float GetRMax() const;


 void SetViewport(Float left, Float right, Float top, Float bottom);
 void GetViewport(Float& rLeft, Float& rRight, Float& rTop,
  Float& rBottom);

 inline Bool IsPerspective() const;

private:

 Vector3F mLocation;
 Vector3F mDVector;
 Vector3F mUVector;
 Vector3F mRVector;


 Float mFrustum[VF_QUANTITY];


 Float mPortLeft;
 Float mPortRight;
 Float mPortTop;
 Float mPortBottom;


 Bool mIsPerspective;
};

typedef Pointer<Camera> CameraPtr;

# 1 "/home/pete/code/wire3d/Wire/Engine/WireCamera.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireCamera.inl"
inline Vector3F Camera::GetLocation() const
{
 return mLocation;
}


inline Vector3F Camera::GetDVector() const
{
 return mDVector;
}


inline Vector3F Camera::GetUVector() const
{
 return mUVector;
}


inline Vector3F Camera::GetRVector() const
{
 return mRVector;
}


inline const Float* Camera::GetFrustum() const
{
 return mFrustum;
}


inline Float Camera::GetDMin() const
{
 return mFrustum[VF_DMIN];
}


inline Float Camera::GetDMax() const
{
 return mFrustum[VF_DMAX];
}


inline Float Camera::GetUMin() const
{
 return mFrustum[VF_UMIN];
}


inline Float Camera::GetUMax() const
{
 return mFrustum[VF_UMAX];
}


inline Float Camera::GetRMin() const
{
 return mFrustum[VF_RMIN];
}


inline Float Camera::GetRMax() const
{
 return mFrustum[VF_RMAX];
}


inline Bool Camera::IsPerspective() const
{
 return mIsPerspective;
}
# 127 "/home/pete/code/wire3d/Wire/Engine/WireCamera.h" 2

}
# 16 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireController.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireController.h"
       





namespace Wire
{

class SceneObject;

class Controller : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:

 virtual ~Controller();


 inline SceneObject* GetObject() const;


 virtual Bool Update(Double appTime);

protected:

 Controller();


 friend class SceneObject;
 inline void SetObject(SceneObject* pObject);



 SceneObject* mpObject;

 Double mLastAppTime;
};

typedef Pointer<Controller> ControllerPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireController.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireController.inl"
inline void Controller::SetObject(SceneObject* pObject)
{
 mpObject = pObject;
}


inline SceneObject* Controller::GetObject() const
{
 return mpObject;
}
# 51 "/home/pete/code/wire3d/Wire/Engine/WireController.h" 2

}
# 17 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireCuller.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireCuller.h"
       





# 1 "/home/pete/code/wire3d/Wire/Engine/WireVisibleSet.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireVisibleSet.h"
       



# 1 "/home/pete/code/wire3d/Wire/Engine/WireVisibleObject.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireVisibleObject.h"
       





namespace Wire
{

class Effect;
class Spatial;

class VisibleObject
{

public:
 Spatial* Object;
 Effect* GlobalEffect;

 inline Bool IsDrawable() const;
};

# 1 "/home/pete/code/wire3d/Wire/Engine/WireVisibleObject.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireVisibleObject.inl"
inline Bool VisibleObject::IsDrawable() const
{
 return Object && !GlobalEffect;
}
# 32 "/home/pete/code/wire3d/Wire/Engine/WireVisibleObject.h" 2

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireVisibleSet.h" 2


namespace Wire
{

class Spatial;

class VisibleSet
{

public:
 enum
 {
  VS_DEFAULT_MAX_QUANTITY = 32,
  VS_DEFAULT_GROWBY = 32,
 };

 VisibleSet(UInt maxQuantity = VS_DEFAULT_MAX_QUANTITY, UInt growBy =
  VS_DEFAULT_GROWBY);
 virtual ~VisibleSet ();

 inline UInt GetQuantity() const;
 inline VisibleObject* GetVisible();
 inline VisibleObject& GetVisible(UInt i);



 void Insert(Spatial* pObject, Effect* pGlobalEffect);
 inline void Clear();

private:
 TArray<VisibleObject> mVisible;
};

# 1 "/home/pete/code/wire3d/Wire/Engine/WireVisibleSet.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireVisibleSet.inl"
inline void VisibleSet::Clear()
{
 mVisible.SetQuantity(0, false);
}


inline UInt VisibleSet::GetQuantity() const
{
 return mVisible.GetQuantity();
}


inline VisibleObject* VisibleSet::GetVisible()
{
 return mVisible.GetArray();
}


inline VisibleObject& VisibleSet::GetVisible(UInt i)
{
 ;
 return mVisible[i];
}
# 49 "/home/pete/code/wire3d/Wire/Engine/WireVisibleSet.h" 2

}
# 16 "/home/pete/code/wire3d/Wire/Engine/WireCuller.h" 2

namespace Wire
{

class Spatial;

class Culler
{
public:




 Culler(Int maxQuantity = VisibleSet::VS_DEFAULT_MAX_QUANTITY, Int growBy =
  VisibleSet::VS_DEFAULT_GROWBY, const Camera* pCamera = 0);
 virtual ~Culler();


 inline void SetCamera(const Camera* pCamera);
 inline const Camera* GetCamera() const;
 void SetFrustum(const Float* pFrustum);
 inline VisibleSet& GetVisibleSet();




 void ComputeVisibleSet(Spatial* pScene);


 Bool IsVisible(const Spatial* pSpatial) const;



 Bool IsVisible(const BoundingVolume* pBV);






 inline virtual void Insert(Spatial* pObject, Effect* pGlobalEffect);

 enum { VS_MAX_PLANE_QUANTITY = 32 };
 inline void SetPlaneState(UInt planeState);
 inline UInt GetPlaneState() const;

protected:


 const Camera* mpCamera;





 Float mFrustum[Camera::VF_QUANTITY];
# 83 "/home/pete/code/wire3d/Wire/Engine/WireCuller.h"
 Int mPlaneQuantity;
 Plane3F mPlanes[VS_MAX_PLANE_QUANTITY];
 UInt mPlaneState;


 VisibleSet mVisible;
};

# 1 "/home/pete/code/wire3d/Wire/Engine/WireCuller.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireCuller.inl"
inline void Culler::SetCamera(const Camera* pCamera)
{
 mpCamera = pCamera;
 SetFrustum(mpCamera->GetFrustum());
}


inline const Camera* Culler::GetCamera() const
{
 return mpCamera;
}


inline void Culler::SetPlaneState(UInt planeState)
{
 mPlaneState = planeState;
}


inline UInt Culler::GetPlaneState() const
{
 return mPlaneState;
}


inline VisibleSet& Culler::GetVisibleSet()
{
 return mVisible;
}


inline void Culler::Insert(Spatial* pObject, Effect* pGlobalEffect)
{
 mVisible.Insert(pObject, pGlobalEffect);
}
# 92 "/home/pete/code/wire3d/Wire/Engine/WireCuller.h" 2

}
# 18 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireEffect.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireEffect.h"
       





namespace Wire
{

class Effect : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:

 virtual ~Effect();

protected:
 Effect();
};

typedef Pointer<Effect> EffectPtr;

}
# 19 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireGeometry.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireGeometry.h"
       




# 1 "/home/pete/code/wire3d/Wire/Engine/WireIndexBuffer.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireIndexBuffer.h"
       





namespace Wire
{

class IndexBuffer : public Buffer
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 IndexBuffer(UInt quantity, UsageType usage = UT_STATIC);
 virtual ~IndexBuffer();


 inline UInt operator[] (UInt i) const;
 inline UInt& operator[] (UInt i);




 inline UInt GetIndexQuantity() const;
 inline UInt* GetData();
 inline const UInt* GetData() const;

private:
 UInt mQuantity;
 UInt* mpIndices;
};

typedef Pointer<IndexBuffer> IndexBufferPtr;

# 1 "/home/pete/code/wire3d/Wire/Engine/WireIndexBuffer.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireIndexBuffer.inl"
inline UInt IndexBuffer::GetIndexQuantity() const
{
 return mQuantity;
}


inline UInt* IndexBuffer::GetData()
{
 return mpIndices;
}


inline const UInt* IndexBuffer::GetData() const
{
 return mpIndices;
}


inline UInt IndexBuffer::operator[] (UInt i) const
{
 ;
 return mpIndices[i];
}

inline UInt& IndexBuffer::operator[] (UInt i)
{
 ;
 return mpIndices[i];
}
# 45 "/home/pete/code/wire3d/Wire/Engine/WireIndexBuffer.h" 2

}
# 15 "/home/pete/code/wire3d/Wire/Engine/WireGeometry.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireLight.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireLight.h"
       







namespace Wire
{

class Light : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 enum LightType
 {
  LT_DIRECTIONAL,
  LT_POINT,
  LT_SPOT,
  LT_QUANTITY
 };

 Light(LightType type = LT_DIRECTIONAL);
 virtual ~Light();

 LightType Type;

 ColorRGB Ambient;
 ColorRGB Color;


 Vector3F Position;
 Vector3F Direction;


 Float Angle;
 Float Exponent;

 Bool Enabled;
};

typedef Pointer<Light> LightPtr;

}
# 16 "/home/pete/code/wire3d/Wire/Engine/WireGeometry.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireMaterial.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireMaterial.h"
       





# 1 "/home/pete/code/wire3d/Wire/Engine/WireTexture2D.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireTexture2D.h"
       





namespace Wire
{

class Image2D;

class Texture2D : public Buffer
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 enum FilterType
 {
  FT_NEAREST,
  FT_LINEAR,
  FT_NEAREST_NEAREST,
  FT_NEAREST_LINEAR,
  FT_LINEAR_NEAREST,
  FT_LINEAR_LINEAR,
  FT_QUANTITY
 };

 enum WrapType
 {
  WT_CLAMP,
  WT_REPEAT,
  WT_MIRRORED_REPEAT,
  WT_QUANTITY
 };

 Texture2D(Image2D* pImage, UsageType usage = UT_STATIC);
 virtual ~Texture2D();

 inline Image2D* GetImage();
 inline const Image2D* GetImage() const;


 inline void SetFilterType(FilterType filterType);
 inline FilterType GetFilterType() const;


 inline void SetWrapType(UInt i, WrapType wrapType);
 inline WrapType GetWrapType(UInt i) const;


 inline void SetAnisotropyValue(Float anisotropy);
 inline Float GetAnisotropyValue() const;

private:
 Pointer<Image2D> mspImage;
 FilterType mFilterType;
 WrapType mWarpType[2];
 Float mAnisotropy;
};

typedef Pointer<Texture2D> Texture2DPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireTexture2D.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireTexture2D.inl"
inline Image2D* Texture2D::GetImage()
{
 return mspImage;
}


inline const Image2D* Texture2D::GetImage() const
{
 return mspImage;
}


inline void Texture2D::SetFilterType(FilterType filterType)
{
 mFilterType = filterType;
}

inline Texture2D::FilterType Texture2D::GetFilterType() const
{
 return mFilterType;
}


inline void Texture2D::SetWrapType(UInt i, WrapType wrapType)
{
 ;
 mWarpType[i] = wrapType;
}

inline Texture2D::WrapType Texture2D::GetWrapType(UInt i) const
{
 ;
 return mWarpType[i];
}


inline void Texture2D::SetAnisotropyValue(Float anisotropy)
{
 mAnisotropy = anisotropy;
}

inline Float Texture2D::GetAnisotropyValue() const
{
 return mAnisotropy;
}
# 71 "/home/pete/code/wire3d/Wire/Engine/WireTexture2D.h" 2

}
# 16 "/home/pete/code/wire3d/Wire/Engine/WireMaterial.h" 2

namespace Wire
{

class Material : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 Material();
 virtual ~Material();

 enum BlendMode
 {
  BM_REPLACE,
  BM_MODULATE,
  BM_PASS,
  BM_BLEND,
  BM_DECAL,
  BM_QUANTITY
 };

 inline UInt GetTextureQuantity() const;
 inline Texture2D* GetTexture(UInt i = 0) const;
 inline BlendMode GetBlendMode(UInt i = 0) const;
 inline void SetBlendMode(BlendMode blendMode, UInt i = 0);

 void AddTexture(Texture2D* pTexture, BlendMode blendMode = BM_MODULATE);
  void SetTexture(UInt i, Texture2D* pTexture, BlendMode blendMode =
  BM_MODULATE);

private:
 struct TextureBlendMode
 {
  Texture2DPtr Texture;
  Material::BlendMode BlendMode;
 };

 TArray<TextureBlendMode> mTextures;
};

typedef Pointer<Material> MaterialPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireMaterial.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireMaterial.inl"
inline UInt Material::GetTextureQuantity() const
{
 return mTextures.GetQuantity();
}


inline Texture2D* Material::GetTexture(UInt i) const
{
 return mTextures[i].Texture;
}


inline Material::BlendMode Material::GetBlendMode(UInt i) const
{
 return mTextures[i].BlendMode;
}


inline void Material::SetBlendMode(BlendMode blendmode, UInt i)
{
 mTextures[i].BlendMode = blendmode;
}
# 59 "/home/pete/code/wire3d/Wire/Engine/WireMaterial.h" 2

}
# 17 "/home/pete/code/wire3d/Wire/Engine/WireGeometry.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireSpatial.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireSpatial.h"
       






# 1 "/home/pete/code/wire3d/Wire/Engine/WireSceneObject.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireSceneObject.h"
       







namespace Wire
{

class SceneObject : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 virtual ~SceneObject();

 inline UInt GetControllerQuantity() const;
  inline Controller* GetController(UInt i) const;
  void AttachController(Controller* pController);
  void DetachController(Controller* pController);
  void DetachAllControllers();
  Bool UpdateControllers(Double appTime);

protected:
 SceneObject();

private:
 TArray<ControllerPtr> mControllers;
};

typedef Pointer<SceneObject> SceneObjectPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireSceneObject.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireSceneObject.inl"
inline UInt SceneObject::GetControllerQuantity() const
{
 return mControllers.GetQuantity();
}


inline Controller* SceneObject::GetController(UInt i) const
{
 ;
 return mControllers[i];
}
# 43 "/home/pete/code/wire3d/Wire/Engine/WireSceneObject.h" 2

}
# 17 "/home/pete/code/wire3d/Wire/Engine/WireSpatial.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireState.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireState.h"
       



# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMain.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireMain.h"
       





namespace Wire
{

class Main
{

public:
 typedef void (*Initializer)();
 typedef TArray<Initializer> InitializerArray;
 static void AddInitializer(Initializer initializer);
 static void Initialize();

 typedef void (*Terminator)();
 typedef TArray<Terminator> TerminatorArray;
 static void AddTerminator(Terminator terminator);
 static void Terminate();

private:
 static InitializerArray* s_pInitializers;
 static TerminatorArray* s_pTerminators;
};

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireState.h" 2


namespace Wire
{

class State : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:

 virtual ~State();


 enum StateType
 {
  ALPHA,
  CULL,
  FOG,
  MATERIAL,
  WIREFRAME,
  ZBUFFER,
  MAX_STATE_TYPE
 };

 virtual StateType GetStateType() const = 0;

 static Pointer<State> Default[MAX_STATE_TYPE];

protected:
 State();
};

typedef Pointer<State> StatePtr;

}
# 18 "/home/pete/code/wire3d/Wire/Engine/WireSpatial.h" 2


namespace Wire
{

class Culler;

class Spatial : public SceneObject
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:

 virtual ~Spatial();






 Transformation Local;
 Transformation World;
 Bool WorldIsCurrent;





 BoundingVolumePtr WorldBound;
 Bool WorldBoundIsCurrent;


 enum CullingMode
 {


  CULL_DYNAMIC,



  CULL_ALWAYS,





  CULL_NEVER,

  MAX_CULLING_MODE
 };

 CullingMode Culling;







 void UpdateGS(Double appTime = -MathD::MAX_REAL, Bool isInitiator = true);
 void UpdateBS();


 virtual void UpdateRS(TArray<State*>* pGStack = __null,
  TArray<Light*>* pLStack = __null);


 inline void SetParent(Spatial* pParent);
 inline Spatial* GetParent();


 void OnGetVisibleSet(Culler& rCuller, Bool noCull);
 virtual void GetVisibleSet(Culler& rCuller, Bool noCull) = 0;


 inline UInt GetStateQuantity() const;
 inline State* GetState(UInt i) const;
 State* GetState(State::StateType type) const;
 void AttachState(State* pState);
 void DetachState(State::StateType type);
 inline void DetachAllStates();


    inline UInt GetLightQuantity() const;
    inline Light* GetLight(UInt i = 0) const;
    void AttachLight(Light* pLight);
    inline void DetachLight(Light* pLight);
    inline void DetachAllLights();


 inline UInt GetEffectQuantity() const;
 inline Effect* GetEffect(UInt i = 0) const;
 void AttachEffect(Effect* pEffect);
 inline void DetachEffect(Effect* pEffect);
 inline void DetachAllEffects();

protected:
 Spatial();


 virtual void UpdateWorldData(Double appTime);
 virtual void UpdateWorldBound() = 0;
 void PropagateBoundToRoot();


 void PropagateStateFromRoot(TArray<State*>* pGStack,
  TArray<Light*>* pLStack);
 void PushState(TArray<State*>* pGStack, TArray<Light*>* pLStack);
 void PopState(TArray<State*>* pGStack, TArray<Light*>* pLStack);
 virtual void UpdateState(TArray<State*>* pGStack,
  TArray<Light*>* pLStack) = 0;

protected:

 Spatial* mpParent;


 TArray<StatePtr> mStates;


 TArray<LightPtr> mLights;





 TArray<EffectPtr> mEffects;
};

typedef Pointer<Spatial> SpatialPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireSpatial.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireSpatial.inl"
inline void Spatial::SetParent(Spatial* pParent)
{
 mpParent = pParent;
}


inline Spatial* Spatial::GetParent()
{
 return mpParent;
}


inline UInt Spatial::GetStateQuantity() const
{
 return mStates.GetQuantity();
}


inline State* Spatial::GetState(UInt i) const
{
 ;
 return mStates[i];
}


inline void Spatial::DetachAllStates()
{
 mStates.RemoveAll();
}


inline UInt Spatial::GetLightQuantity() const
{
 return mLights.GetQuantity();
}


inline Light* Spatial::GetLight(UInt i) const
{
 ;
 return mLights[i];
}


inline void Spatial::DetachLight(Light* pLight)
{
 mLights.Remove(pLight);
}


inline void Spatial::DetachAllLights()
{
 mLights.RemoveAll();
}


inline UInt Spatial::GetEffectQuantity() const
{
 return mEffects.GetQuantity();
}


inline Effect* Spatial::GetEffect(UInt i) const
{
 ;
 return mEffects[i];
}


inline void Spatial::DetachEffect(Effect* pEffect)
{
 mEffects.Remove(pEffect);
}


inline void Spatial::DetachAllEffects()
{
 mEffects.RemoveAll();
}
# 149 "/home/pete/code/wire3d/Wire/Engine/WireSpatial.h" 2

}
# 18 "/home/pete/code/wire3d/Wire/Engine/WireGeometry.h" 2


namespace Wire
{

class Geometry : public Spatial
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 Geometry(VertexBuffer* pVBuffer, IndexBuffer* pIBuffer, Material*
  pMaterial = __null);
 virtual ~Geometry();


 virtual void UpdateWorldBound();
 void UpdateModelBound();

 inline VertexBuffer* GetVBuffer();
 inline const VertexBuffer* GetVBuffer() const;

 inline IndexBuffer* GetIBuffer();
 inline const IndexBuffer* GetIBuffer() const;

 inline Material* GetMaterial();
 inline const Material* GetMaterial() const;
 inline void SetMaterial(Material* pMaterial);

 inline BoundingVolume* GetModelBound();
 inline const BoundingVolume* GetModelBound() const;

 void GenerateNormals(Bool ignoreHardEdges = false);


 StatePtr States[State::MAX_STATE_TYPE];
 TArray<LightPtr> Lights;


protected:

 virtual void UpdateState(TArray<State*>* pGStack, TArray<Light*>*
  pLStack);


 virtual void GetVisibleSet(Culler& rCuller, Bool noCull);

private:
 VertexBufferPtr mspVBuffer;
 IndexBufferPtr mspIBuffer;
 BoundingVolumePtr mspModelBound;
 MaterialPtr mspMaterial;
};

typedef Pointer<Geometry> GeometryPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireGeometry.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireGeometry.inl"
inline VertexBuffer* Geometry::GetVBuffer()
{
 return mspVBuffer;
}


inline const VertexBuffer* Geometry::GetVBuffer() const
{
 return mspVBuffer;
}


inline IndexBuffer* Geometry::GetIBuffer()
{
 return mspIBuffer;
}


inline const IndexBuffer* Geometry::GetIBuffer() const
{
 return mspIBuffer;
}


inline Material* Geometry::GetMaterial()
{
 return mspMaterial;
}


inline const Material* Geometry::GetMaterial() const
{
 return mspMaterial;
}


inline void Geometry::SetMaterial(Material* pMaterial)
{
 mspMaterial = pMaterial;
}


inline BoundingVolume* Geometry::GetModelBound()
{
 return mspModelBound;
}


inline const BoundingVolume* Geometry::GetModelBound() const
{
 return mspModelBound;
}
# 73 "/home/pete/code/wire3d/Wire/Engine/WireGeometry.h" 2

}
# 20 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireImage2D.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireImage2D.h"
       





namespace Wire
{

class Image2D : public Object
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 enum FormatMode
 {
  FM_RGB888,
  FM_RGBA8888,
  FM_RGB565,
  FM_RGBA4444,
  FM_QUANTITY
 };




 Image2D(FormatMode format, UInt width, UInt height, UChar* pData,
  Bool createMipmaps = true);
 virtual ~Image2D();


 inline UChar* GetData() const;
 inline FormatMode GetFormat() const;


 inline UInt GetQuantity(UInt level = 0) const;
 UInt GetBound(UInt i, UInt level = 0) const;
 inline UInt GetBytesPerPixel() const;
 inline static UInt GetBytesPerPixel(FormatMode format);

 inline Bool HasAlpha() const;
 inline Bool HasMipmaps() const;
 void CreateMipmaps();
 UInt GetMipmapCount() const;
 UInt GetMipmapQuantity(UInt level) const;


 UChar* GetMipmap(UInt level) const;


 UInt GetMipmapOffset(UInt level) const;


 UInt GetTotalQuantity() const;

 inline static void RGB888ToRGB565(UChar* pSrc888, UChar* pDst565);
 inline static void RGBA8888ToRGBA4444(UChar* pRGBA8888, UChar* pDst4444);
 inline static void RGB565ToRGB888(UChar* pSrc565, UChar* pDst888);
 inline static void RGBA4444ToRGBA8888(UChar* pSrc4444, UChar* pDst8888);

private:
 inline Bool IsPowerOfTwo(UInt value) const;
 void CreateMipmap(UChar* pSrc, UChar* pDst, UInt width, UInt height);
 void CreateMipmap1(UChar* pSrc, UChar* pDst, UInt width, UInt height);

 static const UChar s_ImageBpp[];
 FormatMode mFormat;
 UChar* mpData;
 UInt mBound[2];
 Bool mHasMipmaps;
};

typedef Pointer<Image2D> Image2DPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireImage2D.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireImage2D.inl"
inline UChar* Image2D::GetData() const
{
 return mpData;
}


inline Image2D::FormatMode Image2D::GetFormat() const
{
 return mFormat;
}


inline UInt Image2D::GetQuantity(UInt level) const
{
 if (level == 0)
 {
  return mBound[0] * mBound[1];
 }
 else
 {
  return GetBound(0, level) * GetBound(1, level);
 }
}


inline Bool Image2D::HasAlpha() const
{
 return mFormat == FM_RGBA8888 || mFormat == FM_RGBA4444;
}


inline Bool Image2D::HasMipmaps() const
{
 return mHasMipmaps;
}


inline Bool Image2D::IsPowerOfTwo(UInt value) const
{
 return ((value & (value-1)) == 0);
}


inline UInt Image2D::GetBytesPerPixel() const
{
 return GetBytesPerPixel(mFormat);
}


inline UInt Image2D::GetBytesPerPixel(FormatMode format)
{
 return s_ImageBpp[format];
}


inline void Image2D::RGB888ToRGB565(UChar* pSrc888, UChar* pDst565)
{
 UShort rgb565 = static_cast<UShort>(*pSrc888++);
 rgb565 &= 0xF8;
 rgb565 = rgb565 << 8;

 UShort component = static_cast<UShort>(*pSrc888++);
 component &= 0xFC;
 rgb565 |= component << 3;

 component = static_cast<UShort>(*pSrc888);
 component &= 0xF8;
 rgb565 |= component >> 3;

 *pDst565++ = static_cast<UChar>(rgb565 >> 8);
 *pDst565 = static_cast<UChar>(rgb565);
}


inline void Image2D::RGBA8888ToRGBA4444(UChar* pSrc8888, UChar* pDst4444)
{
 UShort rgba4444 = static_cast<UShort>(*pSrc8888++);
 rgba4444 &= 0xF0;
 rgba4444 = rgba4444 << 8;

 UShort component = static_cast<UShort>(*pSrc8888++);
 component &= 0xF0;
 rgba4444 |= component << 4;

 component = static_cast<UShort>(*pSrc8888++);
 component &= 0xF0;
 rgba4444 |= component;

 component = static_cast<UShort>(*pSrc8888);
 rgba4444 |= component >> 4;

 *pDst4444++ = static_cast<UChar>(rgba4444 >> 8);
 *pDst4444 = static_cast<UChar>(rgba4444);
}


inline void Image2D::RGB565ToRGB888(UChar* pSrc565, UChar* pDst888)
{
 *pDst888++ = *pSrc565 & 0xF8;
 UChar gHigh = (*pSrc565++ & 0x07) << 5;
 UChar gLow = (*pSrc565 & 0xE0) >> 3;
 *pDst888++ = gHigh | gLow;
 *pDst888++ = (*pSrc565 & 0x1F) << 3;
}


inline void Image2D::RGBA4444ToRGBA8888(UChar* pSrc4444, UChar* pDst8888)
{
 *pDst8888++ = *pSrc4444 & 0xF0;
 *pDst8888++ = (*pSrc4444++ & 0x0F) << 4;
 *pDst8888++ = *pSrc4444 & 0xF0;
 *pDst8888++ = (*pSrc4444 & 0x0F) << 4;
}
# 83 "/home/pete/code/wire3d/Wire/Engine/WireImage2D.h" 2

}
# 21 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2



# 1 "/home/pete/code/wire3d/Wire/Engine/WireNode.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireNode.h"
       





namespace Wire
{

class Node : public Spatial
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 Node(UInt quantity = 0, UInt growBy = 1);
 virtual ~Node();





 inline UInt GetQuantity() const;







 UInt AttachChild(Spatial* pChild);




  Int DetachChild(Spatial* pChild);




 SpatialPtr DetachChildAt(UInt i);






 SpatialPtr SetChild(UInt i, Spatial* pChild);





  SpatialPtr GetChild(UInt i);

protected:

 virtual void UpdateWorldData(Double appTime);
 virtual void UpdateWorldBound();


 virtual void UpdateState(TArray<State*>* pGStack,
  TArray<Light*>* pLStack);


 virtual void GetVisibleSet(Culler& rCuller, Bool noCull);

 TArray<SpatialPtr> mChildren;
};

typedef Pointer<Node> NodePtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireNode.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireNode.inl"
inline UInt Node::GetQuantity() const
{
 return mChildren.GetQuantity();
}
# 80 "/home/pete/code/wire3d/Wire/Engine/WireNode.h" 2

}
# 25 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireNodeBillboard.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireNodeBillboard.h"
       





namespace Wire
{

class Camera;

class NodeBillboard : public Node
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:




    NodeBillboard(Camera* pCamera = __null);
    virtual ~NodeBillboard();


    inline void AlignTo(Camera* pCamera);

protected:

    virtual void UpdateWorldData(Double appTime);

    Pointer<Camera> mspCamera;
};

typedef Pointer<NodeBillboard> NodeBillboardPtr;

# 1 "/home/pete/code/wire3d/Wire/Engine/WireNodeBillboard.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireNodeBillboard.inl"
inline void NodeBillboard::AlignTo(Camera* pCamera)
{
    mspCamera = pCamera;
}
# 45 "/home/pete/code/wire3d/Wire/Engine/WireNodeBillboard.h" 2

}
# 26 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireNodeDLod.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireNodeDLod.h"
       



# 1 "/home/pete/code/wire3d/Wire/Engine/WireNodeSwitch.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireNodeSwitch.h"
       





namespace Wire
{

class NodeSwitch: public Node
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
    NodeSwitch();
    virtual ~NodeSwitch();

    enum { SN_INVALID_CHILD = -1 };

    inline void SetActiveChild(Int activeChild);
    inline Int GetActiveChild() const;
    inline void DisableAllChildren();

protected:

    virtual void GetVisibleSet(Culler& rCuller, Bool noCull);

    Int mActiveChild;
};

typedef Pointer<NodeSwitch> NodeSwitchPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireNodeSwitch.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireNodeSwitch.inl"
inline void NodeSwitch::SetActiveChild(Int activeChild)
{
   
                                                 ;
    mActiveChild = activeChild;
}


inline Int NodeSwitch::GetActiveChild() const
{
    return mActiveChild;
}


inline void NodeSwitch::DisableAllChildren()
{
    mActiveChild = SN_INVALID_CHILD;
}
# 41 "/home/pete/code/wire3d/Wire/Engine/WireNodeSwitch.h" 2

}
# 14 "/home/pete/code/wire3d/Wire/Engine/WireNodeDLod.h" 2

namespace Wire
{

class Camera;

class NodeDLod : public NodeSwitch
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 NodeDLod();
 virtual ~NodeDLod();

 void SetLod(UInt i, Spatial* pLod, Float minDist, Float maxDist);


    inline Vector3F& ModelCenter();
    inline const Vector3F& GetModelCenter() const;
    inline const Vector3F& GetWorldCenter() const;


    void SetModelDistance(UInt i, Float minDist, Float maxDist);
    inline Float GetModelMinDistance(UInt i) const;
    inline Float GetModelMaxDistance(UInt i) const;
    inline Float GetWorldMinDistance(UInt i) const;
    inline Float GetWorldMaxDistance(UInt i) const;

protected:

    void SelectLevelOfDetail(const Camera* pCamera);


    virtual void GetVisibleSet(Culler& rCuller, Bool noCull);


    Vector3F mModelLodCenter;
    Vector3F mWorldLodCenter;


    TArray<Float> mModelMinDist;
    TArray<Float> mModelMaxDist;
    TArray<Float> mWorldMinDist;
    TArray<Float> mWorldMaxDist;
};

typedef Pointer<NodeDLod> NodeDLodPtr;

# 1 "/home/pete/code/wire3d/Wire/Engine/WireNodeDLod.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireNodeDLod.inl"
inline Vector3F& NodeDLod::ModelCenter()
{
    return mModelLodCenter;
}


inline const Vector3F& NodeDLod::GetModelCenter() const
{
    return mModelLodCenter;
}


inline const Vector3F& NodeDLod::GetWorldCenter() const
{
    return mWorldLodCenter;
}


inline Float NodeDLod::GetModelMinDistance(UInt i) const
{
    ;
    return mModelMinDist[i];
}


inline Float NodeDLod::GetModelMaxDistance(UInt i) const
{
    ;
    return mModelMaxDist[i];
}


inline Float NodeDLod::GetWorldMinDistance(UInt i) const
{
    ;
    return mWorldMinDist[i];
}


inline Float NodeDLod::GetWorldMaxDistance(UInt i) const
{
    ;
    return mWorldMaxDist[i];
}
# 63 "/home/pete/code/wire3d/Wire/Engine/WireNodeDLod.h" 2

}
# 27 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireNodeLight.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireNodeLight.h"
       





namespace Wire
{

class Light;

class NodeLight : public Node
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 NodeLight(Light* pLight = __null);
 virtual ~NodeLight();

 void SetLight(Light* pLight);
 inline Light* GetLight();
 inline const Light* GetLight() const;

protected:

 virtual void UpdateWorldData(Double appTime);

private:
 void LightToLocalTransform();

 LightPtr mspLight;
};

typedef Pointer<NodeLight> NodeLightPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireNodeLight.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireNodeLight.inl"
inline Light* NodeLight::GetLight()
{
 return mspLight;
}


inline const Light* NodeLight::GetLight() const
{
 return mspLight;
}
# 44 "/home/pete/code/wire3d/Wire/Engine/WireNodeLight.h" 2

}
# 28 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2


# 1 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h"
       






# 1 "/home/pete/code/wire3d/Wire/Engine/WireStateAlpha.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireStateAlpha.h"
       





namespace Wire
{

class StateAlpha : public State
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };
 public: static Bool RegisterInitialize(); static void Initialize(); private: static Bool s_InitializeRegistered;
 public: static Bool RegisterTerminate(); static void Terminate(); private: static Bool s_TerminateRegistered;

public:
 enum SrcBlendMode
 {
  SBM_ZERO,
  SBM_ONE,
  SBM_DST_COLOR,
  SBM_ONE_MINUS_DST_COLOR,
  SBM_SRC_ALPHA,
  SBM_ONE_MINUS_SRC_ALPHA,
  SBM_DST_ALPHA,
  SBM_ONE_MINUS_DST_ALPHA,
  SBM_QUANTITY
 };

 enum DstBlendMode
 {
  DBM_ZERO,
  DBM_ONE,
  DBM_SRC_COLOR,
  DBM_ONE_MINUS_SRC_COLOR,
  DBM_SRC_ALPHA,
  DBM_ONE_MINUS_SRC_ALPHA,
  DBM_DST_ALPHA,
  DBM_ONE_MINUS_DST_ALPHA,
  DBM_QUANTITY
 };

 StateAlpha();
 virtual ~StateAlpha();

 inline virtual StateType GetStateType() const { return ALPHA; }

 Bool BlendEnabled;
 SrcBlendMode SrcBlend;
 DstBlendMode DstBlend;
};

typedef Pointer<StateAlpha> StateAlphaPtr;

static Bool gs_InitializeRegisteredStateAlpha = StateAlpha::RegisterInitialize();
static Bool gs_TerminateRegisteredStateAlpha = StateAlpha::RegisterTerminate();

}
# 17 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireStateCull.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireStateCull.h"
       





namespace Wire
{

class StateCull : public State
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };
 public: static Bool RegisterInitialize(); static void Initialize(); private: static Bool s_InitializeRegistered;
 public: static Bool RegisterTerminate(); static void Terminate(); private: static Bool s_TerminateRegistered;

public:
 StateCull();
 virtual ~StateCull();

 virtual StateType GetStateType() const { return CULL; }

 enum CullMode
 {
  CM_OFF,
  CM_FRONT,
  CM_BACK,
  CM_QUANTITY
 };

 Bool Enabled;
 CullMode CullFace;
};

typedef Pointer<StateCull> StateCullPtr;

static Bool gs_InitializeRegisteredStateCull = StateCull::RegisterInitialize();
static Bool gs_TerminateRegisteredStateCull = StateCull::RegisterTerminate();

}
# 18 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireStateFog.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireStateFog.h"
       






namespace Wire
{

class StateFog : public State
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };
 public: static Bool RegisterInitialize(); static void Initialize(); private: static Bool s_InitializeRegistered;
 public: static Bool RegisterTerminate(); static void Terminate(); private: static Bool s_TerminateRegistered;

public:
 StateFog();
 virtual ~StateFog();

 inline virtual StateType GetStateType() const { return FOG; }

 enum DensityFunction
 {
  DF_LINEAR,
  DF_EXP,
  DF_EXPSQR,
  DF_QUANTITY
 };

 Bool Enabled;
 ColorRGB Color;
 DensityFunction DensityFunc;
 Float Start;
 Float End;
};

typedef Pointer<StateFog> StateFogPtr;

static Bool gs_InitializeRegisteredStateFog = StateFog::RegisterInitialize();
static Bool gs_TerminateRegisteredStateFog = StateFog::RegisterTerminate();

}
# 19 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireStateMaterial.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireStateMaterial.h"
       






namespace Wire
{

class StateMaterial : public State
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };
 public: static Bool RegisterInitialize(); static void Initialize(); private: static Bool s_InitializeRegistered;
 public: static Bool RegisterTerminate(); static void Terminate(); private: static Bool s_TerminateRegistered;

public:
 StateMaterial();
 virtual ~StateMaterial();

 inline virtual StateType GetStateType() const { return MATERIAL; }

    ColorRGBA Ambient;
};

typedef Pointer<StateMaterial> StateMaterialPtr;

static Bool gs_InitializeRegisteredStateMaterial = StateMaterial::RegisterInitialize();
static Bool gs_TerminateRegisteredStateMaterial = StateMaterial::RegisterTerminate();

}
# 20 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireStateWireframe.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireStateWireframe.h"
       





namespace Wire
{

class StateWireframe : public State
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };
 public: static Bool RegisterInitialize(); static void Initialize(); private: static Bool s_InitializeRegistered;
 public: static Bool RegisterTerminate(); static void Terminate(); private: static Bool s_TerminateRegistered;

public:
 StateWireframe();
 virtual ~StateWireframe();

 inline virtual StateType GetStateType() const { return WIREFRAME; }

 Bool Enabled;
};

typedef Pointer<StateWireframe> StateWireframePtr;

static Bool gs_InitializeRegisteredStateWireframe = StateWireframe::RegisterInitialize();
static Bool gs_TerminateRegisteredStateWireframe = StateWireframe::RegisterTerminate();

}
# 21 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireStateZBuffer.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireStateZBuffer.h"
       





namespace Wire
{

class StateZBuffer : public State
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };
 public: static Bool RegisterInitialize(); static void Initialize(); private: static Bool s_InitializeRegistered;
 public: static Bool RegisterTerminate(); static void Terminate(); private: static Bool s_TerminateRegistered;

public:
 StateZBuffer();
 virtual ~StateZBuffer();

 inline virtual StateType GetStateType() const { return ZBUFFER; }

 enum CompareFunction
 {
  CF_NEVER,
  CF_LESS,
  CF_EQUAL,
  CF_LEQUAL,
  CF_GREATER,
  CF_NOTEQUAL,
  CF_GEQUAL,
  CF_ALWAYS,
  CF_QUANTITY
 };

 Bool Enabled;
 Bool Writable;
 CompareFunction Compare;
};

typedef Pointer<StateZBuffer> StateZBufferPtr;

static Bool gs_InitializeRegisteredStateZBuffer = StateZBuffer::RegisterInitialize();
static Bool gs_TerminateRegisteredStateZBuffer = StateZBuffer::RegisterTerminate();

}
# 22 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTHashTable.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireTHashTable.h"
       
# 32 "/home/pete/code/wire3d/Wire/Foundation/WireTHashTable.h"
namespace Wire
{

template <class TKEY, class TVALUE>
class THashTable
{
public:

 THashTable(UInt tableSize = 256);
 ~THashTable();


 inline UInt GetQuantity() const;


 Bool Insert(const TKEY& rKey, const TVALUE& rValue);


 TVALUE* Find(const TKEY& rKey) const;


 Bool Remove(const TKEY& rKey);
 void RemoveAll();


 UInt (*UserHashFunction)(const TKEY&);

 struct HashItem
 {
  TKEY mKey;
  TVALUE mValue;
  HashItem* mpNext;
 };


 class Iterator
 {
 public:
  Iterator(THashTable* pHashTable);

   TVALUE* GetFirst(TKEY* pKey = __null) const;
   TVALUE* GetNext(TKEY* pKey = __null) const;

 private:
  THashTable* mpHashTable;
  mutable UInt mIndex;
  mutable HashItem* mpItem;
 };

private:


 UInt HashFunction(const TKEY& rKey) const;


 UInt mTableSize;
 UInt mQuantity;
 HashItem** mpTable;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTHashTable.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireTHashTable.inl"
template <class TKEY, class TVALUE>
THashTable<TKEY, TVALUE>::THashTable(UInt tableSize)
 :
 mTableSize(tableSize),
 mQuantity(0)
{
    mpTable = new HashItem*[mTableSize];
 ;

 System::Memset(mpTable, 0, mTableSize * sizeof(HashItem*));
    UserHashFunction = __null;
}


template <class TKEY, class TVALUE>
THashTable<TKEY, TVALUE>::~THashTable()
{
    RemoveAll();
    delete[] mpTable;
}


template <class TKEY, class TVALUE>
inline UInt THashTable<TKEY, TVALUE>::GetQuantity() const
{
    return mQuantity;
}


template <class TKEY, class TVALUE>
Bool THashTable<TKEY, TVALUE>::Insert(const TKEY& rKey, const TVALUE& rValue)
{

    UInt index = HashFunction(rKey);
    HashItem* pItem = mpTable[index];


    while (pItem)
    {
        if (rKey == pItem->mKey)
        {

            return false;
        }

        pItem = pItem->mpNext;
    }


    pItem = new HashItem;
 ;
 pItem->mKey = rKey;
    pItem->mValue = rValue;
    pItem->mpNext = mpTable[index];
    mpTable[index] = pItem;
    mQuantity++;

    return true;
}


template <class TKEY, class TVALUE>
TVALUE* THashTable<TKEY, TVALUE>::Find(const TKEY& rKey) const
{

    UInt index = HashFunction(rKey);
    HashItem* pItem = mpTable[index];


    while (pItem)
    {
        if (rKey == pItem->mKey)
        {

            return &pItem->mValue;
        }

        pItem = pItem->mpNext;
    }

    return __null;
}


template <class TKEY, class TVALUE>
Bool THashTable<TKEY, TVALUE>::Remove(const TKEY& rKey)
{

    UInt index = HashFunction(rKey);
    HashItem* pItem = mpTable[index];

    if (!pItem)
    {
        return false;
    }

    if (rKey == pItem->mKey)
    {

        HashItem* pSave = pItem;
        mpTable[index] = pItem->mpNext;
        delete pSave;
        mQuantity--;
        return true;
    }


    HashItem* pPrev = pItem;
    HashItem* pCurr = pItem->mpNext;
    while (pCurr && rKey != pCurr->mKey)
    {
        pPrev = pCurr;
        pCurr = pCurr->mpNext;
    }

    if (pCurr)
    {

        pPrev->mpNext = pCurr->mpNext;
        delete pCurr;
        mQuantity--;
        return true;
    }

    return false;
}


template <class TKEY, class TVALUE>
void THashTable<TKEY, TVALUE>::RemoveAll()
{
    if (mQuantity > 0)
    {
        for (UInt i = 0; i < mTableSize; i++)
        {
            while (mpTable[i])
            {
                HashItem* pSave = mpTable[i];
                mpTable[i] = mpTable[i]->mpNext;
                delete pSave;
                if (--mQuantity == 0)
                {
                    return;
                }
            }
        }
    }
}


template <class TKEY, class TVALUE>
UInt THashTable<TKEY, TVALUE>::HashFunction(const TKEY& rKey) const
{
 if (UserHashFunction)
    {
        return (*UserHashFunction)(rKey);
    }


    static Double s_HashMultiplier = 0.5 * (MathD::Sqrt(5.0) - 1.0);
 UInt key = (UInt)(rKey);
 key %= mTableSize;
 Double fraction = MathD::FMod(s_HashMultiplier * key, 1.0);
 return static_cast<UInt>(MathD::Floor(mTableSize*fraction));
}


template <class TKEY, class TVALUE>
THashTable<TKEY, TVALUE>::Iterator::Iterator(THashTable* pHashTable)
 :
 mpHashTable(pHashTable),
 mIndex(0),
 mpItem(__null)
{
 ;
}


template <class TKEY, class TVALUE>
TVALUE* THashTable<TKEY, TVALUE>::Iterator::GetFirst(TKEY* pKey) const
{
 if (mpHashTable->mQuantity > 0)
 {
  for (mIndex = 0; mIndex < mpHashTable->mTableSize; mIndex++)
  {
   if (mpHashTable->mpTable[mIndex])
   {
    mpItem = mpHashTable->mpTable[mIndex];
    if (pKey)
    {
     *pKey = mpItem->mKey;
    }

    return &mpItem->mValue;
   }
  }
 }

 return __null;
}


template <class TKEY, class TVALUE>
TVALUE* THashTable<TKEY, TVALUE>::Iterator::GetNext(TKEY* pKey) const
{
 if (mpHashTable->mQuantity > 0)
 {
  mpItem = mpItem->mpNext;
  if (mpItem)
  {
   if (pKey)
   {
    *pKey = mpItem->mKey;
   }

   return &mpItem->mValue;
  }

  for (mIndex++; mIndex < mpHashTable->mTableSize; mIndex++)
  {
   if (mpHashTable->mpTable[mIndex])
   {
    mpItem = mpHashTable->mpTable[mIndex];
    if (pKey)
    {
     *pKey = mpItem->mKey;
    }

    return &mpItem->mValue;
   }
  }
 }

 return __null;
}
# 93 "/home/pete/code/wire3d/Wire/Foundation/WireTHashTable.h" 2

}
# 23 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h" 2

namespace Wire
{

class Camera;
class Geometry;
class IndexBuffer;
class Light;
class PdrIndexBuffer;
class PdrVertexBuffer;
class PdrRendererData;
class PdrRendererInput;
class PdrTexture2D;
class Spatial;
class Texture2D;
class VertexBuffer;
class VisibleSet;

class Renderer
{
public:
 Renderer(PdrRendererInput& rInput, UInt width, UInt height,
  Bool isFullscreen);
 ~Renderer();



 void Initialize(UInt width, UInt height);



 void Terminate();


 void DrawScene(VisibleSet& rVisibleSet);
 void Draw(Geometry* pGeometry);


 inline UInt GetWidth() const;
 inline UInt GetHeight() const;
 inline const ColorRGBA& GetClearColor() const;


 inline Float GetMaxAnisotropy() const;
 inline UInt GetMaxTextureStages() const;


 static void BindAll(const Spatial* pSpatial);
 static void UnbindAll(const Spatial* pSpatial);


 PdrIndexBuffer* Bind(const IndexBuffer* pIndexBuffer);
 void Unbind(const IndexBuffer* pIndexBuffer);
 static void UnbindAll(const IndexBuffer* pIndexBuffer);
 void Enable(const IndexBuffer* pIndexBuffer);
 void Disable(const IndexBuffer* pIndexBuffer);
 PdrIndexBuffer* GetResource(const IndexBuffer* pIndexBuffer);


 PdrVertexBuffer* Bind(const VertexBuffer* pVertexBuffer);
 void Unbind(const VertexBuffer* pVertexBuffer);
 static void UnbindAll(const VertexBuffer* pVertexBuffer);
 void Enable(const VertexBuffer* pVertexBuffer);
 void Disable(const VertexBuffer* pVertexBuffer);
 PdrVertexBuffer* GetResource(const VertexBuffer* pVertexBuffer);
 void Update(const VertexBuffer* pVertexBuffer);


 PdrTexture2D* Bind(const Texture2D* pTexture);
 void Unbind(const Texture2D* pTexture);
 static void UnbindAll(const Texture2D* pTexture);
 void Enable(Texture2D* pTexture, UInt unit = 0);
 void Disable(Texture2D* pTexture, UInt unit = 0);
 PdrTexture2D* GetResource(const Texture2D* pTexture);


 void Enable(Material* pMaterial);
 void Disable(Material* pMaterial);




 Bool PreDraw(Camera* pCamera = __null);
 void PostDraw();


 void SetCamera(Camera* pCamera);
 void OnFrameChange();
 void OnViewportChange();


 void Resize(UInt width, UInt height);


 void SetClearColor(const ColorRGBA& rClearColor);
 void ClearBuffers();
 void DisplayBackBuffer();


 void SetState(StateAlpha* pState);
 void SetState(StateCull* pState);
 void SetState(StateFog* pState);
 void SetState(StateMaterial* pState);
 void SetState(StateWireframe* pState);
 void SetState(StateZBuffer* pState);
 inline const StateAlpha* GetStateAlpha() const;
 inline const StateCull* GetStateCull() const;
 inline const StateFog* GetStateFog() const;
 inline const StateMaterial* GetStateMaterial() const;
 inline const StateWireframe* GetStateWireframe() const;
 inline const StateZBuffer* GetStateZBuffer() const;


 void SetLight(const Light* pLight, UInt unit = 0);
 void Enable(const TArray<Pointer<Light> >& rLights);
 void Disable(const TArray<Pointer<Light> >& rLights);
 void EnableLighting();
 void DisableLighting();

 inline PdrRendererData* GetRendererData() const;

private:
 void SetBlendMode(Material::BlendMode blendMode, UInt unit = 0,
  Bool hasAlpha = true);


 void DrawElements(Geometry* pGeometry);


 void SetStates(StatePtr spStates[]);
 void RestoreStates(StatePtr spStates[]);



 void DestroyAllIndexBuffers();
  void DestroyAllTexture2Ds();
 void DestroyAllVertexBuffers();



 void ClearReferences();


 StatePtr mspStates[State::MAX_STATE_TYPE];


 Pointer<Camera> mspCamera;


 ColorRGBA mClearColor;


 UInt mWidth;
 UInt mHeight;


 Float mMaxAnisotropy;
 UInt mMaxTextureStages;
 UInt mMaxLights;

 static Renderer* s_pRenderer;

 friend class PdrRendererData;
 PdrRendererData* mpData;

 typedef THashTable<const IndexBuffer*, PdrIndexBuffer*> IndexBufferMap;
 typedef THashTable<const VertexBuffer*, PdrVertexBuffer*> VertexBufferMap;
 typedef THashTable<const Texture2D*, PdrTexture2D*> Texture2DMap;
 IndexBufferMap mIndexBufferMap;
 VertexBufferMap mVertexBufferMap;
 Texture2DMap mTexture2DMap;
};

# 1 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.inl"
inline UInt Renderer::GetHeight() const
{
 return mHeight;
}


inline UInt Renderer::GetWidth() const
{
 return mWidth;
}


inline Float Renderer::GetMaxAnisotropy() const
{
 return mMaxAnisotropy;
}


inline UInt Renderer::GetMaxTextureStages() const
{
 return mMaxTextureStages;
}


inline PdrRendererData* Renderer::GetRendererData() const
{
 return mpData;
}


inline const ColorRGBA& Renderer::GetClearColor() const
{
 return mClearColor;
}


inline const StateAlpha* Renderer::GetStateAlpha() const
{
 return StaticCast<StateAlpha>(mspStates[State::ALPHA]);
}


inline const StateCull* Renderer::GetStateCull() const
{
 return StaticCast<StateCull>(mspStates[State::CULL]);
}


inline const StateFog* Renderer::GetStateFog() const
{
 return StaticCast<StateFog>(mspStates[State::FOG]);
}


inline const StateMaterial* Renderer::GetStateMaterial() const
{
 return StaticCast<StateMaterial>(mspStates[State::MATERIAL]);
}


inline const StateWireframe* Renderer::GetStateWireframe() const
{
 return StaticCast<StateWireframe>(mspStates[State::WIREFRAME]);
}


inline const StateZBuffer* Renderer::GetStateZBuffer() const
{
 return StaticCast<StateZBuffer>(mspStates[State::ZBUFFER]);
}
# 197 "/home/pete/code/wire3d/Wire/Engine/WireRenderer.h" 2

}
# 31 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2




# 1 "/home/pete/code/wire3d/Wire/Engine/WireSphereBV.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireSphereBV.h"
       




# 1 "/home/pete/code/wire3d/Wire/Foundation/WireSphere3.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireSphere3.h"
       





namespace Wire
{

template <class Real>
class Sphere3
{
public:



 Sphere3();
 Sphere3(const Vector3<Real>& rCenter, Real radius);
 Sphere3(const Sphere3& rSphere);


 Sphere3& operator= (const Sphere3& rSphere);


 static Sphere3 MergeSpheres(const Sphere3& rSphere0, const Sphere3& rSphere1);

 Vector3<Real> Center;
 Real Radius;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireSphere3.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireSphere3.inl"
template <class Real>
Sphere3<Real>::Sphere3()
{

}

template <class Real>
Sphere3<Real>::Sphere3(const Vector3<Real>& rCenter, Real radius)
 :
 Center(rCenter),
 Radius(radius)
{
}

template <class Real>
Sphere3<Real>::Sphere3(const Sphere3& rSphere)
 :
 Center(rSphere.Center),
 Radius(rSphere.Radius)
{
}

template <class Real>
Sphere3<Real>& Sphere3<Real>::operator= (const Sphere3& rSphere)
{
 Center = rSphere.Center;
 Radius = rSphere.Radius;
 return *this;
}


template <class Real>
Sphere3<Real> Sphere3<Real>::MergeSpheres(const Sphere3<Real>& rSphere0,
 const Sphere3<Real>& rSphere1)
{
 Vector3<Real> centerDiff = rSphere1.Center - rSphere0.Center;
 Real centerDiffLenSqr = centerDiff.SquaredLength();
 Real radiusDiff = rSphere1.Radius - rSphere0.Radius;
 Real radiusDiffSqr = radiusDiff * radiusDiff;

 if (radiusDiffSqr >= centerDiffLenSqr)
 {
  return (radiusDiff >= static_cast<Real>(0.0) ? rSphere1 : rSphere0);
 }

 Real length = Math<Real>::Sqrt(centerDiffLenSqr);
 Sphere3<Real> sphere;

 if (length > Math<Real>::ZERO_TOLERANCE)
 {
  Real coeff = (length + radiusDiff)/((static_cast<Real>(2.0))*length);
  sphere.Center = rSphere0.Center + coeff*centerDiff;
 }
 else
 {
  sphere.Center = rSphere0.Center;
 }

 sphere.Radius = (static_cast<Real>(0.5))*(length + rSphere0.Radius +
  rSphere1.Radius);

 return sphere;
}
# 40 "/home/pete/code/wire3d/Wire/Foundation/WireSphere3.h" 2

typedef Sphere3<Float> Sphere3F;
typedef Sphere3<Double> Sphere3D;

}
# 15 "/home/pete/code/wire3d/Wire/Engine/WireSphereBV.h" 2

namespace Wire
{

class SphereBV : public BoundingVolume
{
 public: static const Rtti TYPE; inline virtual const Rtti& GetType() const { return TYPE; };

public:
 SphereBV();
 SphereBV(const Sphere3F& rSphere);
 virtual ~SphereBV();


 inline virtual void SetCenter(const Vector3F& rCenter);
 inline virtual void SetRadius(Float radius);
 inline virtual Vector3F GetCenter() const;
 inline virtual Float GetRadius() const;

 inline Sphere3F& Sphere();
 inline const Sphere3F& GetSphere() const;


 virtual void ComputeFromData(const VertexBuffer* pVBuffer);


 virtual void TransformBy(const Transformation& rTransform,
  BoundingVolume* pResult);






 virtual Int WhichSide(const Plane3F& rPlane) const;


 virtual void CopyFrom(const BoundingVolume* pInput);



 virtual void GrowToContain(const BoundingVolume* pInput);

protected:
 Sphere3F mSphere;
};

typedef Pointer<SphereBV> SphereBVPtr;
# 1 "/home/pete/code/wire3d/Wire/Engine/WireSphereBV.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Engine/WireSphereBV.inl"
inline void SphereBV::SetCenter(const Vector3F& rCenter)
{
 mSphere.Center = rCenter;
}


inline void SphereBV::SetRadius(Float radius)
{
 mSphere.Radius = radius;
}


inline Vector3F SphereBV::GetCenter() const
{
 return mSphere.Center;
}


inline Float SphereBV::GetRadius() const
{
 return mSphere.Radius;
}


inline Sphere3F& SphereBV::Sphere()
{
 return mSphere;
}


inline const Sphere3F& SphereBV::GetSphere() const
{
 return mSphere;
}
# 64 "/home/pete/code/wire3d/Wire/Engine/WireSphereBV.h" 2

}
# 36 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 1 "/home/pete/code/wire3d/Wire/Engine/WireStandardMesh.h" 1
# 9 "/home/pete/code/wire3d/Wire/Engine/WireStandardMesh.h"
       







namespace Wire
{

class Geometry;

class StandardMesh
{
 public: static Bool RegisterTerminate(); static void Terminate(); private: static Bool s_TerminateRegistered;

public:







 static Geometry* CreateCube8(const UInt vertexColorChannels = 0,
  const Bool useNormals = false, const Float extent = 1.0F);


  static Geometry* CreateCube14(const UInt vertexColorChannels = 0,
   const UInt uvQuantity = 0, const Bool useNormals = false,
  const Float extent = 1.0F);


 static Geometry* CreateCube24(const UInt vertexColorChannels = 0,
  const UInt uvQuantity = 0, const Bool useNormals = false,
  const Float extent = 1.0F);


 static Geometry* CreatePlane(const UInt xTileCount, const UInt yTileCount,
  const Float xTotalSize, const Float yTotalSize,
  const UInt vertexColorChannels = 0,
  const UInt uvQuantity = 0, const Bool useNormals = false);


 static Geometry* CreateQuad(const UInt vertexColorChannels = 0,
  const UInt uvQuantity = 0, const Bool useNormals = false,
  const Float extent = 1.0F);


 static Geometry* CreateSphere(Int zSampleCount, Int radialSampleCount,
  Float radius, const UInt uvQuantity = 0,
  const UInt vertexColorChannels = 0, const Bool useNormals = false);

 static Geometry* CreateText(const Char* pText, const Float screenWidth,
  const Float screenHeight);

private:
 static Texture2DPtr s_spFontTexture;
 static const UChar s_Font[];
};

static Bool gs_TerminateRegisteredStandardMesh = StandardMesh::RegisterTerminate();

}
# 37 "/home/pete/code/wire3d/Wire/Engine/WireEngine.h" 2
# 14 "/home/pete/code/wire3d/Wire/Foundation/WireApplication.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h"
       




# 1 "/home/pete/code/wire3d/Wire/Foundation/WireBox3.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireBox3.h"
       





namespace Wire
{

template <class Real>
class Box3
{
public:






 Box3();
  Box3(const Vector3<Real>& rCenter, const Vector3<Real>* pAxis,
  const Real* pExtent);
  Box3(const Vector3<Real>& rCenter, const Vector3<Real>& rAxis0,
   const Vector3<Real>& rAxis1, const Vector3<Real>& rAxis2,
   Real extent0, Real extent1, Real extent2);

  void ComputeVertices(Vector3<Real> vertices[8]) const;

  Vector3<Real> Center;
  Vector3<Real> Axis[3];
  Real Extent[3];
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireBox3.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireBox3.inl"
template <class Real>
Box3<Real>::Box3()
{

}


template <class Real>
Box3<Real>::Box3(const Vector3<Real>& rCenter, const Vector3<Real>* pAxis,
 const Real* pExtent)
 :
 Center(rCenter)
{
 for (UInt i = 0; i < 3; i++)
 {
  Axis[i] = pAxis[i];
  Extent[i] = pExtent[i];
  ;
 }
}


template <class Real>
Box3<Real>::Box3(const Vector3<Real>& rCenter, const Vector3<Real>& rAxis0,
 const Vector3<Real>& rAxis1, const Vector3<Real>& rAxis2, Real extent0,
 Real extent1, Real extent2)
 :
 Center(rCenter)
{
 Axis[0] = rAxis0;
 Axis[1] = rAxis1;
 Axis[2] = rAxis2;
 Extent[0] = extent0;
 Extent[1] = extent1;
 Extent[2] = extent2;

 ;
 ;
 ;
}


template <class Real>
void Box3<Real>::ComputeVertices(Vector3<Real> vertices[8]) const
{
 Vector3<Real> axes[3] =
 {
  Extent[0]*Axis[0],
  Extent[1]*Axis[1],
  Extent[2]*Axis[2]
 };

 vertices[0] = Center - axes[0] - axes[1] - axes[2];
 vertices[1] = Center + axes[0] - axes[1] - axes[2];
 vertices[2] = Center + axes[0] + axes[1] - axes[2];
 vertices[3] = Center - axes[0] + axes[1] - axes[2];
 vertices[4] = Center - axes[0] - axes[1] + axes[2];
 vertices[5] = Center + axes[0] - axes[1] + axes[2];
 vertices[6] = Center + axes[0] + axes[1] + axes[2];
 vertices[7] = Center - axes[0] + axes[1] + axes[2];
}
# 43 "/home/pete/code/wire3d/Wire/Foundation/WireBox3.h" 2

typedef Box3<Float> Box3F;
typedef Box3<Double> Box3D;

}
# 15 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2




# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix2.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix2.h"
       
# 32 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix2.h"
namespace Wire
{

template <class Real>
class Matrix2
{
public:
 Matrix2();



 Matrix2(Bool zero);


 Matrix2(Real m00, Real m01, Real m10, Real m11);


 Matrix2(const Vector2<Real>& rU, const Vector2<Real>& rV, Bool isColumn);



 Matrix2(Real angle);


 void MakeZero ();
 void MakeIdentity ();
 void FromAngle(Real angle);


 inline operator const Real* () const;
 inline operator Real* ();
 inline const Real* operator[] (Int row) const;
 inline Real* operator[] (Int row);
 inline Real operator() (UInt row, UInt col) const;
 inline Real& operator() (UInt row, UInt col);
 void SetRow(UInt row, const Vector2<Real>& rV);
 Vector2<Real> GetRow(UInt row) const;
 void SetColumn(UInt col, const Vector2<Real>& rV);
 Vector2<Real> GetColumn (UInt col) const;


 inline Matrix2 operator* (const Matrix2& rM) const;
 inline Matrix2 operator* (Real scalar) const;


 inline Vector2<Real> operator* (const Vector2<Real>& rV) const;


 Matrix2 Transpose() const;
 Matrix2 TransposeTimes(const Matrix2& rM) const;
 Matrix2 TimesTranspose(const Matrix2& rM) const;
 Matrix2 Inverse() const;


 static const Matrix2 ZERO;
 static const Matrix2 IDENTITY;

private:
 Real mEntry[4];
};


template <class Real>
inline Matrix2<Real> operator* (Real scalar, const Matrix2<Real>& rM);


template <class Real>
inline Vector2<Real> operator* (const Vector2<Real>& rV,
 const Matrix2<Real>& rM);

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix2.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix2.inl"
template <class Real>
Matrix2<Real>::Matrix2()
{

}


template <class Real>
Matrix2<Real>::Matrix2(Bool zero)
{
 if (zero)
 {
  MakeZero();
 }
 else
 {
  MakeIdentity();
 }
}


template <class Real>
Matrix2<Real>::Matrix2(Real m00, Real m01, Real m10, Real m11)
{
 mEntry[0] = m00;
 mEntry[1] = m01;
 mEntry[2] = m10;
 mEntry[3] = m11;
}


template <class Real>
Matrix2<Real>::Matrix2(const Vector2<Real>& rU, const Vector2<Real>& rV,
 Bool isColumn)
{
 if (isColumn)
 {
  mEntry[0] = rU[0];
  mEntry[1] = rV[0];
  mEntry[2] = rU[1];
  mEntry[3] = rV[1];
 }
 else
 {
  mEntry[0] = rU[0];
  mEntry[1] = rU[1];
  mEntry[2] = rV[0];
  mEntry[3] = rV[1];
 }
}


template <class Real>
Matrix2<Real>::Matrix2(Real angle)
{
 FromAngle(angle);
}


template <class Real>
void Matrix2<Real>::MakeZero()
{
 mEntry[0] = static_cast<Real>(0.0);
 mEntry[1] = static_cast<Real>(0.0);
 mEntry[2] = static_cast<Real>(0.0);
 mEntry[3] = static_cast<Real>(0.0);
}


template <class Real>
void Matrix2<Real>::MakeIdentity()
{
 mEntry[0] = static_cast<Real>(1.0);
 mEntry[1] = static_cast<Real>(0.0);
 mEntry[2] = static_cast<Real>(0.0);
 mEntry[3] = static_cast<Real>(1.0);
}


template <class Real>
void Matrix2<Real>::FromAngle(Real angle)
{
 mEntry[0] = Math<Real>::Cos(angle);
 mEntry[2] = Math<Real>::Sin(angle);
 mEntry[1] = -mEntry[2];
 mEntry[3] = mEntry[0];
}


template <class Real>
inline Matrix2<Real>::operator const Real* () const
{
 return mEntry;
}


template <class Real>
inline Matrix2<Real>::operator Real* ()
{
 return mEntry;
}


template <class Real>
inline const Real* Matrix2<Real>::operator[] (Int row) const
{
 return &mEntry[2 * row];
}


template <class Real>
inline Real* Matrix2<Real>::operator[] (Int row)
{
 return &mEntry[2 * row];
}


template <class Real>
inline Real Matrix2<Real>::operator() (UInt row, UInt col) const
{
 return mEntry[col + 2*row];
}


template <class Real>
inline Real& Matrix2<Real>::operator() (UInt row, UInt col)
{
 return mEntry[col + 2*row];
}


template <class Real>
void Matrix2<Real>::SetRow(UInt row, const Vector2<Real>& rkV)
{
 mEntry[2*row] = rkV[0];
 mEntry[2*row+1] = rkV[1];
}


template <class Real>
Vector2<Real> Matrix2<Real>::GetRow(UInt row) const
{
 return Vector2<Real>(mEntry[2*row], mEntry[2*row+1]);
}


template <class Real>
void Matrix2<Real>::SetColumn(UInt iCol, const Vector2<Real>& rV)
{
 mEntry[iCol] = rV[0];
 mEntry[iCol+2] = rV[1];
}


template <class Real>
Vector2<Real> Matrix2<Real>::GetColumn(UInt col) const
{
 return Vector2<Real>(mEntry[col], mEntry[col+2]);
}


template <class Real>
inline Matrix2<Real> Matrix2<Real>::operator* (const Matrix2& rM) const
{
 return Matrix2<Real>(
  mEntry[0] * rM.mEntry[0] + mEntry[1] * rM.mEntry[2],
  mEntry[0] * rM.mEntry[1] + mEntry[1] * rM.mEntry[3],
  mEntry[2] * rM.mEntry[0] + mEntry[3] * rM.mEntry[2],
  mEntry[2] * rM.mEntry[1] + mEntry[3] * rM.mEntry[3]);
}


template <class Real>
inline Matrix2<Real> Matrix2<Real>::operator* (Real scalar) const
{
 return Matrix2<Real>(
  scalar * mEntry[0],
  scalar * mEntry[1],
  scalar * mEntry[2],
  scalar * mEntry[3]);
}


template <class Real>
inline Vector2<Real> Matrix2<Real>::operator* (const Vector2<Real>& rV) const
{
 return Vector2<Real>(
  mEntry[0] * rV[0] + mEntry[1] * rV[1],
  mEntry[2] * rV[0] + mEntry[3] * rV[1]);
}


template <class Real>
Matrix2<Real> Matrix2<Real>::Transpose() const
{
 return Matrix2<Real>(
  mEntry[0],
  mEntry[2],
  mEntry[1],
  mEntry[3]);
}


template <class Real>
Matrix2<Real> Matrix2<Real>::TransposeTimes(const Matrix2& rM) const
{

 return Matrix2<Real>(
  mEntry[0] * rM.mEntry[0] + mEntry[2] * rM.mEntry[2],
  mEntry[0] * rM.mEntry[1] + mEntry[2] * rM.mEntry[3],
  mEntry[1] * rM.mEntry[0] + mEntry[3] * rM.mEntry[2],
  mEntry[1] * rM.mEntry[1] + mEntry[3] * rM.mEntry[3]);
}


template <class Real>
Matrix2<Real> Matrix2<Real>::TimesTranspose(const Matrix2& rM) const
{

 return Matrix2<Real>(
  mEntry[0] * rM.mEntry[0] + mEntry[1] * rM.mEntry[1],
  mEntry[0] * rM.mEntry[2] + mEntry[1] * rM.mEntry[3],
  mEntry[2] * rM.mEntry[0] + mEntry[3] * rM.mEntry[1],
  mEntry[2] * rM.mEntry[2] + mEntry[3] * rM.mEntry[3]);
}


template <class Real>
Matrix2<Real> Matrix2<Real>::Inverse() const
{
 Matrix2<Real> inverse;

 Real det = mEntry[0] * mEntry[3] - mEntry[1] * mEntry[2];
 if (Math<Real>::FAbs(det) > Math<Real>::ZERO_TOLERANCE)
 {
  Real invDet = static_cast<Real>(1.0) / det;
  inverse.mEntry[0] = mEntry[3] * invDet;
  inverse.mEntry[1] = -mEntry[1] * invDet;
  inverse.mEntry[2] = -mEntry[2] * invDet;
  inverse.mEntry[3] = mEntry[0] * invDet;
 }
 else
 {
  inverse.mEntry[0] = static_cast<Real>(0.0);
  inverse.mEntry[1] = static_cast<Real>(0.0);
  inverse.mEntry[2] = static_cast<Real>(0.0);
  inverse.mEntry[3] = static_cast<Real>(0.0);
 }

 return inverse;
}


template <class Real>
inline Matrix2<Real> operator* (Real scalar, const Matrix2<Real>& rM)
{
 return rM * scalar;
}


template <class Real>
inline Vector2<Real> operator* (const Vector2<Real>& rV,
 const Matrix2<Real>& rM)
{
 return Vector2<Real>(
  rV[0] * rM[0][0] + rV[1] * rM[1][0],
  rV[0] * rM[0][1] + rV[1] * rM[1][1]);
}
# 103 "/home/pete/code/wire3d/Wire/Foundation/WireMatrix2.h" 2

typedef Matrix2<Float> Matrix2F;
typedef Matrix2<Double> Matrix2D;

}
# 20 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2




# 1 "/home/pete/code/wire3d/Wire/Foundation/WireNoisePerlin.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireNoisePerlin.h"
       






namespace Wire
{


class NoisePerlinBase
{
 public: static Bool RegisterInitialize(); static void Initialize(); private: static Bool s_InitializeRegistered;

protected:
 static const Int s_Permutation[];
 static Int s_P[];
};

static Bool gs_InitializeRegisteredNoisePerlinBase = NoisePerlinBase::RegisterInitialize();


template <typename Real>
class NoisePerlin : public NoisePerlinBase
{
public:
 Real Noise(Real x, Real y);
 Real Noise(Real x, Real y, Real z);

private:
 Real Fade(Real t);
 Real Grad(Int hash, Real x, Real y, Real z);
 inline Real Lerp(Real t, Real a, Real b);
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireNoisePerlin.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireNoisePerlin.inl"
template <typename Real>
Real NoisePerlin<Real>::Noise(Real x, Real y)
{
 Int X = static_cast<Int>(Math<Real>::Floor(x)) & 255;
 Int Y = static_cast<Int>(Math<Real>::Floor(y)) & 255;
 x -= Math<Real>::Floor(x);
 y -= Math<Real>::Floor(y);
 Real u = Fade(x);
 Real v = Fade(y);
 Int A = s_P[X] + Y;
 Int AA = s_P[A];
 Int AB = s_P[A+1];
 Int B = s_P[X+1] + Y;
 Int BA = s_P[B];
 Int BB = s_P[B+1];

 return Lerp(v, Lerp(u, Grad(s_P[AA], x, y, 0),
                     Grad(s_P[BA], x-1, y, 0)),
             Lerp(u, Grad(s_P[AB], x, y-1, 0),
                     Grad(s_P[BB], x-1, y-1, 0)));
}


template <typename Real>
Real NoisePerlin<Real>::Noise(Real x, Real y, Real z)
{
 Int X = static_cast<Int>(Math<Real>::Floor(x)) & 255;
 Int Y = static_cast<Int>(Math<Real>::Floor(y)) & 255;
 Int Z = static_cast<Int>(Math<Real>::Floor(z)) & 255;
 x -= Math<Real>::Floor(x);
 y -= Math<Real>::Floor(y);
 z -= Math<Real>::Floor(z);
 Real u = Fade(x);
 Real v = Fade(y);
 Real w = Fade(z);
 Int A = s_P[X] + Y;
 Int AA = s_P[A] + Z;
 Int AB = s_P[A+1] + Z;
 Int B = s_P[X+1] + Y;
 Int BA = s_P[B] + Z;
 Int BB = s_P[B+1] + Z;

 return Lerp(w, Lerp(v, Lerp(u, Grad(s_P[AA], x, y, z),
                                   Grad(s_P[BA], x-1, y, z)),
                           Lerp(u, Grad(s_P[AB], x, y-1, z),
                                   Grad(s_P[BB], x-1, y-1, z))),
                   Lerp(v, Lerp(u, Grad(s_P[AA+1], x, y, z-1 ),
                                   Grad(s_P[BA+1], x-1, y, z-1)),
                           Lerp(u, Grad(s_P[AB+1], x, y-1, z-1),
                                   Grad(s_P[BB+1], x-1, y-1, z-1))));
}


template <typename Real>
Real NoisePerlin<Real>::Fade(Real t)
{
 return t * t * t * (t * (t * 6 - 15) + 10);
}


template <typename Real>
Real NoisePerlin<Real>::Lerp(Real t, Real a, Real b)
{
 return a + t * (b - a);
}


template <typename Real>
Real NoisePerlin<Real>::Grad(Int hash, Real x, Real y, Real z)
{
 Int h = hash & 15;
 Real u = h < 8 ? x : y;
 Real v = h < 4 ? y : h==12||h==14 ? x : z;
 return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
}
# 46 "/home/pete/code/wire3d/Wire/Foundation/WireNoisePerlin.h" 2

typedef NoisePerlin<Float> NoisePerlinF;
typedef NoisePerlin<Double> NoisePerlinD;

}
# 25 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireQuaternion.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireQuaternion.h"
       






namespace Wire
{

template <class Real>
class Quaternion
{
public:




 Quaternion();
 Quaternion(Real w, Real x, Real y, Real z);
 Quaternion(const Quaternion& rQ);


  Quaternion(const Matrix3<Real>& rRot);


  Quaternion(const Vector3<Real>& rAxis, Real angle);


  Quaternion(const Vector3<Real> rotColumns[3]);


 inline operator const Real* () const;
 inline operator Real* ();
 inline Real operator[] (UInt i) const;
 inline Real& operator[] (UInt i);
 inline Real W() const;
 inline Real& W();
 inline Real X() const;
 inline Real& X();
 inline Real Y() const;
 inline Real& Y();
 inline Real Z() const;
 inline Real& Z();


 inline Quaternion& operator= (const Quaternion& rQ);


 inline Bool operator== (const Quaternion& rQ) const;
 inline Bool operator!= (const Quaternion& rQ) const;


 inline Quaternion operator+ (const Quaternion& rQ) const;
 inline Quaternion operator- (const Quaternion& rQ) const;
 inline Quaternion operator* (const Quaternion& rQ) const;
 inline Quaternion operator* (Real scalar) const;
 inline Quaternion operator/ (Real scalar) const;
 inline Quaternion operator- () const;


 inline Quaternion& operator+= (const Quaternion& rQ);
 inline Quaternion& operator-= (const Quaternion& rQ);
 inline Quaternion& operator*= (Real scalar);
 inline Quaternion& operator/= (Real scalar);


 Quaternion& FromRotationMatrix(const Matrix3<Real>& rRot);
 void ToRotationMatrix(Matrix3<Real>& rRot) const;
 Quaternion& FromAxisAngle(const Vector3<Real>& rAxis, Real angle);
 void ToAxisAngle(Vector3<Real>& rAxis, Real& rAngle) const;


 inline Real Length() const;
 inline Real SquaredLength() const;
 inline Real Dot(const Quaternion& rQ) const;
 inline Real Normalize();
 Quaternion Inverse() const;
 Quaternion Conjugate() const;
 Quaternion Exp() const;
 Quaternion Log() const;


 Vector3<Real> Rotate(const Vector3<Real>& rVector) const;


 Quaternion& Slerp(Real t, const Quaternion& rP, const Quaternion& rQ);

 static const Quaternion IDENTITY;
 static const Quaternion ZERO;

private:
 Real mTuple[4];
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireQuaternion.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireQuaternion.inl"
template <class Real>
Quaternion<Real>::Quaternion()
{

}


template <class Real>
Quaternion<Real>::Quaternion(Real w, Real x, Real y, Real z)
{
 mTuple[0] = w;
 mTuple[1] = x;
 mTuple[2] = y;
 mTuple[3] = z;
}


template <class Real>
Quaternion<Real>::Quaternion(const Quaternion& rQ)
{
 mTuple[0] = rQ.mTuple[0];
 mTuple[1] = rQ.mTuple[1];
 mTuple[2] = rQ.mTuple[2];
 mTuple[3] = rQ.mTuple[3];
}


template <class Real>
Quaternion<Real>::Quaternion(const Matrix3<Real>& rRot)
{
 FromRotationMatrix(rRot);
}


template <class Real>
Quaternion<Real>::Quaternion(const Vector3<Real>& rAxis, Real angle)
{
 FromAxisAngle(rAxis, angle);
}


template <class Real>
Quaternion<Real>::Quaternion(const Vector3<Real> rotColumns[3])
{
 FromRotationMatrix(rotColumns);
}


template <class Real>
inline Quaternion<Real>::operator const Real* () const
{
 return mTuple;
}


template <class Real>
inline Quaternion<Real>::operator Real* ()
{
 return mTuple;
}


template <class Real>
inline Real Quaternion<Real>::operator[] (UInt i) const
{
 return mTuple[i];
}


template <class Real>
inline Real& Quaternion<Real>::operator[] (UInt i)
{
 return mTuple[i];
}


template <class Real>
inline Real Quaternion<Real>::W() const
{
 return mTuple[0];
}


template <class Real>
inline Real& Quaternion<Real>::W()
{
 return mTuple[0];
}


template <class Real>
inline Real Quaternion<Real>::X() const
{
 return mTuple[1];
}


template <class Real>
inline Real& Quaternion<Real>::X()
{
 return mTuple[1];
}


template <class Real>
inline Real Quaternion<Real>::Y() const
{
 return mTuple[2];
}


template <class Real>
inline Real& Quaternion<Real>::Y()
{
 return mTuple[2];
}


template <class Real>
inline Real Quaternion<Real>::Z() const
{
 return mTuple[3];
}


template <class Real>
inline Real& Quaternion<Real>::Z()
{
 return mTuple[3];
}


template <class Real>
inline Quaternion<Real>& Quaternion<Real>::operator= (const Quaternion& rQ)
{
 mTuple[0] = rQ.mTuple[0];
 mTuple[1] = rQ.mTuple[1];
 mTuple[2] = rQ.mTuple[2];
 mTuple[3] = rQ.mTuple[3];
 return *this;
}


template <class Real>
inline Bool Quaternion<Real>::operator== (const Quaternion& rQ) const
{
 return (
  mTuple[0] == rQ.mTuple[0] &&
  mTuple[1] == rQ.mTuple[1] &&
  mTuple[2] == rQ.mTuple[2] &&
  mTuple[3] == rQ.mTuple[3]);
}


template <class Real>
inline Bool Quaternion<Real>::operator!= (const Quaternion& rQ) const
{
 return !(
  mTuple[0] == rQ.mTuple[0] &&
  mTuple[1] == rQ.mTuple[1] &&
  mTuple[2] == rQ.mTuple[2] &&
  mTuple[3] == rQ.mTuple[3]);
}


template <class Real>
inline Quaternion<Real> Quaternion<Real>::operator+ (const Quaternion& rQ)
 const
{
 return Quaternion(
  mTuple[0] + rQ.mTuple[0],
  mTuple[1] + rQ.mTuple[1],
  mTuple[2] + rQ.mTuple[2],
  mTuple[3] + rQ.mTuple[3]);
}


template <class Real>
inline Quaternion<Real> Quaternion<Real>::operator- (const Quaternion& rQ)
 const
{
 return Quaternion(
  mTuple[0] - rQ.mTuple[0],
  mTuple[1] - rQ.mTuple[1],
  mTuple[2] - rQ.mTuple[2],
  mTuple[3] - rQ.mTuple[3]);
}


template <class Real>
inline Quaternion<Real> Quaternion<Real>::operator* (const Quaternion& rQ)
 const
{


 Quaternion prod;

 prod.mTuple[0] =
  mTuple[0] * rQ.mTuple[0] -
  mTuple[1] * rQ.mTuple[1] -
  mTuple[2] * rQ.mTuple[2] -
  mTuple[3] * rQ.mTuple[3];

 prod.mTuple[1] =
  mTuple[0] * rQ.mTuple[1] +
  mTuple[1] * rQ.mTuple[0] +
  mTuple[2] * rQ.mTuple[3] -
  mTuple[3] * rQ.mTuple[2];

 prod.mTuple[2] =
  mTuple[0] * rQ.mTuple[2] +
  mTuple[2] * rQ.mTuple[0] +
  mTuple[3] * rQ.mTuple[1] -
  mTuple[1] * rQ.mTuple[3];

 prod.mTuple[3] =
  mTuple[0] * rQ.mTuple[3] +
  mTuple[3] * rQ.mTuple[0] +
  mTuple[1] * rQ.mTuple[2] -
  mTuple[2] * rQ.mTuple[1];

 return prod;
}


template <class Real>
inline Quaternion<Real> Quaternion<Real>::operator* (Real scalar) const
{
 return Quaternion(
  scalar * mTuple[0],
  scalar * mTuple[1],
  scalar * mTuple[2],
  scalar * mTuple[3]);
}


template <class Real>
inline Quaternion<Real> Quaternion<Real>::operator/ (Real scalar) const
{
 Quaternion quot;

 if (scalar != static_cast<Real>(0.0))
 {
  Real invScalar = (static_cast<Real>(1.0))/scalar;
  quot.mTuple[0] = invScalar * mTuple[0];
  quot.mTuple[1] = invScalar * mTuple[1];
  quot.mTuple[2] = invScalar * mTuple[2];
  quot.mTuple[3] = invScalar * mTuple[3];
 }
 else
 {
  quot.mTuple[0] = Math<Real>::MAX_REAL;
  quot.mTuple[1] = Math<Real>::MAX_REAL;
  quot.mTuple[2] = Math<Real>::MAX_REAL;
  quot.mTuple[3] = Math<Real>::MAX_REAL;
 }

 return quot;
}


template <class Real>
inline Quaternion<Real> Quaternion<Real>::operator- () const
{
 return Quaternion(-mTuple[0], -mTuple[1], -mTuple[2], -mTuple[3]);
}


template <class Real>
inline Quaternion<Real>& Quaternion<Real>::operator+= (const Quaternion& rQ)
{
 mTuple[0] += rQ.mTuple[0];
 mTuple[1] += rQ.mTuple[1];
 mTuple[2] += rQ.mTuple[2];
 mTuple[3] += rQ.mTuple[3];

 return *this;
}


template <class Real>
inline Quaternion<Real>& Quaternion<Real>::operator-= (const Quaternion& rQ)
{
 mTuple[0] -= rQ.mTuple[0];
 mTuple[1] -= rQ.mTuple[1];
 mTuple[2] -= rQ.mTuple[2];
 mTuple[3] -= rQ.mTuple[3];

 return *this;
}


template <class Real>
inline Quaternion<Real>& Quaternion<Real>::operator*= (Real scalar)
{
 mTuple[0] *= scalar;
 mTuple[1] *= scalar;
 mTuple[2] *= scalar;
 mTuple[3] *= scalar;

 return *this;
}


template <class Real>
inline Quaternion<Real>& Quaternion<Real>::operator/= (Real scalar)
{
 if (scalar != static_cast<Real>(0.0))
 {
  Real invScalar = (static_cast<Real>(1.0))/scalar;
  mTuple[0] *= invScalar;
  mTuple[1] *= invScalar;
  mTuple[2] *= invScalar;
  mTuple[3] *= invScalar;
 }
 else
 {
  mTuple[0] = Math<Real>::MAX_REAL;
  mTuple[1] = Math<Real>::MAX_REAL;
  mTuple[2] = Math<Real>::MAX_REAL;
  mTuple[3] = Math<Real>::MAX_REAL;
 }

 return *this;
}


template <class Real>
Quaternion<Real>& Quaternion<Real>::FromRotationMatrix(
 const Matrix3<Real>& rRot)
{



 Real trace = rRot(0,0) + rRot(1,1) + rRot(2,2);
 Real root;

 if (trace > static_cast<Real>(0.0))
 {

  root = Math<Real>::Sqrt(trace + static_cast<Real>(1.0));
  mTuple[0] = (static_cast<Real>(0.5))*root;
  root = (static_cast<Real>(0.5))/root;
  mTuple[1] = (rRot(2,1)-rRot(1,2))*root;
  mTuple[2] = (rRot(0,2)-rRot(2,0))*root;
  mTuple[3] = (rRot(1,0)-rRot(0,1))*root;
 }
 else
 {

  Int i = 0;
  if (rRot(1,1) > rRot(0,0))
  {
   i = 1;
  }

  if (rRot(2,2) > rRot(i,i))
  {
   i = 2;
  }

  static const UInt s_next[3] = { 1, 2, 0 };
  UInt j = s_next[i];
  UInt k = s_next[j];

  root = Math<Real>::Sqrt(rRot(i,i)-rRot(j,j)-rRot(k,k)+
   static_cast<Real>(1.0));
  Real* pQuat[3] = { &mTuple[1], &mTuple[2], &mTuple[3] };
  *pQuat[i] = (static_cast<Real>(0.5))*root;
  root = (static_cast<Real>(0.5))/root;
  mTuple[0] = (rRot(k,j)-rRot(j,k))*root;
  *pQuat[j] = (rRot(j,i)+rRot(i,j))*root;
  *pQuat[k] = (rRot(k,i)+rRot(i,k))*root;
 }

 return *this;
}


template <class Real>
void Quaternion<Real>::ToRotationMatrix(Matrix3<Real>& rRot) const
{
 Real tx = static_cast<Real>(2.0) * mTuple[1];
 Real ty = static_cast<Real>(2.0) * mTuple[2];
 Real tz = static_cast<Real>(2.0) * mTuple[3];
 Real twx = tx * mTuple[0];
 Real twy = ty * mTuple[0];
 Real twz = tz * mTuple[0];
 Real txx = tx * mTuple[1];
 Real txy = ty * mTuple[1];
 Real txz = tz * mTuple[1];
 Real tyy = ty * mTuple[2];
 Real tyz = tz * mTuple[2];
 Real tzz = tz * mTuple[3];

 rRot(0,0) = static_cast<Real>(1.0) - (tyy + tzz);
 rRot(0,1) = txy - twz;
 rRot(0,2) = txz + twy;
 rRot(1,0) = txy + twz;
 rRot(1,1) = static_cast<Real>(1.0) - (txx + tzz);
 rRot(1,2) = tyz - twx;
 rRot(2,0) = txz - twy;
 rRot(2,1) = tyz + twx;
 rRot(2,2) = static_cast<Real>(1.0) - (txx + tyy);
}


template <class Real>
Quaternion<Real>& Quaternion<Real>::FromAxisAngle(const Vector3<Real>& rAxis,
 Real angle)
{


                                                                         ;




 Real halfAngle = (static_cast<Real>(0.5)) * angle;
 Real sin = Math<Real>::Sin(halfAngle);
 mTuple[0] = Math<Real>::Cos(halfAngle);
 mTuple[1] = sin*rAxis[0];
 mTuple[2] = sin*rAxis[1];
 mTuple[3] = sin*rAxis[2];

 return *this;
}


template <class Real>
void Quaternion<Real>::ToAxisAngle(Vector3<Real>& rAxis, Real& rAngle) const
{



 Real sqrLength = mTuple[1]*mTuple[1] + mTuple[2]*mTuple[2] +
  mTuple[3]*mTuple[3];

 if (sqrLength > Math<Real>::ZERO_TOLERANCE)
 {
  rAngle = (static_cast<Real>(2.0)) * Math<Real>::ACos(mTuple[0]);
  Real invLength = Math<Real>::InvSqrt(sqrLength);
  rAxis[0] = mTuple[1] * invLength;
  rAxis[1] = mTuple[2] * invLength;
  rAxis[2] = mTuple[3] * invLength;
 }
 else
 {

  rAngle = static_cast<Real>(0.0);
  rAxis[0] = static_cast<Real>(1.0);
  rAxis[1] = static_cast<Real>(0.0);
  rAxis[2] = static_cast<Real>(0.0);
 }
}


template <class Real>
inline Real Quaternion<Real>::Length() const
{
 return Math<Real>::Sqrt(
  mTuple[0] * mTuple[0] +
  mTuple[1] * mTuple[1] +
  mTuple[2] * mTuple[2] +
  mTuple[3] * mTuple[3]);
}


template <class Real>
inline Real Quaternion<Real>::SquaredLength() const
{
 return
  mTuple[0] * mTuple[0] +
  mTuple[1] * mTuple[1] +
  mTuple[2] * mTuple[2] +
  mTuple[3] * mTuple[3];
}


template <class Real>
inline Real Quaternion<Real>::Dot(const Quaternion& rQ) const
{
 Real dot = mTuple[0] * rQ.mTuple[0];
 dot += (mTuple[1] * rQ.mTuple[1]);
 dot += (mTuple[2] * rQ.mTuple[2]);
 dot += (mTuple[3] * rQ.mTuple[3]);

 return dot;
}


template <class Real>
inline Real Quaternion<Real>::Normalize()
{
 Real length = Length();

 if (length > Math<Real>::ZERO_TOLERANCE)
 {
  Real invLength = (static_cast<Real>(1.0))/length;
  mTuple[0] *= invLength;
  mTuple[1] *= invLength;
  mTuple[2] *= invLength;
  mTuple[3] *= invLength;
 }
 else
 {
  length = static_cast<Real>(0.0);
  mTuple[0] = static_cast<Real>(0.0);
  mTuple[1] = static_cast<Real>(0.0);
  mTuple[2] = static_cast<Real>(0.0);
  mTuple[3] = static_cast<Real>(0.0);
 }

 return length;
}


template <class Real>
Quaternion<Real> Quaternion<Real>::Inverse() const
{
 Quaternion inverse;

 Real norm = static_cast<Real>(0.0);
 for (UInt i = 0; i < 4; i++)
 {
  norm += mTuple[i] * mTuple[i];
 }

 if (norm > static_cast<Real>(0.0))
 {
  Real invNorm = static_cast<Real>(1.0) / norm;
  inverse.mTuple[0] = mTuple[0] * invNorm;
  inverse.mTuple[1] = -mTuple[1] * invNorm;
  inverse.mTuple[2] = -mTuple[2] * invNorm;
  inverse.mTuple[3] = -mTuple[3] * invNorm;
 }
 else
 {

  inverse.mTuple[0] = static_cast<Real>(0.0);
  inverse.mTuple[1] = static_cast<Real>(0.0);
  inverse.mTuple[2] = static_cast<Real>(0.0);
  inverse.mTuple[3] = static_cast<Real>(0.0);
 }

 return inverse;
}


template <class Real>
Quaternion<Real> Quaternion<Real>::Conjugate() const
{
 return Quaternion(mTuple[0], -mTuple[1], -mTuple[2], -mTuple[3]);
}


template <class Real>
Quaternion<Real> Quaternion<Real>::Exp() const
{




 Quaternion result;

 Real angle = Math<Real>::Sqrt(mTuple[1] * mTuple[1] +
  mTuple[2] * mTuple[2] + mTuple[3] * mTuple[3]);

 Real sin = Math<Real>::Sin(angle);
 result.mTuple[0] = Math<Real>::Cos(angle);

 if (Math<Real>::FAbs(sin) >= Math<Real>::ZERO_TOLERANCE)
 {
  Real coeff = sin / angle;
  result.mTuple[1] = coeff * mTuple[1];
  result.mTuple[2] = coeff * mTuple[2];
  result.mTuple[3] = coeff * mTuple[3];
 }
 else
 {
  result.mTuple[1] = mTuple[1];
  result.mTuple[2] = mTuple[2];
  result.mTuple[3] = mTuple[3];
 }

 return result;
}


template <class Real>
Quaternion<Real> Quaternion<Real>::Log() const
{




 Quaternion result;
 result.mTuple[0] = static_cast<Real>(0.0);

 if (Math<Real>::FAbs(mTuple[0]) < static_cast<Real>(1.0))
 {
  Real angle = Math<Real>::ACos(mTuple[0]);
  Real sin = Math<Real>::Sin(angle);
  if (Math<Real>::FAbs(sin) >= Math<Real>::ZERO_TOLERANCE)
  {
   Real coeff = angle / sin;

   result.mTuple[1] = coeff * mTuple[1];
   result.mTuple[2] = coeff * mTuple[2];
   result.mTuple[3] = coeff * mTuple[3];

   return result;
  }
 }

 result.mTuple[1] = mTuple[1];
 result.mTuple[2] = mTuple[2];
 result.mTuple[3] = mTuple[3];

 return result;
}


template <class Real>
Vector3<Real> Quaternion<Real>::Rotate(const Vector3<Real>& rVector)
const
{
# 655 "/home/pete/code/wire3d/Wire/Foundation/WireQuaternion.inl"
 Matrix3<Real> rot;
 ToRotationMatrix(rot);
 return rot * rVector;
}


template <class Real>
Quaternion<Real>& Quaternion<Real>::Slerp(Real t, const Quaternion& rP,
 const Quaternion& rQ)
{
 Real cos = rP.Dot(rQ);
 Real angle = Math<Real>::ACos(cos);


 if (Math<Real>::FAbs(angle) >= Math<Real>::ZERO_TOLERANCE)
 {
  Real sin = Math<Real>::Sin(angle);
  Real invSin = ((Real)1.0)/sin;
  Real tAngle = t * angle;
  Real coeff0 = Math<Real>::Sin(angle - tAngle) * invSin;
  Real coeff1 = Math<Real>::Sin(tAngle) * invSin;





  mTuple[0] = coeff0 * rP.mTuple[0] + coeff1 * rQ.mTuple[0];
  mTuple[1] = coeff0 * rP.mTuple[1] + coeff1 * rQ.mTuple[1];
  mTuple[2] = coeff0 * rP.mTuple[2] + coeff1 * rQ.mTuple[2];
  mTuple[3] = coeff0 * rP.mTuple[3] + coeff1 * rQ.mTuple[3];
 }
 else
 {
  mTuple[0] = rP.mTuple[0];
  mTuple[1] = rP.mTuple[1];
  mTuple[2] = rP.mTuple[2];
  mTuple[3] = rP.mTuple[3];
 }

 return *this;
}
# 105 "/home/pete/code/wire3d/Wire/Foundation/WireQuaternion.h" 2

typedef Quaternion<Float> QuaternionF;
typedef Quaternion<Double> QuaternionD;

}
# 27 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireRandom.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireRandom.h"
       





namespace Wire
{


class Random
{
public:
 Random(UInt seed = 0);

 void Init(UInt seed);


 UInt Get();


 Float GetFloat();
 Double GetDouble();

protected:
 ULongLong mX[5];
};

}
# 28 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireString.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireString.h"
       





namespace Wire
{

class String
{
public:

 String(const Char* pText = __null);
 String(UInt length, const Char* pText);
 String(const String& rString);
 ~String();


 inline UInt GetLength() const;
 inline operator const Char* () const;


 String& operator= (const String& rString);
 String& operator+= (const String& rString);
 String operator+ (const String& rString) const;
 Bool operator== (const String& rString) const;
 Bool operator!= (const String& rString) const;


 String ToUpper() const;
 String ToLower() const;

private:
 UInt VerifyLength(UInt length, const Char* pText) const;

 UInt mLength;
 Char* mpText;
 static const Char* s_pEmpty;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireString.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireString.inl"
inline UInt String::GetLength() const
{
    return mLength;
}


inline String::operator const Char* () const
{
    return mpText;
}
# 51 "/home/pete/code/wire3d/Wire/Foundation/WireString.h" 2

}
# 30 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2


# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTHashSet.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireTHashSet.h"
       
# 27 "/home/pete/code/wire3d/Wire/Foundation/WireTHashSet.h"
namespace Wire
{

template <class TKEY>
class THashSet
{
public:

 THashSet(UInt tableSize = 128);
 ~THashSet ();


 inline UInt GetQuantity() const;




 TKEY* Insert(const TKEY& rKey);




 TKEY* Get(const TKEY& rKey) const;

 Bool Remove(const TKEY& rKey);
 void RemoveAll();


 UInt (*UserHashFunction)(const TKEY&);

 struct HashItem
 {
  TKEY mKey;
  HashItem* mpNext;
 };


 class Iterator
 {
 public:
  Iterator(THashSet* pHashSet);

  TKEY* GetFirst() const;
  TKEY* GetNext() const;

 private:
  THashSet* mpHashSet;
  mutable UInt mIndex;
  mutable HashItem* mpItem;
 };

private:


 UInt HashFunction(const TKEY& rKey) const;


 UInt mTableSize;
 UInt mQuantity;
 HashItem** mpTable;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTHashSet.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireTHashSet.inl"
template <class TKEY>
THashSet<TKEY>::THashSet(UInt tableSize)
 :
 UserHashFunction(__null),
 mTableSize(tableSize),
 mQuantity(0)
{
    mpTable = new HashItem*[mTableSize];
 ;
 System::Memset(mpTable, 0, mTableSize*sizeof(HashItem*));
}


template <class TKEY>
THashSet<TKEY>::~THashSet()
{
    RemoveAll();
    delete[] mpTable;
}


template <class TKEY>
inline UInt THashSet<TKEY>::GetQuantity() const
{
    return mQuantity;
}


template <class TKEY>
TKEY* THashSet<TKEY>::Insert(const TKEY& rKey)
{

    UInt index = HashFunction(rKey);
    HashItem* pItem = mpTable[index];


    while (pItem)
    {
        if (rKey == pItem->mKey)
        {

            return &pItem->mKey;
        }

        pItem = pItem->mpNext;
    }


    pItem = new HashItem;
    pItem->mKey = rKey;
    pItem->mpNext = mpTable[index];
    mpTable[index] = pItem;
    mQuantity++;

    return &pItem->mKey;
}


template <class TKEY>
TKEY* THashSet<TKEY>::Get(const TKEY& rtKey) const
{

    UInt index = HashFunction(rtKey);
    HashItem* pItem = mpTable[index];


    while (pItem)
    {
        if (rtKey == pItem->mKey)
        {

            return &pItem->mKey;
        }

        pItem = pItem->mpNext;
    }

    return __null;
}


template <class TKEY>
Bool THashSet<TKEY>::Remove(const TKEY& rKey)
{

    UInt index = HashFunction(rKey);
    HashItem* pItem = mpTable[index];

    if (!pItem)
    {
        return false;
    }

    if (rKey == pItem->mKey)
    {

        HashItem* pSave = pItem;
        mpTable[index] = pItem->mpNext;
        delete pSave;
        mQuantity--;
        return true;
    }


    HashItem* pPrev = pItem;
    HashItem* pCurr = pItem->mpNext;
    while (pCurr && rKey != pCurr->mKey)
    {
        pPrev = pCurr;
        pCurr = pCurr->mpNext;
    }

    if (pCurr)
    {

        pPrev->mpNext = pCurr->mpNext;
        delete pCurr;
        mQuantity--;
        return true;
    }

    return false;
}


template <class TKEY>
void THashSet<TKEY>::RemoveAll()
{
    if (mQuantity > 0)
    {
        for (UInt index = 0; index < mTableSize; index++)
        {
            while (mpTable[index])
            {
                HashItem* pSave = mpTable[index];
                mpTable[index] = mpTable[index]->mpNext;
                delete pSave;
                if (--mQuantity == 0)
                {
                    return;
                }
            }
        }
    }
}


template <class TKEY>
UInt THashSet<TKEY>::HashFunction(const TKEY& rKey) const
{
    if (UserHashFunction)
    {
        return (*UserHashFunction)(rKey);
    }


 static Double s_HashMultiplier = 0.5 * (MathD::Sqrt(5.0) - 1.0);
 UInt key = (UInt)(rKey);
 key %= mTableSize;
 Double fraction = MathD::FMod(s_HashMultiplier * key, 1.0);
 return static_cast<UInt>(MathD::Floor(mTableSize*fraction));
}


template <class TKEY>
THashSet<TKEY>::Iterator::Iterator(THashSet* pHashSet)
 :
 mpHashSet(pHashSet),
 mIndex(0),
 mpItem(__null)
{
 ;
}


template <class TKEY>
TKEY* THashSet<TKEY>::Iterator::GetFirst() const
{
    if (mpHashSet->mQuantity > 0)
    {
        for (mIndex = 0; mIndex < mpHashSet->mTableSize; mIndex++)
        {
            if (mpHashSet->mpTable[mIndex])
            {
                mpItem = mpHashSet->mpTable[mIndex];
                return &mpItem->mKey;
            }
        }
    }

    return __null;
}


template <class TKEY>
TKEY* THashSet<TKEY>::Iterator::GetNext() const
{
    if (mpHashSet->mQuantity > 0)
    {
        mpItem = mpItem->mpNext;
        if (mpItem)
        {
            return &mpItem->mKey;
        }

        for (mIndex++; mIndex < mpHashSet->mTableSize; mIndex++)
        {
            if (mpHashSet->mpTable[mIndex])
            {
                mpItem = mpHashSet->mpTable[mIndex];
                return &mpItem->mKey;
            }
        }
    }

    return __null;
}
# 90 "/home/pete/code/wire3d/Wire/Foundation/WireTHashSet.h" 2

}
# 33 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTList.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireTList.h"
       
# 21 "/home/pete/code/wire3d/Wire/Foundation/WireTList.h"
namespace Wire
{

template <class T>
class TList
{
public:

    TList();
    TList(const T& rItem, TList* pNext);
    ~TList();


    void SetItem(const T& rItem);
    T& Item();
    const T& GetItem() const;
    void SetNext(TList* pNext);
    TList*& Next();
    const TList* GetNext() const;


    UInt GetQuantity() const;

private:
    T mItem;
    TList* mpNext;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTList.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireTList.inl"
template <class T>
TList<T>::TList()
 :
 mpNext(__null)
{
}


template <class T>
TList<T>::TList(const T& rItem, TList* pNext)
    :
    mItem(rItem),
 mpNext(pNext)
{
}


template <class T>
TList<T>::~TList()
{
}


template <class T>
void TList<T>::SetItem(const T& rItem)
{
    mItem = rItem;
}


template <class T>
T& TList<T>::Item()
{
    return mItem;
}


template <class T>
const T& TList<T>::GetItem() const
{
    return mItem;
}


template <class T>
void TList<T>::SetNext(TList* pNext)
{
    mpNext = pNext;
}


template <class T>
TList<T>*& TList<T>::Next()
{
    return mpNext;
}


template <class T>
const TList<T>* TList<T>::GetNext() const
{
    return mpNext;
}


template <class T>
UInt TList<T>::GetQuantity() const
{
 UInt quantity = 0;
 for (const TList<T>* pIter = this; pIter; pIter = pIter->mpNext)
 {
  quantity++;
 }

 return quantity;
}
# 50 "/home/pete/code/wire3d/Wire/Foundation/WireTList.h" 2

}
# 35 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTMap.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireTMap.h"
       





namespace Wire
{

template <class TKEY, class TVALUE>
class TMap
{
public:

 TMap(UInt quantity = 0, UInt growBy = 1);
 ~TMap();

 struct MapElement
 {
  TKEY Key;
  TVALUE Value;
 };

 void Insert(const TKEY& rKey, const TVALUE& rValue);
 void Remove(const TKEY& rKey);
 TVALUE* Find(const TKEY& rKey);

 inline TArray<MapElement>* GetArray() { return mpArray; }

private:
 TArray<MapElement>* mpArray;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTMap.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireTMap.inl"
template <class TKEY, class TVALUE>
TMap<TKEY, TVALUE>::TMap(UInt quantity, UInt growBy)
{
 mpArray = new TArray<MapElement>(quantity, growBy);
}


template <class TKEY, class TVALUE>
TMap<TKEY, TVALUE>::~TMap()
{
 delete mpArray;
}


template <class TKEY, class TVALUE>
TVALUE* TMap<TKEY, TVALUE>::Find(const TKEY& rKey)
{
 const UInt quantity = mpArray->GetQuantity();
 UInt low = 0;
 UInt high = quantity;

 while (low < high)
 {
  UInt mid = low + (high - low) / 2;
  if ((*mpArray)[mid].Key < rKey)
  {
   low = mid + 1;
  }
  else
  {
   high = mid;
  }
 }

 if ((low < quantity) && ((*mpArray)[low].Key == rKey))
 {
  return &((*mpArray)[low].Value);
 }
 else
 {
  return __null;
 }
}


template <class TKEY, class TVALUE>
void TMap<TKEY, TVALUE>::Insert(const TKEY& rKey, const TVALUE& rValue)
{
 ;

 UInt low = 0;
 UInt high = mpArray->GetQuantity();

 while (low < high)
 {
  UInt mid = low + (high - low) / 2;
  if ((*mpArray)[mid].Key < rKey)
  {
   low = mid + 1;
  }
  else
  {
   high = mid;
  }
 }

 MapElement element;
 element.Key = rKey;
 element.Value = rValue;
 mpArray->Insert(low, element);
}


template <class TKEY, class TVALUE>
void TMap<TKEY, TVALUE>::Remove(const TKEY& rKey)
{
 const UInt quantity = mpArray->GetQuantity();
 UInt low = 0;
 UInt high = quantity;

 while (low < high)
 {
  UInt mid = low + (high - low) / 2;
  if ((*mpArray)[mid].Key < rKey)
  {
   low = mid + 1;
  }
  else
  {
   high = mid;
  }
 }

 ;
 mpArray->RemoveAt(low);
}
# 43 "/home/pete/code/wire3d/Wire/Foundation/WireTMap.h" 2

}
# 36 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTQueue.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireTQueue.h"
       
# 21 "/home/pete/code/wire3d/Wire/Foundation/WireTQueue.h"
namespace Wire
{

template <class T>
class TQueue
{
public:
    TQueue(UInt maxQuantity = 64);
    ~TQueue();

    inline Bool IsEmpty() const;
    inline Bool IsFull() const;
    void PushBack(const T& rItem);
    void PopFront(T& rItem);
 T& PopFront();
    void Clear();
    inline Bool GetFront(T& rItem) const;
 inline T& GetFront() const;

private:
    UInt mMaxQuantity;
 UInt mBack;
 UInt mFront;
    T* mpQueue;
 Bool mIsEmpty;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTQueue.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireTQueue.inl"
template <class T>
TQueue<T>::TQueue(UInt maxQuantity)
 :
 mMaxQuantity(maxQuantity),
 mBack(0),
 mFront(0),
 mIsEmpty(true)
{
    mpQueue = new T[mMaxQuantity];
}


template <class T>
TQueue<T>::~TQueue()
{
    delete[] mpQueue;
}


template <class T>
inline bool TQueue<T>::IsEmpty() const
{
    return mIsEmpty;
}


template <class T>
inline bool TQueue<T>::IsFull() const
{
 if (!mIsEmpty)
 {
  return (mBack+1) == mFront;
 }

 return false;
}


template <class T>
void TQueue<T>::PushBack(const T& rItem)
{
 if (!IsFull())
 {
  mpQueue[mBack++] = rItem;
  mIsEmpty = false;

  if (mBack >= mMaxQuantity)
  {
   mBack = mBack % mMaxQuantity;
  }
 }
 else
 {

  ;
 }
}


template <class T>
void TQueue<T>::PopFront(T& rItem)
{
 if (!mIsEmpty)
 {
  rItem = mpQueue[mFront++];

  if (mFront >= mMaxQuantity)
  {
   mFront = mFront % mMaxQuantity;
  }

  if (mFront == mBack)
  {
   mIsEmpty = true;
  }
 }
 else
 {

  ;
 }
}


template <class T>
T& TQueue<T>::PopFront()
{
 if (!mIsEmpty)
 {
  T& rItem = mpQueue[mFront++];

  if (mFront >= mMaxQuantity)
  {
   mFront = mFront % mMaxQuantity;
  }

  if (mFront == mBack)
  {
   mIsEmpty = true;
  }

  return rItem;
 }
 else
 {

  ;
  return mpQueue[mFront];
 }
}


template <class T>
void TQueue<T>::Clear()
{
    mBack = 0;
 mFront = 0;
 mIsEmpty = true;
}


template <class T>
inline bool TQueue<T>::GetFront(T& rItem) const
{
 if (!mIsEmpty)
    {
        rItem = mpQueue[mFront];
        return true;
    }

    return false;
}


template <class T>
inline T& TQueue<T>::GetFront() const
{
    ;
    return mpQueue[mFront];
}
# 49 "/home/pete/code/wire3d/Wire/Foundation/WireTQueue.h" 2

}
# 37 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2
# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTStack.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/WireTStack.h"
       
# 21 "/home/pete/code/wire3d/Wire/Foundation/WireTStack.h"
namespace Wire
{

template <class T>
class TStack
{
public:
 TStack(Int maxQuantity = 64);
 ~TStack();

 Bool IsEmpty() const;
 Bool IsFull() const;
 void Push(const T& rItem);
 void Pop(T& rItem);
 void Pop();
 void Clear();
 Bool GetTop(T& rItem) const;
 T& GetTop() const;


 inline Int GetQuantity() const;
 inline Int GetMaxQuantity() const;
 inline const T* GetData() const;

private:
    Int mMaxQuantity;
 Int mTop;
    T* mpStack;
};

# 1 "/home/pete/code/wire3d/Wire/Foundation/WireTStack.inl" 1
# 10 "/home/pete/code/wire3d/Wire/Foundation/WireTStack.inl"
template <class T>
TStack<T>::TStack(Int maxQuantity)
 :
 mMaxQuantity(maxQuantity),
 mTop(-1)
{
    ;
    mpStack = new T[mMaxQuantity];
}


template <class T>
TStack<T>::~TStack()
{
    delete[] mpStack;
}


template <class T>
Bool TStack<T>::IsEmpty() const
{
    return mTop == -1;
}


template <class T>
Bool TStack<T>::IsFull() const
{
    return mTop >= mMaxQuantity-1;
}


template <class T>
void TStack<T>::Push(const T& rkItem)
{
    mTop++;
    if (mTop <= mMaxQuantity-1)
    {
        mpStack[mTop] = rkItem;
    }
    else
    {

        ;
    }
}


template <class T>
void TStack<T>::Pop(T& rItem)
{
    if (mTop >= 0)
    {
        if (mTop <= mMaxQuantity-1)
        {
            rItem = mpStack[mTop];
        }
        else
        {

            ;
        }

        mTop--;
    }
    else
    {

        ;
    }
}


template <class T>
void TStack<T>::Pop()
{
    if (mTop >= 0)
    {
        if (mTop > mMaxQuantity-1)
        {

            ;
        }

        mTop--;
    }
    else
    {

        ;
    }
}


template <class T>
void TStack<T>::Clear()
{
    mTop = -1;
}


template <class T>
Bool TStack<T>::GetTop(T& rItem) const
{
    if (0 <= mTop && mTop <= mMaxQuantity-1)
    {
        rItem = mpStack[mTop];
        return true;
    }
    return false;
}


template <class T>
T& TStack<T>::GetTop() const
{
    ;
    return mpStack[mTop];
}


template <class T>
inline Int TStack<T>::GetQuantity() const
{
    return mTop+1;
}


template <class T>
inline Int TStack<T>::GetMaxQuantity() const
{
    return mMaxQuantity;
}


template <class T>
inline const T* TStack<T>::GetData() const
{
    return mpStack;
}
# 52 "/home/pete/code/wire3d/Wire/Foundation/WireTStack.h" 2

}
# 38 "/home/pete/code/wire3d/Wire/Foundation/WireFoundation.h" 2
# 15 "/home/pete/code/wire3d/Wire/Foundation/WireApplication.h" 2

namespace Wire
{

class Renderer;

class Application
{
public:

 virtual ~Application();

 virtual Int Main(Int argumentQuantity, Char* arguments[]) = 0;



  virtual Bool OnPrecreate() = 0;


 virtual Bool OnInitialize() = 0;


 virtual void OnIdle() = 0;


 virtual void OnTerminate() = 0;

 virtual void OnResize(UInt width, UInt height);

 static void SetApplication(Application* pApplication);
 static Application* GetApplication();

 inline Renderer* GetRenderer() const { return mpRenderer; }




 UInt KEY_TERMINATE;
 static const UInt KEY_ESCAPE;

protected:
 Application(const ColorRGBA& rBackgroundColor, const Char* pWindowTitle,
  Int xPosition, Int yPosition, UInt width, UInt height,
  Bool isFullscreen);


 static Application* s_pApplication;

 Renderer* mpRenderer;

 ColorRGBA mBackgroundColor;
 const Char* mpWindowTitle;
 Int mXPosition;
 Int mYPosition;
 UInt mWidth;
 UInt mHeight;
 Bool mIsFullscreen;
};

}






# 1 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireGXApplication.h" 1
# 9 "/home/pete/code/wire3d/Wire/Foundation/Wii/WireGXApplication.h"
       






namespace Wire
{

class GXApplication : public Application
{

public:
 GXApplication(const ColorRGBA& rBackgroundColor = ColorRGBA::BLACK,
  const Char* pWindowTitle = __null, Int xPosition = 0, Int yPosition = 0,
  UInt width = 640, UInt height = 480, Bool isFullscreen = true);

 virtual ~GXApplication();

 virtual Bool OnPrecreate();
 virtual Bool OnInitialize();
 virtual void OnTerminate();
 virtual void OnIdle();

private:


 virtual Int Main(Int argumentQuantity, Char* arguments[]);
};

}
# 82 "/home/pete/code/wire3d/Wire/Foundation/WireApplication.h" 2
# 12 "/home/pete/code/liiner/src/GameApplication.h" 2
using namespace Wire;







class GameApplication : public GXApplication
{

 public: static Bool RegisterInitialize(); static void Initialize(); private: static Bool s_InitializeRegistered;
 typedef GXApplication Parent;

public:

 virtual Bool OnPrecreate();
 virtual Bool OnInitialize();
 virtual void OnTerminate();
 virtual void OnIdle();

private:
 GeometryPtr mspCube;
 CameraPtr mspCamera;
 Vector3F cameraLocation;

};

static Bool gs_InitializeRegisteredGameApplication = GameApplication::RegisterInitialize();
# 9 "/home/pete/code/liiner/src/GameApplication.cpp" 2



using namespace Wire;

Bool GameApplication::s_InitializeRegistered = false; Bool GameApplication::RegisterInitialize() { if (!s_InitializeRegistered) { Main::AddInitializer(GameApplication::Initialize); s_InitializeRegistered = true; } return s_InitializeRegistered; }; void GameApplication::Initialize() { SetApplication(new GameApplication); } Int main(Int argc, Char** argv) { Main::Initialize(); Application* pApplication = Application::GetApplication(); if (pApplication) { pApplication->Main(argc, argv); delete pApplication; Application::SetApplication(__null); } Main::Terminate(); return 0; };

Bool GameApplication::OnPrecreate()
{





 if ( !Parent::OnPrecreate() )
 {
   return false;
 }

 return true;
}

Bool GameApplication::OnInitialize()
{



 if (!Parent::OnInitialize())
 {
   return false;
 }
# 51 "/home/pete/code/liiner/src/GameApplication.cpp"
 mspCube = StandardMesh::CreateCube8( 4);


 cameraLocation = Vector3F( 0.0F, 0.0F, 10.0F );
 Vector3F viewDirection(0.0F, 0.0F, -1.0F);
 Vector3F up(0.0F, 1.0F, 0.0F);
 mspCamera = new Camera(cameraLocation, viewDirection, up);

 return true;
}

void GameApplication::OnTerminate()
{
}

void GameApplication::OnIdle()
{

 int numPlayers = 2;
 for ( int i = 0; i < numPlayers; i ++ )
 {
  u32 pressed = WPAD_ButtonsHeld( i );
  bool left = pressed & 0x0100;
  bool right = pressed & 0x0200;
  bool boost = pressed & 0x0008;
  bool jump = pressed & 0x0004;

  if ( left )
  {
   cameraLocation = Vector3F( cameraLocation.X() - 1, cameraLocation.Y(), cameraLocation.Z() );
  }
  else if ( right )
  {
   cameraLocation = Vector3F( cameraLocation.X() + 1, cameraLocation.Y(), cameraLocation.Z() );
  }

  if ( boost )
  {



  }
  else if ( false )
  {

  }

  if ( jump )
  {

  }
 }


 Vector3F viewDirection(0.0F, 0.0F, -1.0F);
 Vector3F up(0.0F, 1.0F, 0.0F);
 this->mspCamera->LookAt( cameraLocation, viewDirection, up );

 Renderer* g = GetRenderer();
 g->ClearBuffers();
 g->PreDraw( mspCamera );

 g->Draw( mspCube );

 g->PostDraw();
 g->DisplayBackBuffer();

}
